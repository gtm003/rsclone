!function(t){var i={};function r(n){if(i[n])return i[n].exports;var e=i[n]={i:n,l:!1,exports:{}};return t[n].call(e.exports,e,e.exports,r),e.l=!0,e.exports}r.m=t,r.c=i,r.d=function(n,e,t){r.o(n,e)||Object.defineProperty(n,e,{enumerable:!0,get:t})},r.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},r.t=function(e,n){if(1&n&&(e=r(e)),8&n)return e;if(4&n&&"object"==typeof e&&e&&e.__esModule)return e;var t=Object.create(null);if(r.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:e}),2&n&&"string"!=typeof e)for(var i in e)r.d(t,i,function(n){return e[n]}.bind(null,i));return t},r.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return r.d(e,"a",e),e},r.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},r.p="",r(r.s="./js/main.js")}({"./js/main.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _utils_ie_fix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/ie-fix */ "./js/utils/ie-fix.js");\n/* harmony import */ var _modules_views_AppView__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modules/views/AppView */ "./js/modules/views/AppView.js");\n // Utils\n// ---------------------------------\n\nObject(_utils_ie_fix__WEBPACK_IMPORTED_MODULE_0__["ieFix"])(); // Modules\n// ---------------------------------\n\n\nvar appView = new _modules_views_AppView__WEBPACK_IMPORTED_MODULE_1__["AppView"](document.body);\nappView.init();\n\n//# sourceURL=webpack:///./js/main.js?')},"./js/modules/controllers/ColorPickerController.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ColorPickerController", function() { return ColorPickerController; });\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar ColorPickerController = /*#__PURE__*/function () {\n  function ColorPickerController(appView, model) {\n    _classCallCheck(this, ColorPickerController);\n\n    this.appView = appView;\n    this.model = model;\n    this.onChangeColorClick = this.onChangeColorClick.bind(this);\n  }\n\n  _createClass(ColorPickerController, [{\n    key: "addAllListeners",\n    value: function addAllListeners() {\n      this.appView.colorPicker.btnUserAnswerContainer.addEventListener(\'click\', this.onChangeColorClick);\n    }\n  }, {\n    key: "removeAllListeners",\n    value: function removeAllListeners() {\n      this.appView.colorPicker.btnUserAnswerContainer.removeEventListener(\'click\', this.onChangeColorClick);\n    }\n  }, {\n    key: "onChangeColorClick",\n    value: function onChangeColorClick(_ref) {\n      var target = _ref.target;\n\n      if (target.id === \'OK\') {\n        if (this.model.type === \'fill\') {\n          this.model.fillColor = this.appView.colorPicker.color; // [...this.appView.toolsLeftContainer.childNodes][7].style.background = this.appView.colorPicker.color;\n\n          _toConsumableArray(this.appView.toolsLeftContainer.childNodes)[7].querySelector(\'svg\').style.fill = this.appView.colorPicker.color;\n        } else if (this.model.type === \'stroke\') {\n          this.model.strokeColor = this.appView.colorPicker.color;\n          _toConsumableArray(this.appView.toolsLeftContainer.childNodes)[8].querySelector(\'svg\').style.fill = this.appView.colorPicker.color;\n        }\n\n        this.appView.colorPicker.closeColorPicker();\n      }\n\n      if (target.id === \'CANSEL\') {\n        this.appView.colorPicker.closeColorPicker();\n      }\n    }\n  }]);\n\n  return ColorPickerController;\n}();\n\n//# sourceURL=webpack:///./js/modules/controllers/ColorPickerController.js?')},"./js/modules/controllers/ContextMenuController.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ContextMenuController\", function() { return ContextMenuController; });\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar ContextMenuController = /*#__PURE__*/function () {\n  function ContextMenuController(appView, model) {\n    _classCallCheck(this, ContextMenuController);\n\n    this.appView = appView;\n    this.model = model;\n    this.onContextMenuClick = this.onContextMenuClick.bind(this);\n    this.onContextMenuMouseDown = this.onContextMenuMouseDown.bind(this);\n    this.onContextMenuElementsClick = this.onContextMenuElementsClick.bind(this);\n  }\n\n  _createClass(ContextMenuController, [{\n    key: \"addAllListeners\",\n    value: function addAllListeners() {\n      this.model.svgArea.node.addEventListener('contextmenu', this.onContextMenuClick);\n      this.model.svgArea.node.addEventListener('mousedown', this.onContextMenuMouseDown);\n      this.appView.contextMenuWindow.addEventListener('click', this.onContextMenuElementsClick);\n    }\n  }, {\n    key: \"removeAllListeners\",\n    value: function removeAllListeners() {\n      this.model.svgArea.node.removeEventListener('contextmenu', this.onContextMenuClick);\n      this.model.svgArea.node.removeEventListener('mousedown', this.onContextMenuMouseDown);\n      this.appView.contextMenuWindow.removeEventListener('click', this.onContextMenuElementsClick);\n    }\n  }, {\n    key: \"onContextMenuClick\",\n    value: function onContextMenuClick(evt) {\n      this.model.appearContextMenu(evt);\n    }\n  }, {\n    key: \"onContextMenuMouseDown\",\n    value: function onContextMenuMouseDown() {\n      this.appView.deleteVisibilityContextMenu();\n    }\n  }, {\n    key: \"onContextMenuElementsClick\",\n    value: function onContextMenuElementsClick(_ref) {\n      var target = _ref.target;\n\n      switch (target.dataset[this.appView.propertiesDataAttribute]) {\n        case 'Delete':\n          this.model.deleteElements();\n          this.appView.removeVisibilityPanel(this.model.selectElements);\n          break;\n\n        case 'Copy':\n          this.model.copyElements();\n          break;\n\n        case 'Paste':\n          this.model.pasteElements();\n          break;\n\n        case 'Bring to Front':\n          this.model.bringToFront();\n          break;\n\n        case 'Send to Back':\n          this.model.sendToBack();\n          break;\n      }\n    }\n  }]);\n\n  return ContextMenuController;\n}();\n\n//# sourceURL=webpack:///./js/modules/controllers/ContextMenuController.js?")},"./js/modules/controllers/Controller.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Controller", function() { return Controller; });\n/* harmony import */ var _models_SvgAreaModel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../models/SvgAreaModel */ "./js/modules/models/SvgAreaModel.js");\n/* harmony import */ var _MainMenuController__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./MainMenuController */ "./js/modules/controllers/MainMenuController.js");\n/* harmony import */ var _FunctionalAreaController__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./FunctionalAreaController */ "./js/modules/controllers/FunctionalAreaController.js");\n/* harmony import */ var _SvgAreaController__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./SvgAreaController */ "./js/modules/controllers/SvgAreaController.js");\n/* harmony import */ var _ToolsLeftController__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ToolsLeftController */ "./js/modules/controllers/ToolsLeftController.js");\n/* harmony import */ var _ContextMenuController__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ContextMenuController */ "./js/modules/controllers/ContextMenuController.js");\n/* harmony import */ var _HotKeysController__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./HotKeysController */ "./js/modules/controllers/HotKeysController.js");\n/* harmony import */ var _ColorPickerController__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./ColorPickerController */ "./js/modules/controllers/ColorPickerController.js");\n/* harmony import */ var _SignInModalController__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./SignInModalController */ "./js/modules/controllers/SignInModalController.js");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\n\n\n\n\n\n\n\nvar Controller = /*#__PURE__*/function () {\n  function Controller(appView, svgRootElement, viewModel, lastCondition) {\n    _classCallCheck(this, Controller);\n\n    this.appView = appView;\n    this.svgRootElement = svgRootElement;\n    this.viewModel = viewModel;\n    this.model = new _models_SvgAreaModel__WEBPACK_IMPORTED_MODULE_0__["SvgAreaModel"](this.appView, this.svgRootElement, lastCondition);\n    this.mainMenuController = null;\n    this.functionalAreaController = null;\n    this.svgAreaController = null;\n    this.toolsLeftController = null;\n    this.contextMenuController = null;\n    this.hotKeysController = null;\n    this.colorController = null;\n    this.signInModelController = null;\n  }\n\n  _createClass(Controller, [{\n    key: "init",\n    value: function init() {\n      this.model.init();\n      this.mainMenuController = new _MainMenuController__WEBPACK_IMPORTED_MODULE_1__["MainMenuController"](this.appView, this.model); // модуль контроллер Главного Меню и модалок связанных с ним\n\n      this.functionalAreaController = new _FunctionalAreaController__WEBPACK_IMPORTED_MODULE_2__["FunctionalAreaController"](this.appView, this.model); // модуль контроллер FunctionalArea\n\n      this.svgAreaController = new _SvgAreaController__WEBPACK_IMPORTED_MODULE_3__["SvgAreaController"](this.appView, this.model); // модуль контроллер SvgArea\n\n      this.toolsLeftController = new _ToolsLeftController__WEBPACK_IMPORTED_MODULE_4__["ToolsLeftController"](this.appView, this.model, this.svgAreaController); // модуль контроллер ToolsLeft\n\n      this.contextMenuController = new _ContextMenuController__WEBPACK_IMPORTED_MODULE_5__["ContextMenuController"](this.appView, this.model); // модуль контроллер ContextMenu\n\n      this.hotKeysController = new _HotKeysController__WEBPACK_IMPORTED_MODULE_6__["HotKeysController"](this.appView, this.model); // модуль контроллер HotKeys\n\n      this.colorController = new _ColorPickerController__WEBPACK_IMPORTED_MODULE_7__["ColorPickerController"](this.appView, this.model); // модуль контроллер ColorPicker\n\n      this.signInModelController = new _SignInModalController__WEBPACK_IMPORTED_MODULE_8__["SignInModalController"](this.appView, this.model); // модуль контроллер входа в систему\n\n      this.addAllListeners();\n    }\n  }, {\n    key: "remove",\n    value: function remove() {\n      this.removeAllListeners();\n      this.model.svgArea = null;\n      this.model = null;\n    }\n  }, {\n    key: "addAllListeners",\n    value: function addAllListeners() {\n      var _this = this;\n\n      this.model.svgArea.node.addEventListener(\'click\', function (e) {\n        _this.model.svgArea.node.tabIndex = \'1\';\n\n        _this.model.svgArea.node.focus();\n      });\n      this.mainMenuController.addAllListeners();\n      this.functionalAreaController.addAllListeners();\n      this.svgAreaController.addAllListeners();\n      this.toolsLeftController.addAllListeners();\n      this.contextMenuController.addAllListeners();\n      this.hotKeysController.addAllListeners();\n      this.colorController.addAllListeners();\n      this.signInModelController.addAllListeners();\n    }\n  }, {\n    key: "removeAllListeners",\n    value: function removeAllListeners() {\n      var _this2 = this;\n\n      this.model.svgArea.node.removeEventListener(\'click\', function (e) {\n        _this2.model.svgArea.node.tabIndex = \'1\';\n\n        _this2.model.svgArea.node.focus();\n      });\n      this.mainMenuController.removeAllListeners();\n      this.functionalAreaController.removeAllListeners();\n      this.svgAreaController.removeAllListeners();\n      this.toolsLeftController.removeAllListeners();\n      this.contextMenuController.removeAllListeners();\n      this.hotKeysController.removeAllListeners();\n      this.colorController.removeAllListeners();\n      this.model.removeSelect();\n    }\n  }]);\n\n  return Controller;\n}();\n\n//# sourceURL=webpack:///./js/modules/controllers/Controller.js?')},"./js/modules/controllers/FunctionalAreaController.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FunctionalAreaController\", function() { return FunctionalAreaController; });\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar FunctionalAreaController = /*#__PURE__*/function () {\n  function FunctionalAreaController(appView, model) {\n    _classCallCheck(this, FunctionalAreaController);\n\n    this.appView = appView;\n    this.model = model;\n    this.onPropertiesSVGElementKeyUp = this.onPropertiesSVGElementKeyUp.bind(this);\n    this.onDeleteElementsClick = this.onDeleteElementsClick.bind(this);\n    this.onSelectPropertyChange = this.onSelectPropertyChange.bind(this);\n    this.onAlignPanelClick = this.onAlignPanelClick.bind(this);\n  }\n\n  _createClass(FunctionalAreaController, [{\n    key: \"addAllListeners\",\n    value: function addAllListeners() {\n      this.appView.rectContainerPanel.addEventListener('keyup', this.onPropertiesSVGElementKeyUp);\n      this.appView.lineContainerPanel.addEventListener('keyup', this.onPropertiesSVGElementKeyUp);\n      this.appView.ellipseContainerPanel.addEventListener('keyup', this.onPropertiesSVGElementKeyUp);\n      this.appView.textContainerPanel.addEventListener('keyup', this.onPropertiesSVGElementKeyUp);\n      this.appView.pencilContainerPanel.addEventListener('keyup', this.onPropertiesSVGElementKeyUp);\n      this.appView.rectContainerPanel.addEventListener('click', this.onDeleteElementsClick);\n      this.appView.lineContainerPanel.addEventListener('click', this.onDeleteElementsClick);\n      this.appView.ellipseContainerPanel.addEventListener('click', this.onDeleteElementsClick);\n      this.appView.textContainerPanel.addEventListener('click', this.onDeleteElementsClick);\n      this.appView.selectProperty.addEventListener('change', this.onSelectPropertyChange);\n      this.appView.pencilContainerPanel.addEventListener('click', this.onDeleteElementsClick);\n      this.appView.alignContainerPanel.addEventListener('click', this.onAlignPanelClick);\n    }\n  }, {\n    key: \"removeAllListeners\",\n    value: function removeAllListeners() {\n      this.appView.rectContainerPanel.removeEventListener('keyup', this.onPropertiesSVGElementKeyUp);\n      this.appView.lineContainerPanel.removeEventListener('keyup', this.onPropertiesSVGElementKeyUp);\n      this.appView.ellipseContainerPanel.removeEventListener('keyup', this.onPropertiesSVGElementKeyUp);\n      this.appView.textContainerPanel.removeEventListener('keyup', this.onPropertiesSVGElementKeyUp);\n      this.appView.pencilContainerPanel.removeEventListener('keyup', this.onPropertiesSVGElementKeyUp);\n      this.appView.rectContainerPanel.removeEventListener('click', this.onDeleteElementsClick);\n      this.appView.lineContainerPanel.removeEventListener('click', this.onDeleteElementsClick);\n      this.appView.ellipseContainerPanel.removeEventListener('click', this.onDeleteElementsClick);\n      this.appView.textContainerPanel.removeEventListener('click', this.onDeleteElementsClick);\n      this.appView.selectProperty.removeEventListener('change', this.onSelectPropertyChange);\n      this.appView.pencilContainerPanel.removeEventListener('click', this.onDeleteElementsClick);\n      this.appView.alignContainerPanel.removeEventListener('click', this.onAlignPanelClick);\n    }\n  }, {\n    key: \"onPropertiesSVGElementKeyUp\",\n    value: function onPropertiesSVGElementKeyUp(_ref) {\n      var target = _ref.target;\n\n      if (target.dataset['delete'] !== 'delete' && target.dataset['convert'] !== 'convert') {\n        this.playSound();\n        this.model.changePropertiesSVGElement(target);\n      }\n    }\n  }, {\n    key: \"onDeleteElementsClick\",\n    value: function onDeleteElementsClick(_ref2) {\n      var target = _ref2.target;\n\n      if (target.closest('.tools-top__functional-area__container__btn--click') !== null) {\n        if (target.closest('.tools-top__functional-area__container__btn--click').dataset[this.appView.propertiesDataAttribute] === 'delete') {\n          this.model.deleteElements();\n        }\n      }\n    }\n  }, {\n    key: \"onSelectPropertyChange\",\n    value: function onSelectPropertyChange(_ref3) {\n      var target = _ref3.target;\n      this.model.changeSelectProperty(target);\n    }\n  }, {\n    key: \"onAlignPanelClick\",\n    value: function onAlignPanelClick(_ref4) {\n      var target = _ref4.target;\n\n      if (target.closest('.tools-top__functional-area__container__btn--click') !== null) {\n        var dataAttribute = target.closest('.tools-top__functional-area__container__btn--click').dataset[this.appView.alignPanelDataAttribute];\n\n        if (dataAttribute === 'disabled_by_default') {\n          this.model.deleteElements();\n        } else if (dataAttribute === 'timeline') {} else {\n          this.model.alignElements(dataAttribute);\n        }\n      }\n    }\n  }, {\n    key: \"playSound\",\n    value: function playSound() {\n      var context = new (window.AudioContext || window.webkitAudioContext)();\n      var osc = context.createOscillator();\n      var gainNode = context.createGain();\n      osc.connect(gainNode);\n      gainNode.connect(context.destination);\n      gainNode.gain.value = 0.1;\n      osc.frequency.value = 200;\n      osc.type = 'triangle';\n      osc.start();\n      setTimeout(function () {\n        osc.stop();\n      }, 150);\n    }\n  }]);\n\n  return FunctionalAreaController;\n}();\n\n//# sourceURL=webpack:///./js/modules/controllers/FunctionalAreaController.js?")},"./js/modules/controllers/HotKeysController.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"HotKeysController\", function() { return HotKeysController; });\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar HotKeysController = /*#__PURE__*/function () {\n  function HotKeysController(appView, model) {\n    _classCallCheck(this, HotKeysController);\n\n    this.appView = appView;\n    this.model = model;\n    this.onHotKeysKeyUp = this.onHotKeysKeyUp.bind(this);\n  }\n\n  _createClass(HotKeysController, [{\n    key: \"addAllListeners\",\n    value: function addAllListeners() {\n      this.model.svgArea.node.addEventListener('keyup', this.onHotKeysKeyUp);\n    }\n  }, {\n    key: \"removeAllListeners\",\n    value: function removeAllListeners() {\n      this.model.svgArea.node.removeEventListener('keyup', this.onHotKeysKeyUp);\n    }\n  }, {\n    key: \"onHotKeysKeyUp\",\n    value: function onHotKeysKeyUp(_ref) {\n      var key = _ref.key,\n          code = _ref.code,\n          ctrlKey = _ref.ctrlKey,\n          metaKey = _ref.metaKey;\n\n      if (key === 'Delete') {\n        this.model.deleteElements();\n      } else if ((ctrlKey || metaKey) && code === 'KeyC') {\n        // копировать\n        this.model.copyElements();\n      } else if ((ctrlKey || metaKey) && code === 'KeyV') {\n        // вставить\n        this.model.pasteElements();\n      } else if ((ctrlKey || metaKey) && code === 'KeyZ') {\n        // назад\n        this.model.unDo();\n      } else if ((ctrlKey || metaKey) && code === 'KeyY') {\n        // вперед\n        this.model.reDo();\n      }\n    }\n  }]);\n\n  return HotKeysController;\n}();\n\n//# sourceURL=webpack:///./js/modules/controllers/HotKeysController.js?")},"./js/modules/controllers/LoadingController.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LoadingController", function() { return LoadingController; });\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar LoadingController = /*#__PURE__*/function () {\n  function LoadingController(viewModel) {\n    _classCallCheck(this, LoadingController);\n\n    this.viewModel = viewModel;\n    this.onWindowBeforeUnload = this.onWindowBeforeUnload.bind(this);\n  }\n\n  _createClass(LoadingController, [{\n    key: "addAllListeners",\n    value: function addAllListeners() {\n      window.addEventListener(\'beforeunload\', this.onWindowBeforeUnload);\n    }\n  }, {\n    key: "onWindowBeforeUnload",\n    value: function onWindowBeforeUnload() {\n      this.viewModel.saveLastCondition();\n    }\n  }]);\n\n  return LoadingController;\n}();\n\n//# sourceURL=webpack:///./js/modules/controllers/LoadingController.js?')},"./js/modules/controllers/MainMenuController.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MainMenuController\", function() { return MainMenuController; });\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar MainMenuController = /*#__PURE__*/function () {\n  function MainMenuController(appView, model) {\n    _classCallCheck(this, MainMenuController);\n\n    this.appView = appView;\n    this.model = model;\n    this.onMenuButtonsClick = this.onMenuButtonsClick.bind(this);\n    this.onNewImageModalClick = this.onNewImageModalClick.bind(this);\n    this.onImportSvgChange = this.onImportSvgChange.bind(this);\n    this.onSaveModalClick = this.onSaveModalClick.bind(this);\n    this.onSettingsModalClick = this.onSettingsModalClick.bind(this);\n    this.onSvgCodeModalClick = this.onSvgCodeModalClick.bind(this);\n  }\n\n  _createClass(MainMenuController, [{\n    key: \"addAllListeners\",\n    value: function addAllListeners() {\n      this.appView.menuContainer.addEventListener('click', this.onMenuButtonsClick);\n      this.appView.menuContainer.addEventListener('change', this.onImportSvgChange);\n      this.appView.newImageModal.addEventListener('click', this.onNewImageModalClick);\n      this.appView.saveModal.addEventListener('click', this.onSaveModalClick);\n      this.appView.settingsModal.addEventListener('click', this.onSettingsModalClick);\n      this.appView.svgCodeModal.addEventListener('click', this.onSvgCodeModalClick);\n    }\n  }, {\n    key: \"removeAllListeners\",\n    value: function removeAllListeners() {\n      this.appView.menuContainer.removeEventListener('click', this.onMenuButtonsClick);\n      this.appView.menuContainer.removeEventListener('change', this.onImportSvgChange);\n      this.appView.newImageModal.removeEventListener('click', this.onNewImageModalClick);\n      this.appView.saveModal.removeEventListener('click', this.onSaveModalClick);\n      this.appView.settingsModal.removeEventListener('click', this.onSettingsModalClick);\n      this.appView.svgCodeModal.removeEventListener('click', this.onSvgCodeModalClick);\n    }\n  }, {\n    key: \"onMenuButtonsClick\",\n    value: function onMenuButtonsClick(_ref) {\n      var target = _ref.target;\n      this.appView.deleteVisibilityContextMenu();\n      var buttonDataAttribute = target.dataset[\"\".concat(this.appView.menuButtonsDataAttribute)];\n\n      if (buttonDataAttribute === 'Create') {\n        this.model.openNewImageModal();\n        this.model.selectElements = [];\n        this.appView.removeVisibilityPanel(this.model.selectElements);\n      } else if (buttonDataAttribute === 'Save') {\n        this.model.openModalSave();\n      } else if (buttonDataAttribute === 'Properties') {\n        this.model.openModalSettings();\n      } else if (buttonDataAttribute === 'Get the code') {\n        this.model.openModalSvgCode(); // console.log(JSON.stringify(this.model.getLastCondition()));\n        // console.log(this.model.getLastCondition());\n      }\n\n      var button = target.closest('[data-menu]');\n      if (!button) return;\n      var buttonId = button.dataset[\"\".concat(this.appView.menuButtonsDataAttribute)];\n\n      if (buttonId === 'Undo') {\n        this.model.unDo();\n        this.appView.removeVisibilityPanel(this.model.selectElements);\n      } else if (buttonId === 'Redo') {\n        this.model.reDo();\n        this.appView.removeVisibilityPanel(this.model.selectElements);\n      } //порефакторить\n\n    }\n  }, {\n    key: \"onImportSvgChange\",\n    value: function onImportSvgChange(_ref2) {\n      var target = _ref2.target;\n\n      if (target.dataset[\"\".concat(this.appView.menuButtonsDataAttribute)] === 'Import') {\n        this.model.uploadSVG(target);\n      }\n    }\n  }, {\n    key: \"onNewImageModalClick\",\n    value: function onNewImageModalClick(_ref3) {\n      var target = _ref3.target;\n      var buttonDataAttribute = target.dataset[\"\".concat(this.appView.newImageDataAttribute)];\n\n      if (buttonDataAttribute === 'ok') {\n        this.model.createNewImage();\n      } else if (buttonDataAttribute === 'cancel') {\n        this.model.closeNewImageModal();\n      }\n    }\n  }, {\n    key: \"onSaveModalClick\",\n    value: function onSaveModalClick(_ref4) {\n      var target = _ref4.target;\n      var buttonDataAttribute = target.dataset[\"\".concat(this.appView.saveElementsDataAttribute)];\n\n      if (buttonDataAttribute === 'save') {\n        if (this.appView.saveModal.classList.contains('modal-save--server')) {\n          this.model.saveFile(this.appView.inputFileName.value, 'server');\n        } else {\n          this.model.saveFile(this.appView.inputFileName.value, 'client');\n        }\n      } else if (buttonDataAttribute === 'cancel') {\n        this.model.closeModalSave();\n      }\n    }\n  }, {\n    key: \"onSettingsModalClick\",\n    value: function onSettingsModalClick(_ref5) {\n      var target = _ref5.target;\n      var buttonDataAttribute = target.dataset[\"\".concat(this.appView.settingsElementsDataAttribute)];\n\n      if (buttonDataAttribute === 'save') {\n        this.model.changeProperties();\n        this.model.closeModalSettings();\n      } else if (buttonDataAttribute === 'cancel') {\n        this.model.closeModalSettings();\n      }\n    }\n  }, {\n    key: \"onSvgCodeModalClick\",\n    value: function onSvgCodeModalClick(_ref6) {\n      var target = _ref6.target;\n      var buttonDataId = target.dataset[\"\".concat(this.appView.svgCodeDataAttribute)];\n      if (buttonDataId === 'cancel') this.model.closeModalSvgCode();\n    }\n  }]);\n\n  return MainMenuController;\n}();\n\n//# sourceURL=webpack:///./js/modules/controllers/MainMenuController.js?")},"./js/modules/controllers/SignInModalController.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SignInModalController\", function() { return SignInModalController; });\n/* harmony import */ var _views_SignInModal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../views/SignInModal */ \"./js/modules/views/SignInModal.js\");\n/* harmony import */ var _utils_createELement__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/createELement */ \"./js/utils/createELement.js\");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\nvar SignInModalController = /*#__PURE__*/function () {\n  function SignInModalController(appView, viewModel) {\n    _classCallCheck(this, SignInModalController);\n\n    this.appView = appView;\n    this.viewModel = viewModel;\n    this.signInModalObject = new _views_SignInModal__WEBPACK_IMPORTED_MODULE_0__[\"SignInModal\"](this.appView, this.appView.contentContainer);\n    this.openSignInModal = this.openSignInModal.bind(this);\n    this.onSignInModalClick = this.onSignInModalClick.bind(this);\n    this.onSignUpModalClick = this.onSignUpModalClick.bind(this);\n    this.onToolsRightProfileClick = this.onToolsRightProfileClick.bind(this);\n    this.onContainerModalOpenFilesClick = this.onContainerModalOpenFilesClick.bind(this);\n  }\n\n  _createClass(SignInModalController, [{\n    key: \"addAllListeners\",\n    value: function addAllListeners() {\n      this.appView.toolsRightContainer.addEventListener('click', this.openSignInModal);\n    }\n  }, {\n    key: \"openSignInModal\",\n    value: function openSignInModal(_ref) {\n      var target = _ref.target;\n\n      if (target.dataset[this.appView.signInButtonsDataAttribute] === 'Sign In') {\n        this.appView.signInModal = this.signInModalObject.createSignInModal(true);\n        this.appView.signInModal.addEventListener('click', this.onSignInModalClick);\n      } else if (target.dataset[this.appView.signInButtonsDataAttribute] === 'Sign Out') {\n        this.signInModalObject.changeButtonSign(false);\n        var lengthContainer = this.appView.toolsRightContainer.childNodes.length - 1;\n\n        for (var i = 0; i < lengthContainer; i += 1) {\n          this.appView.toolsRightContainer.childNodes[1].remove();\n        }\n      }\n    }\n  }, {\n    key: \"onSignInModalClick\",\n    value: function onSignInModalClick(_ref2) {\n      var _this = this;\n\n      var target = _ref2.target;\n\n      if (target.dataset[this.appView.signInButtonsDataAttribute] === 'Sign In') {\n        target.setAttribute('disabled', 'disabled');\n        var xhr = new XMLHttpRequest();\n        xhr.open('POST', 'https://rs-demo-back.herokuapp.com/auth/login');\n        xhr.responseType = 'json';\n        var email = this.appView.signInModal.childNodes[0].childNodes[0].value;\n        var password = this.appView.signInModal.childNodes[0].childNodes[1].value;\n\n        if (email !== '' && password !== '') {\n          var json = {\n            email: email,\n            password: password\n          };\n          xhr.setRequestHeader('Content-Type', 'application/json');\n          xhr.send(JSON.stringify(json));\n\n          xhr.onload = function () {\n            if (xhr.response.statusCode === 200) {\n              _this.appView.signInModal.removeEventListener('click', _this.onSignInModalClick);\n\n              _this.appView.signInModal.remove();\n\n              _this.viewModel.idClient = xhr.response.id;\n\n              _this.signInModalObject.changeButtonSign(true);\n\n              _this.signInModalObject.createProfile();\n\n              _this.appView.toolsRightContainer.addEventListener('click', _this.onToolsRightProfileClick);\n            } else {\n              _this.appView.signInModal.childNodes[1].textContent = xhr.response.reason;\n            }\n          };\n        }\n      } else if (target.dataset[this.appView.signInButtonsDataAttribute] === 'Sign Up') {\n        this.appView.signInModal.removeEventListener('click', this.onSignInModalClick);\n        this.appView.signInModal = this.signInModalObject.createSignInModal(false);\n        this.appView.signInModal.addEventListener('click', this.onSignUpModalClick);\n      } else if (target.dataset[this.appView.signInButtonsDataAttribute] === 'Cancel') {\n        this.appView.signInModal.removeEventListener('click', this.onSignInModalClick);\n        this.appView.signInModal.remove();\n      }\n    }\n  }, {\n    key: \"onSignUpModalClick\",\n    value: function onSignUpModalClick(_ref3) {\n      var _this2 = this;\n\n      var target = _ref3.target;\n\n      if (target.dataset[this.appView.signInButtonsDataAttribute] === 'Sign Up') {\n        target.setAttribute('disabled', 'disabled');\n        var xhr = new XMLHttpRequest();\n        xhr.open('POST', 'https://rs-demo-back.herokuapp.com/auth/register');\n        xhr.responseType = 'json';\n        var username = this.appView.signInModal.childNodes[0].childNodes[0].value;\n        var email = this.appView.signInModal.childNodes[0].childNodes[1].value;\n        var password = this.appView.signInModal.childNodes[0].childNodes[2].value;\n\n        if (username !== '' && email !== '' && password !== '') {\n          var json = {\n            username: username,\n            email: email,\n            password: password\n          };\n          xhr.setRequestHeader('Content-Type', 'application/json');\n          xhr.send(JSON.stringify(json));\n\n          xhr.onload = function () {\n            if (xhr.response.statusCode === 200) {\n              _this2.appView.signInModal.removeEventListener('click', _this2.onSignInModalClick);\n\n              _this2.appView.signInModal.remove();\n            } else {\n              _this2.appView.signInModal.childNodes[1].textContent = xhr.response.reason;\n            }\n          };\n        }\n      } else if (target.dataset[this.appView.signInButtonsDataAttribute] === 'Cancel') {\n        this.appView.signInModal.removeEventListener('click', this.onSignInModalClick);\n        this.appView.signInModal.remove();\n      }\n    }\n  }, {\n    key: \"onToolsRightProfileClick\",\n    value: function onToolsRightProfileClick(_ref4) {\n      var _this3 = this;\n\n      var target = _ref4.target;\n\n      if (target.dataset[this.appView.signInButtonsDataAttribute] === 'Open') {\n        var xhr = new XMLHttpRequest();\n        xhr.open('GET', \"https://rs-demo-back.herokuapp.com/auth/login/\".concat(this.viewModel.idClient));\n        xhr.responseType = 'json';\n        xhr.setRequestHeader('Content-Type', 'application/json');\n        xhr.send();\n\n        xhr.onload = function () {\n          _this3.filenames = xhr.response.filenames;\n          _this3.projects = xhr.response.projects;\n\n          _this3.signInModalObject.createModalOpen(_this3.filenames);\n\n          _this3.signInModalObject.containerModalOpenFiles.addEventListener('click', _this3.onContainerModalOpenFilesClick);\n        };\n      } else if (target.dataset[this.appView.signInButtonsDataAttribute] === 'Save') {\n        this.viewModel.openModalSave('server');\n      }\n    }\n  }, {\n    key: \"onContainerModalOpenFilesClick\",\n    value: function onContainerModalOpenFilesClick(_ref5) {\n      var target = _ref5.target;\n\n      if (target.dataset[this.appView.signInButtonsDataAttribute] === 'File') {\n        var index = this.filenames.indexOf(target.value);\n        console.log(this.projects[index]); // вот здесь делать создание нового холста по клику, мб придется перефакторить код\n      } else if (target.dataset[this.appView.signInButtonsDataAttribute] === 'Cancel') {\n        this.signInModalObject.containerModalOpenFiles.removeEventListener('click', this.onContainerModalOpenFilesClick);\n        this.signInModalObject.containerModalOpenFiles.remove();\n      }\n    }\n  }]);\n\n  return SignInModalController;\n}();\n\n//# sourceURL=webpack:///./js/modules/controllers/SignInModalController.js?")},"./js/modules/controllers/SvgAreaController.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SvgAreaController\", function() { return SvgAreaController; });\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar SvgAreaController = /*#__PURE__*/function () {\n  function SvgAreaController(appView, model) {\n    _classCallCheck(this, SvgAreaController);\n\n    this.appView = appView;\n    this.model = model;\n    this.onSvgAreaMouseDown = this.onSvgAreaMouseDown.bind(this);\n    this.onSvgAreaMouseMove = this.onSvgAreaMouseMove.bind(this);\n    this.onSvgAreaMouseUp = this.onSvgAreaMouseUp.bind(this);\n    this.onSvgAreaMouseLeave = this.onSvgAreaMouseLeave.bind(this);\n  }\n\n  _createClass(SvgAreaController, [{\n    key: \"addAllListeners\",\n    value: function addAllListeners() {\n      this.model.svgArea.mousedown(this.onSvgAreaMouseDown);\n    }\n  }, {\n    key: \"removeAllListeners\",\n    value: function removeAllListeners() {\n      this.model.rootElement.childNodes[0].removeEventListener('mouseleave', this.onSvgAreaMouseLeave);\n      this.model.svgArea.mousedown(null);\n      this.model.svgArea.mousemove(null);\n      this.model.svgArea.mouseup(null);\n    }\n  }, {\n    key: \"onSvgAreaMouseDown\",\n    value: function onSvgAreaMouseDown(e) {\n      if (e.which !== 1) return;\n      e.preventDefault();\n      this.model.rootElement.childNodes[0].addEventListener('mouseleave', this.onSvgAreaMouseLeave);\n      this.model.target = e.target;\n      this.model.x = e.offsetX;\n      this.model.y = e.offsetY;\n      if (this.model.isActiveText && e.target.instance.parent() !== this.model.elem) this.model.onTextBlur();\n      this.model.getTypeOfMouseDownAction(this.model.type, e);\n\n      if (this.model.type !== 'path') {\n        // This is a temporary option\n        this.model.svgArea.mousemove(this.onSvgAreaMouseMove);\n      } else if (this.model.isStartPath) {\n        this.model.svgArea.mousemove(this.onSvgAreaMouseMove);\n      }\n\n      this.model.svgArea.mouseup(this.onSvgAreaMouseUp);\n    }\n  }, {\n    key: \"onSvgAreaMouseMove\",\n    value: function onSvgAreaMouseMove(e) {\n      e.preventDefault();\n      this.model.wasMoved = true;\n      if (this.model.type === 'fill' || this.model.type === 'stroke') return;\n      this.model.getTypeOfMouseMoveAction(this.model.type, e);\n    }\n  }, {\n    key: \"onSvgAreaMouseUp\",\n    value: function onSvgAreaMouseUp(e) {\n      e.preventDefault();\n      if (this.model.type === 'fill' || this.model.type === 'stroke') return;\n      this.model.getTypeOfMouseUpAction(this.model.type);\n\n      if (this.model.wasMoved && !this.model.isSelectFrame && !this.model.isPath) {\n        this.model.saveHistory();\n      }\n\n      this.model.wasMoved = false;\n      this.model.isSelectFrame = false;\n      this.appView.removeVisibilityPanel(this.model.selectElements);\n      console.log(this.model.selectElements);\n\n      if (this.model.selectElements.length === 1) {\n        this.appView.updateFunctionalArea(this.model.getAttr(this.model.selectElements[0]));\n      }\n\n      if (this.model.type !== 'path') {\n        this.model.svgArea.mousemove(null);\n      } else if (this.model.isEndPath) {\n        this.model.svgArea.mousemove(null);\n      }\n\n      this.model.svgArea.mouseup(null);\n    }\n  }, {\n    key: \"onSvgAreaMouseLeave\",\n    value: function onSvgAreaMouseLeave(e) {\n      e.preventDefault();\n      this.model.svgArea.fire('mouseup');\n      this.model.svgArea.mousemove(null);\n      this.model.svgArea.mouseup(null); //для окончания рисования path\n\n      this.model.isEndPath = true;\n      this.model.pathNodeCount = 0;\n    }\n  }]);\n\n  return SvgAreaController;\n}();\n\n//# sourceURL=webpack:///./js/modules/controllers/SvgAreaController.js?")},"./js/modules/controllers/SwitcherLanguageController.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SwitcherLanguageController", function() { return SwitcherLanguageController; });\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar SwitcherLanguageController = /*#__PURE__*/function () {\n  function SwitcherLanguageController(appView, viewModel) {\n    _classCallCheck(this, SwitcherLanguageController);\n\n    this.appView = appView;\n    this.viewModel = viewModel;\n    this.onSwitcherLanguageClick = this.onSwitcherLanguageClick.bind(this);\n  }\n\n  _createClass(SwitcherLanguageController, [{\n    key: "addAllListeners",\n    value: function addAllListeners() {\n      this.appView.switcherContainer.addEventListener(\'click\', this.onSwitcherLanguageClick);\n    }\n  }, {\n    key: "removeAllListeners",\n    value: function removeAllListeners() {\n      this.appView.switcherContainer.removeEventListener(\'click\', this.onSwitcherLanguageClick);\n    }\n  }, {\n    key: "onSwitcherLanguageClick",\n    value: function onSwitcherLanguageClick(_ref) {\n      var target = _ref.target;\n\n      if (target.tagName === \'INPUT\') {\n        var menuButtons = _toConsumableArray(this.appView.menuContainer.childNodes).filter(function (item) {\n          return item.textContent.length !== 0;\n        });\n\n        var toolTips = _toConsumableArray(this.appView.toolsLeftContainer.childNodes).map(function (item) {\n          return item.lastChild;\n        });\n\n        var contextMenuButtons = _toConsumableArray(this.appView.contextMenuWindow.childNodes);\n\n        this.appView.deleteVisibilityContextMenu();\n\n        if (target.checked) {\n          this.viewModel.changeLanguage(menuButtons, toolTips, contextMenuButtons, \'rus\');\n        } else {\n          this.viewModel.changeLanguage(menuButtons, toolTips, contextMenuButtons, \'en\');\n        }\n      }\n    }\n  }]);\n\n  return SwitcherLanguageController;\n}();\n\n//# sourceURL=webpack:///./js/modules/controllers/SwitcherLanguageController.js?')},"./js/modules/controllers/TabsController.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TabsController", function() { return TabsController; });\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar TabsController = /*#__PURE__*/function () {\n  function TabsController(appView, viewModel) {\n    _classCallCheck(this, TabsController);\n\n    this.appView = appView;\n    this.viewModel = viewModel;\n    this.onToolsBottomClick = this.onToolsBottomClick.bind(this);\n  }\n\n  _createClass(TabsController, [{\n    key: "addAllListeners",\n    value: function addAllListeners() {\n      this.appView.toolsBottomContainer.addEventListener(\'click\', this.onToolsBottomClick);\n    }\n  }, {\n    key: "removeAllListeners",\n    value: function removeAllListeners() {\n      this.appView.toolsBottomContainer.removeEventListener(\'click\', this.onToolsBottomClick);\n    }\n  }, {\n    key: "onToolsBottomClick",\n    value: function onToolsBottomClick(_ref) {\n      var target = _ref.target;\n      var button = target.closest(\'[data-tab]\');\n      var tabDataId = button.dataset["".concat(this.appView.tabsDataAttribute)];\n\n      if (tabDataId) {\n        if (tabDataId === \'new\') {\n          this.viewModel.createNewTab();\n        } else if (tabDataId !== \'close\') {\n          this.viewModel.openTab(tabDataId);\n        }\n      }\n\n      var closeBtn = target.closest(\'.tools-bottom__tab-close\');\n\n      if (closeBtn) {\n        var numberClosedTab = closeBtn.previousSibling.dataset["".concat(this.appView.tabsDataAttribute)];\n        this.viewModel.closeTab(numberClosedTab);\n      }\n    }\n  }]);\n\n  return TabsController;\n}();\n\n//# sourceURL=webpack:///./js/modules/controllers/TabsController.js?')},"./js/modules/controllers/ToolsLeftController.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ToolsLeftController\", function() { return ToolsLeftController; });\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar ToolsLeftController = /*#__PURE__*/function () {\n  function ToolsLeftController(appView, model, svgAreaController) {\n    _classCallCheck(this, ToolsLeftController);\n\n    this.appView = appView;\n    this.model = model;\n    this.svgAreaController = svgAreaController; // убрать\n\n    this.onToolsLeftClick = this.onToolsLeftClick.bind(this);\n  }\n\n  _createClass(ToolsLeftController, [{\n    key: \"addAllListeners\",\n    value: function addAllListeners() {\n      this.appView.toolsLeftContainer.addEventListener('click', this.onToolsLeftClick);\n    }\n  }, {\n    key: \"removeAllListeners\",\n    value: function removeAllListeners() {\n      this.appView.toolsLeftContainer.removeEventListener('click', this.onToolsLeftClick);\n    }\n  }, {\n    key: \"onToolsLeftClick\",\n    value: function onToolsLeftClick(_ref) {\n      var target = _ref.target;\n\n      if (target.closest('button')) {\n        if (this.model.isActiveText) this.model.onTextBlur();\n        this.model.removeSelect();\n        var toolButtonId = target.closest('button').id;\n        this.model.type = toolButtonId;\n        this.model.changeActiveButton(toolButtonId); // this.model.svgArea.mousedown(null);\n        // this.model.svgArea.mousedown(this.svgAreaController.onSvgAreaMouseDown);\n        // this.svgAreaController.removeAllListeners();\n        // this.svgAreaController.addAllListeners();\n\n        if (toolButtonId === 'fill' || toolButtonId === 'stroke') {\n          this.appView.colorPicker.openColorPicker();\n        }\n      }\n    }\n  }]);\n\n  return ToolsLeftController;\n}();\n\n//# sourceURL=webpack:///./js/modules/controllers/ToolsLeftController.js?")},"./js/modules/models/MainViewModel.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MainViewModel", function() { return MainViewModel; });\n/* harmony import */ var _controllers_Controller__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../controllers/Controller */ "./js/modules/controllers/Controller.js");\n/* harmony import */ var _controllers_SwitcherLanguageController__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../controllers/SwitcherLanguageController */ "./js/modules/controllers/SwitcherLanguageController.js");\n/* harmony import */ var _controllers_TabsController__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../controllers/TabsController */ "./js/modules/controllers/TabsController.js");\n/* harmony import */ var _controllers_LoadingController__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../controllers/LoadingController */ "./js/modules/controllers/LoadingController.js");\n/* harmony import */ var _utils_btn_names__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../utils/btn-names */ "./js/utils/btn-names.js");\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\n\n\n\nvar MainViewModel = /*#__PURE__*/function () {\n  function MainViewModel(appView) {\n    _classCallCheck(this, MainViewModel);\n\n    this.appView = appView;\n    this.controllers = [];\n  }\n\n  _createClass(MainViewModel, [{\n    key: "init",\n    value: function init(tabsCount) {\n      new _controllers_SwitcherLanguageController__WEBPACK_IMPORTED_MODULE_1__["SwitcherLanguageController"](this.appView, this).addAllListeners();\n      new _controllers_TabsController__WEBPACK_IMPORTED_MODULE_2__["TabsController"](this.appView, this).addAllListeners();\n      new _controllers_LoadingController__WEBPACK_IMPORTED_MODULE_3__["LoadingController"](this).addAllListeners();\n      this.loadLastCondition(tabsCount);\n    }\n  }, {\n    key: "setActiveController",\n    value: function setActiveController(tabId) {\n      this.activeController = +tabId;\n    }\n  }, {\n    key: "callNewController",\n    value: function callNewController(tabsCount, lastCondition) {\n      this.controllers[this.activeController].removeAllListeners();\n      this.controllers = [].concat(_toConsumableArray(this.controllers), [new _controllers_Controller__WEBPACK_IMPORTED_MODULE_0__["Controller"](this.appView, this.appView.tabs[tabsCount], this, lastCondition)]);\n      this.controllers[this.controllers.length - 1].init();\n      this.setActiveController(tabsCount);\n    }\n  }, {\n    key: "changeController",\n    value: function changeController(tabId) {\n      this.controllers[this.activeController].removeAllListeners();\n      this.controllers[tabId].addAllListeners();\n      this.setActiveController(tabId);\n      this.controllers[tabId].model.changeActiveButton(this.controllers[tabId].model.type);\n    }\n  }, {\n    key: "createNewTab",\n    value: function createNewTab(lastCondition) {\n      this.removeActiveConditionTab();\n      this.removeActiveConditionTabControl();\n      this.appView.renderTab();\n      this.appView.renderTabControl();\n      this.callNewController(this.appView.tabs.length - 1, lastCondition);\n    }\n  }, {\n    key: "openTab",\n    value: function openTab(tabId) {\n      if (this.activeController === +tabId) return;\n      this.changeController(tabId);\n      this.removeActiveConditionTabControl();\n      this.setActiveConditionTabControl(tabId);\n      this.removeActiveConditionTab();\n      this.setActiveConditionTab(tabId);\n    }\n  }, {\n    key: "closeTab",\n    value: function closeTab(tabId) {\n      if (this.appView.tabs.length === 1) return;\n      this.controllers[tabId].remove();\n      this.controllers.splice(tabId, 1);\n      this.removeTabControl(tabId);\n      this.removeTab(tabId);\n      this.setActiveTab();\n    }\n  }, {\n    key: "setActiveConditionTabControl",\n    value: function setActiveConditionTabControl(tabId) {\n      this.appView.tabControls[tabId].classList.add(\'tools-bottom__tab-control--active\');\n    }\n  }, {\n    key: "removeActiveConditionTabControl",\n    value: function removeActiveConditionTabControl() {\n      this.appView.tabControls.forEach(function (tabControl) {\n        if (tabControl.classList.contains(\'tools-bottom__tab-control--active\')) tabControl.classList.remove(\'tools-bottom__tab-control--active\');\n      });\n    }\n  }, {\n    key: "setActiveConditionTab",\n    value: function setActiveConditionTab(tabId) {\n      this.appView.tabs[tabId].classList.add(\'tab--active\');\n    }\n  }, {\n    key: "removeActiveConditionTab",\n    value: function removeActiveConditionTab() {\n      this.appView.tabs.forEach(function (tab) {\n        if (tab.classList.contains(\'tab--active\')) tab.classList.remove(\'tab--active\');\n      });\n    }\n  }, {\n    key: "removeTabControl",\n    value: function removeTabControl(tabId) {\n      var _this = this;\n\n      this.appView.tabControls[tabId].parentElement.remove();\n      this.appView.tabControls.splice(tabId, 1);\n      this.appView.tabControls.forEach(function (tabControl, i) {\n        tabControl.dataset["".concat(_this.appView.tabsDataAttribute)] = i;\n        tabControl.textContent = "SVG ".concat(i);\n      });\n    }\n  }, {\n    key: "removeTab",\n    value: function removeTab(tabId) {\n      this.appView.tabs[tabId].remove();\n      this.appView.tabs.splice(tabId, 1);\n      this.appView.tabs.forEach(function (sheet, i) {\n        sheet.id = "sheet".concat(i);\n      });\n    }\n  }, {\n    key: "setActiveTab",\n    value: function setActiveTab() {\n      var _this2 = this;\n\n      var activeTabId;\n      this.appView.tabControls.forEach(function (tabControl) {\n        if (tabControl.classList.contains(\'tools-bottom__tab-control--active\')) {\n          activeTabId = +tabControl.dataset["".concat(_this2.appView.tabsDataAttribute)];\n        }\n      });\n\n      if (activeTabId === undefined) {\n        activeTabId = 0;\n        this.appView.tabControls[activeTabId].classList.add(\'tools-bottom__tab-control--active\');\n        this.appView.tabs[activeTabId].classList.add(\'tab--active\');\n        this.controllers[activeTabId].addAllListeners();\n      }\n\n      this.setActiveController(activeTabId);\n    }\n  }, {\n    key: "saveLastCondition",\n    value: function saveLastCondition() {\n      var appLastCondition = [];\n      this.controllers.forEach(function (controller) {\n        var tabLastCondition = controller.model.getLastCondition();\n        appLastCondition = [].concat(_toConsumableArray(appLastCondition), [tabLastCondition]);\n      });\n      localStorage.setItem(\'SvgEditor_lastCondition\', JSON.stringify(appLastCondition));\n    }\n  }, {\n    key: "loadLastCondition",\n    value: function loadLastCondition(tabsCount) {\n      var _this3 = this;\n\n      var lastConditions = JSON.parse(localStorage.getItem(\'SvgEditor_lastCondition\'));\n\n      if (lastConditions === null || lastConditions.length === 0) {\n        this.controllers = [].concat(_toConsumableArray(this.controllers), [new _controllers_Controller__WEBPACK_IMPORTED_MODULE_0__["Controller"](this.appView, this.appView.tabs[tabsCount], this)]);\n        this.controllers[tabsCount].init();\n        this.setActiveController(tabsCount);\n        return;\n      }\n\n      lastConditions.forEach(function (lastCondition, i) {\n        if (i === 0) {\n          _this3.controllers = [].concat(_toConsumableArray(_this3.controllers), [new _controllers_Controller__WEBPACK_IMPORTED_MODULE_0__["Controller"](_this3.appView, _this3.appView.tabs[i], _this3, lastCondition)]);\n\n          _this3.controllers[i].init();\n\n          _this3.setActiveController(i);\n        } else {\n          _this3.createNewTab(lastCondition);\n        }\n      });\n      this.openTab(tabsCount);\n    }\n  }, {\n    key: "changeLanguage",\n    value: function changeLanguage(menuButtons, toolTips, contextMenuButtons, strLang) {\n      menuButtons.forEach(function (item, index) {\n        if (strLang === \'rus\') {\n          item.textContent = _utils_btn_names__WEBPACK_IMPORTED_MODULE_4__["MENU_BUTTONS_NAMES_RUS"][index];\n        } else {\n          item.textContent = _utils_btn_names__WEBPACK_IMPORTED_MODULE_4__["MENU_BUTTONS_NAMES_EN"][index];\n        }\n      });\n      toolTips.forEach(function (item, index) {\n        if (strLang === \'rus\') {\n          item.textContent = _utils_btn_names__WEBPACK_IMPORTED_MODULE_4__["TOOLS_LEFT_NAMES_RUS"][index];\n        } else {\n          item.textContent = _utils_btn_names__WEBPACK_IMPORTED_MODULE_4__["TOOLS_LEFT_NAMES_EN"][index];\n        }\n      });\n      contextMenuButtons.forEach(function (item, index) {\n        if (strLang === \'rus\') {\n          item.textContent = _utils_btn_names__WEBPACK_IMPORTED_MODULE_4__["CONTEXTMENU_NAMES_RUS"][index];\n        } else {\n          item.textContent = _utils_btn_names__WEBPACK_IMPORTED_MODULE_4__["CONTEXTMENU_NAMES_EN"][index];\n        }\n      });\n    }\n  }]);\n\n  return MainViewModel;\n}();\n\n//# sourceURL=webpack:///./js/modules/models/MainViewModel.js?')},"./js/modules/models/SvgAreaModel.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SvgAreaModel\", function() { return SvgAreaModel; });\n/* harmony import */ var _vendor_svg_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../vendor/svg.js */ \"./js/vendor/svg.js\");\n/* harmony import */ var _vendor_svg_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_vendor_svg_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _vendor_svg_select_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../vendor/svg.select.js */ \"./js/vendor/svg.select.js\");\n/* harmony import */ var _vendor_svg_select_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_vendor_svg_select_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _vendor_svg_resize_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../vendor/svg.resize.js */ \"./js/vendor/svg.resize.js\");\n/* harmony import */ var _vendor_svg_resize_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_vendor_svg_resize_js__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _vendor_svg_path_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../vendor/svg.path.js */ \"./js/vendor/svg.path.js\");\n/* harmony import */ var _vendor_svg_path_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_vendor_svg_path_js__WEBPACK_IMPORTED_MODULE_3__);\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\n\n\nvar FILE_TYPE = 'svg';\nvar SvgAreaModel = /*#__PURE__*/function () {\n  function SvgAreaModel(appView, rootElement, lastCondition) {\n    _classCallCheck(this, SvgAreaModel);\n\n    this.appView = appView;\n    this.rootElement = rootElement;\n    this.lastCondition = lastCondition;\n    this.svgArea = null;\n    this.type = 'select';\n    this.selectElements = [];\n    this.copiedElements = [];\n    this.setSelectElements = new Set();\n    this.fillColor = 'transparent';\n    this.strokeColor = 'rgba(0, 0, 0, 1)';\n    this.elem = null;\n    this.selectFrame = null;\n    this.mouseDownElemSVG = null;\n    this.text = '';\n    this.isActiveText = false;\n    this.pathArray = [];\n    this.isStartPath = false;\n    this.isEndPath = false;\n    this.isPath = false;\n    this.pathNodeCount = 0;\n    this.segmentPathStraight = false;\n    this.elemCounter = 0;\n    this.target = null;\n    this.x = null;\n    this.y = null;\n    this.xLast = null;\n    this.yLast = null;\n    this.history = [];\n    this.historyPosition = 0;\n    this.isFirstSaveHistory = false;\n    this.wasMoved = false;\n    this.isSelectFrame = false;\n    this.inputText = this.inputText.bind(this);\n    this.idClient = null;\n  }\n\n  _createClass(SvgAreaModel, [{\n    key: \"getTypeOfMouseDownAction\",\n    value: function getTypeOfMouseDownAction(type, e) {\n      var _this = this;\n\n      var mouseDownActions = {\n        select: function select(e) {\n          return _this.selectDown(e);\n        },\n        rect: function rect(e) {\n          return _this.createRect(e);\n        },\n        ellipse: function ellipse(e) {\n          return _this.createEllipse(e);\n        },\n        line: function line(e) {\n          return _this.createLine(e);\n        },\n        text: function text(e) {\n          return _this.textDown(e);\n        },\n        pencil: function pencil(e) {\n          return _this.createPencilTrace(e);\n        },\n        path: function path(e) {\n          return _this.pathDown(e);\n        },\n        fill: function fill(e) {\n          return _this.changeFillColor(e);\n        },\n        stroke: function stroke(e) {\n          return _this.changeStrokeColor(e);\n        }\n      };\n      return mouseDownActions[type](e);\n    }\n  }, {\n    key: \"getTypeOfMouseMoveAction\",\n    value: function getTypeOfMouseMoveAction(type, e) {\n      var _this2 = this;\n\n      var mouseMoveActions = {\n        select: function select(e) {\n          return _this2.selectMove(e);\n        },\n        rect: function rect(e) {\n          return _this2.drawRect(e, _this2.elem);\n        },\n        ellipse: function ellipse(e) {\n          return _this2.drawEllipse(e);\n        },\n        line: function line(e) {\n          return _this2.drawLine(e);\n        },\n        text: function text(e) {\n          return _this2.resizeText(e);\n        },\n        pencil: function pencil(e) {\n          return _this2.drawPencilTrace(e);\n        },\n        path: function path(e) {\n          return _this2.pathMove(e);\n        }\n      };\n      return mouseMoveActions[type](e);\n    }\n  }, {\n    key: \"getTypeOfMouseUpAction\",\n    value: function getTypeOfMouseUpAction(type) {\n      var _this3 = this;\n\n      var mouseUpActions = {\n        select: function select() {\n          return _this3.selectUp();\n        },\n        rect: function rect() {\n          return _this3.finishDrawElem();\n        },\n        ellipse: function ellipse() {\n          return _this3.finishDrawElem();\n        },\n        line: function line() {\n          return _this3.finishDrawElem();\n        },\n        text: function text() {\n          return _this3.finishResizeText();\n        },\n        pencil: function pencil() {\n          return _this3.finishDrawElem();\n        },\n        path: function path() {\n          return _this3.pathUp();\n        }\n      };\n      return mouseUpActions[type]();\n    }\n  }, {\n    key: \"selectDown\",\n    value: function selectDown(e) {\n      var _this4 = this;\n\n      //console.log(this.getAttr(e.target.instance));\n      //console.log(e.target.instance.attr());\n      this.mouseDownElemSVG = e.target.instance;\n\n      if (this.mouseDownElemSVG.type === 'tspan') {\n        this.mouseDownElemSVG = this.mouseDownElemSVG.parent();\n      }\n\n      if (this.mouseDownElemSVG.type === 'svg') {\n        this.selectElements.forEach(function (elem) {\n          return _this4.removeSelectSingleElem(elem);\n        });\n        this.selectFrame = this.svgArea.rect(0, 0).stroke('rgba(0, 90, 180, 0.8)').fill('rgba(0, 90, 180, 0.5)');\n        this.selectFrame.transform({\n          x: e.offsetX\n        }).transform({\n          y: e.offsetY\n        });\n        this.selectFrame.attr('id', 'select-frame');\n        this.isSelectFrame = true;\n      } else {\n        if (!e.ctrlKey) {\n          if (!this.mouseDownElemSVG.hasClass('selectedElem')) {\n            this.selectElements.forEach(function (elem) {\n              if (_this4.mouseDownElemSVG !== elem) _this4.removeSelectSingleElem(elem);\n            });\n          }\n        }\n\n        this.rememberCoordCenter(this.mouseDownElemSVG);\n        this.selectElements.forEach(function (elem) {\n          return _this4.rememberCoordCenter(elem);\n        });\n      }\n    }\n  }, {\n    key: \"selectMove\",\n    value: function selectMove(e) {\n      var _this5 = this;\n\n      if (this.mouseDownElemSVG.type === 'svg' && this.selectFrame !== null) {\n        this.drawRect(e, this.selectFrame);\n      } else {\n        if (this.selectElements.length === 0) {\n          this.moveSingleElem(e, this.mouseDownElemSVG);\n        } else {\n          this.selectElements.forEach(function (elem) {\n            return _this5.moveSingleElem(e, elem);\n          });\n        }\n      }\n    }\n  }, {\n    key: \"selectUp\",\n    value: function selectUp() {\n      var _this6 = this;\n\n      if (this.selectFrame !== null) {\n        this.svgArea.children().forEach(function (elem) {\n          if (_this6.rectanglesOverlap(_this6.selectFrame, elem) && _this6.selectFrame !== elem) {\n            _this6.selectSingleElem(elem);\n          }\n        });\n        this.selectFrame.remove();\n        this.selectFrame = null;\n      }\n\n      if (this.mouseDownElemSVG.type !== 'svg') {\n        if (!this.mouseDownElemSVG.hasClass('selectedElem')) {\n          this.selectSingleElem(this.mouseDownElemSVG);\n        }\n\n        console.log(\"x: \".concat(this.mouseDownElemSVG.x()));\n        console.log(\"xTransform \".concat(this.mouseDownElemSVG.transform('x')));\n        console.log(\"cx: \".concat(this.mouseDownElemSVG.cx()));\n        console.log(\"cxrbox\".concat(this.mouseDownElemSVG.rbox().cx));\n        console.log(\"xrbox\".concat(this.mouseDownElemSVG.rbox().x)); //console.log(`xrboxSVGArea${this.svgArea.rbox().x}`);\n        // this.onMouseMoveG();\n      }\n    }\n  }, {\n    key: \"selectSingleElem\",\n    value: function selectSingleElem(elem) {\n      elem.selectize().resize();\n      elem.addClass('selectedElem');\n      this.setSelectElements.add(elem);\n      this.selectElements = _toConsumableArray(this.setSelectElements); //console.log(this.getAttr(elem));\n    }\n  }, {\n    key: \"rectanglesOverlap\",\n    value: function rectanglesOverlap(r1, r2) {\n      var dimX = 0;\n      var dimY = 0;\n      if (r1.transform('x') < r2.transform('x')) dimX = r2.transform('x') + r2.width() - r1.transform('x');else dimX = r1.transform('x') + r1.width() - r2.transform('x');\n      if (r1.transform('y') < r2.transform('y')) dimY = r2.transform('y') + r2.height() - r1.transform('y');else dimY = r1.transform('y') + r1.height() - r2.transform('y');\n      return dimX < r1.width() + r2.width() && dimY < r1.height() + r2.height();\n    }\n  }, {\n    key: \"removeSelectSingleElem\",\n    value: function removeSelectSingleElem(elem) {\n      elem.resize('stop').selectize(false);\n      elem.removeClass('selectedElem');\n      this.setSelectElements.delete(elem);\n      this.selectElements = _toConsumableArray(this.setSelectElements);\n    }\n  }, {\n    key: \"moveSingleElem\",\n    value: function moveSingleElem(e, elem) {\n      elem.transform({\n        x: e.offsetX - this.x + elem.xLast\n      });\n      elem.transform({\n        y: e.offsetY - this.y + elem.yLast\n      });\n      this.appView.updateFunctionalArea(this.getAttr(this.selectElements[0])); // Почему-то не срабатывает на move\n    }\n  }, {\n    key: \"rememberCoordCenter\",\n    value: function rememberCoordCenter(elem) {\n      elem.xLast = elem.transform('x');\n      elem.yLast = elem.transform('y');\n    }\n  }, {\n    key: \"init\",\n    value: function init() {\n      this.createNewSvgWorkArea();\n      this.loadLastCondition();\n      this.isFirstSaveHistory = true;\n      this.saveHistory();\n    }\n  }, {\n    key: \"createNewSvgWorkArea\",\n    value: function createNewSvgWorkArea() {\n      this.svgArea = SVG(this.rootElement).size('600', '400');\n      this.svgArea.node.classList.add('svg-work-area');\n    } // resizeSvgArea(svgWidth, svgHeight) {\n    //   this.svgArea.size(svgWidth, svgHeight);\n    // }\n\n  }, {\n    key: \"createRect\",\n    value: function createRect(e) {\n      this.elem = this.svgArea.rect(0, 0).stroke(this.strokeColor).fill(this.fillColor);\n      this.elem.attr('stroke-width', 2);\n      this.elem.transform({\n        x: e.offsetX\n      }).transform({\n        y: e.offsetY\n      });\n    }\n  }, {\n    key: \"createCursor\",\n    value: function createCursor() {\n      var cursor = this.elem.tspan('׀').fill('#000').stroke('none');\n      var cursorColor = '#000';\n\n      function cursorFlicker() {\n        if (cursorColor === '#000') {\n          cursorColor = 'transparent';\n          cursor.fill(cursorColor);\n        } else {\n          cursorColor = '#000';\n          cursor.fill(cursorColor);\n        }\n\n        setTimeout(cursorFlicker, 500);\n      }\n\n      cursorFlicker();\n    }\n  }, {\n    key: \"textDown\",\n    value: function textDown(e) {\n      if (!this.isActiveText) {\n        if (e.target.instance.type === 'tspan') {\n          this.editText(e);\n        } else {\n          this.createText(e);\n        }\n      }\n    }\n  }, {\n    key: \"createText\",\n    value: function createText(e) {\n      this.isActiveText = true;\n      this.elem = this.svgArea.text('').stroke(this.strokeColor).fill(this.fillColor);\n      this.elem.transform({\n        x: e.offsetX\n      }).transform({\n        y: e.offsetY\n      });\n      var tspan = this.elem.tspan('');\n      this.elem.build(true);\n      this.createCursor();\n      this.elem.build(false);\n      this.elem.font({\n        family: 'Helvetica',\n        size: 20,\n        anchor: 'left',\n        leading: '0em'\n      });\n    }\n  }, {\n    key: \"resizeText\",\n    value: function resizeText(e) {\n      if (this.elem !== null && this.text === '') {\n        this.elem.selectize().resize();\n        this.elem.font({\n          family: 'Helvetica',\n          size: Math.abs(e.offsetY - this.y)\n        });\n        this.elem.transform({\n          y: e.offsetY\n        });\n      }\n    }\n  }, {\n    key: \"finishResizeText\",\n    value: function finishResizeText() {\n      if (this.text === '') {\n        var tspan = this.elem.tspan('l');\n        tspan.fill('transparent').stroke('transparent');\n        tspan.dy(\"\".concat(1.3 * this.elem.font('size')));\n        var yLast = this.elem.transform('y');\n        this.elem.transform({\n          y: yLast - 1.3 * this.elem.font('size')\n        }); //this.elem.dy(`${-1.3 * this.elem.font('size')}`);\n\n        this.elem.build(true);\n        this.createCursor();\n        this.elem.build(false);\n        document.addEventListener('keydown', this.inputText);\n      }\n    }\n  }, {\n    key: \"onTextBlur\",\n    value: function onTextBlur() {\n      if (this.elem !== null) {\n        if (this.text === '') {\n          this.elem.resize('stop').selectize(false);\n          this.elem.remove();\n          this.elem = null; //this.type = 'select';\n        } else {\n          var tspan = this.elem.tspan(this.text);\n          tspan.dy(\"\".concat(1.3 * this.elem.font('size')));\n          this.elem.resize('stop').selectize(false);\n          this.text = '';\n        }\n      }\n\n      this.isActiveText = false;\n      document.removeEventListener('keydown', this.inputText);\n      this.saveHistory();\n    }\n  }, {\n    key: \"editText\",\n    value: function editText(e) {\n      this.isActiveText = true;\n      this.elem = e.target.instance.parent();\n      this.text = this.elem.text();\n      this.elem.build(true);\n      this.createCursor();\n      this.elem.build(false);\n      document.addEventListener('keydown', this.inputText);\n    }\n  }, {\n    key: \"inputText\",\n    value: function inputText(event) {\n      if (this.type === 'text' && event.key.length < 2) {\n        this.text += event.key;\n        var tspan = this.elem.tspan(this.text);\n        tspan.dy(\"\".concat(1.3 * this.elem.font('size')));\n        this.elem.build(true);\n        this.createCursor();\n        this.elem.build(false);\n        this.elem.resize('stop').selectize(false);\n        this.elem.selectize().resize();\n      }\n\n      if (this.type === 'text' && event.key === 'Backspace') {\n        this.text = this.text.slice(0, -1);\n\n        var _tspan = this.elem.tspan(this.text);\n\n        _tspan.dy(\"\".concat(1.3 * this.elem.font('size')));\n\n        this.elem.build(true);\n        this.createCursor();\n        this.elem.build(false);\n        this.elem.resize('stop').selectize(false);\n        this.elem.selectize().resize();\n      }\n    }\n  }, {\n    key: \"createPencilTrace\",\n    value: function createPencilTrace(e) {\n      this.elem = this.svgArea.path([['M', e.offsetX, e.offsetY]]).stroke(this.strokeColor).fill(this.fillColor);\n      this.elem.attr('stroke-width', 2);\n    }\n  }, {\n    key: \"pathDown\",\n    value: function pathDown(e) {\n      this.isPath = true;\n\n      if (this.pathNodeCount) {\n        this.isStartPath = false;\n        var xFirst = this.elem.transform('x');\n        var yFirst = this.elem.transform('y');\n\n        if (this.xLast === e.offsetX && this.yLast === e.offsetY) {\n          this.isEndPath = true;\n        } else {\n          this.elem.removeSegment(this.pathNodeCount);\n\n          if (e.shiftKey) {\n            this.drawDirectAnglePath(e);\n          } else {\n            this.elem.L({\n              x: e.offsetX - xFirst,\n              y: e.offsetY - yFirst\n            });\n          }\n        }\n      } else {\n        this.elem = this.svgArea.path().M(0, 0).stroke(this.strokeColor).fill(this.fillColor);\n        this.elem.transform({\n          x: e.offsetX\n        }).transform({\n          y: e.offsetY\n        });\n        this.elem.attr('stroke-width', 2);\n        this.isStartPath = true;\n        this.isEndPath = false;\n      }\n\n      this.pathNodeCount += 1;\n      console.log(this.elem.array());\n    }\n  }, {\n    key: \"drawDirectAnglePath\",\n    value: function drawDirectAnglePath(e) {\n      var lastPoinCoord = this.getPointsCoord(this.elem).pop();\n      var xFirst = this.elem.transform('x');\n      var yFirst = this.elem.transform('y');\n      var xLast = lastPoinCoord[0];\n      var yLast = lastPoinCoord[1];\n      var xDelta = Math.abs(e.offsetX - xLast - xFirst);\n      var yDelta = Math.abs(e.offsetY - yLast - yFirst);\n      var xSign = (e.offsetX - xLast - xFirst) / Math.abs(e.offsetX - xLast - xFirst);\n      var ySign = (e.offsetY - yLast - yFirst) / Math.abs(e.offsetY - yLast - yFirst);\n      var xEnd, yEnd;\n\n      if (Math.min(xDelta, yDelta) / Math.max(xDelta, yDelta) > 0.5) {\n        xEnd = xLast + xSign * Math.max(xDelta, yDelta);\n        yEnd = yLast + ySign * Math.max(xDelta, yDelta);\n        this.elem.L({\n          x: xEnd,\n          y: yEnd\n        });\n      } else {\n        if (xDelta < yDelta) {\n          this.elem.V(e.offsetY - yFirst);\n        } else {\n          this.elem.H(e.offsetX - xFirst);\n        }\n      }\n    }\n  }, {\n    key: \"pathMove\",\n    value: function pathMove(e) {\n      var xFirst = this.elem.transform('x');\n      var yFirst = this.elem.transform('y');\n\n      if (e.shiftKey) {\n        this.elem.removeSegment(this.pathNodeCount);\n        this.drawDirectAnglePath(e);\n      } else {\n        this.elem.removeSegment(this.pathNodeCount);\n        this.elem.L({\n          x: e.offsetX - xFirst,\n          y: e.offsetY - yFirst\n        });\n      }\n    }\n  }, {\n    key: \"pathUp\",\n    value: function pathUp(e) {\n      if (this.isEndPath) {\n        this.isPath = false;\n        this.saveHistory();\n        this.pathNodeCount = 0; //console.log(this.elem.array());\n        //console.log(this.getPathArray(this.elem));\n        //this.elem.plot(this.getPathArray(this.elem));\n        //console.log(this.elem.array());\n\n        console.log(this.getPointsCoord(this.elem));\n      }\n\n      this.xLast = this.x;\n      this.yLast = this.y;\n    }\n  }, {\n    key: \"getPointsCoord\",\n    value: function getPointsCoord(elem) {\n      var allPointsCoord = [];\n      var segmentCount = elem.getSegmentCount();\n\n      for (var i = 0; i < segmentCount; i += 1) {\n        var pointCoord = [];\n\n        switch (elem.getSegment(i).type) {\n          case 'M':\n          case 'L':\n            pointCoord = pointCoord.concat(elem.getSegment(i).coords);\n            break;\n\n          case 'H':\n            pointCoord = pointCoord.concat([elem.getSegment(i).coords[0], allPointsCoord[i - 1][1]]);\n            break;\n\n          case 'V':\n            pointCoord = pointCoord.concat([allPointsCoord[i - 1][0], elem.getSegment(i).coords[0]]);\n            break;\n        }\n\n        allPointsCoord.push(pointCoord);\n      }\n\n      return allPointsCoord;\n    }\n  }, {\n    key: \"getPathArray\",\n    value: function getPathArray(elem) {\n      var pathArray = [];\n      var pathNodeCount = elem.getSegmentCount();\n\n      for (var i = 0; i < pathNodeCount; i += 1) {\n        var nodeArray = [elem.getSegment(i).type];\n        nodeArray = nodeArray.concat(elem.getSegment(i).coords);\n        pathArray.push(nodeArray);\n      }\n\n      return pathArray;\n    }\n  }, {\n    key: \"changeFillColor\",\n    value: function changeFillColor(e) {\n      e.target.instance.fill(this.fillColor);\n      this.saveHistory();\n    }\n  }, {\n    key: \"changeStrokeColor\",\n    value: function changeStrokeColor(e) {\n      e.target.instance.stroke(this.strokeColor);\n      this.saveHistory();\n    }\n  }, {\n    key: \"drawRect\",\n    value: function drawRect(e, elem) {\n      var xNew, yNew, xDelta, yDelta;\n      xDelta = Math.abs(e.offsetX - this.x);\n      yDelta = Math.abs(e.offsetY - this.y);\n\n      if (e.shiftKey) {\n        if (e.offsetX < this.x) {\n          xNew = this.x - Math.max(xDelta, yDelta);\n        } else if (e.offsetX >= this.x) {\n          xNew = this.x;\n        }\n\n        if (e.offsetY < this.y) {\n          yNew = this.y - Math.max(xDelta, yDelta);\n        } else if (e.offsetY >= this.y) {\n          yNew = this.y;\n        }\n\n        elem.attr({\n          width: Math.max(Math.abs(e.offsetX - this.x), Math.abs(e.offsetY - this.y)),\n          height: Math.max(Math.abs(e.offsetX - this.x), Math.abs(e.offsetY - this.y))\n        });\n        elem.transform({\n          x: xNew\n        }).transform({\n          y: yNew\n        });\n      } else {\n        xNew = Math.min(e.offsetX, this.x);\n        yNew = Math.min(e.offsetY, this.y);\n        elem.attr({\n          width: Math.abs(e.offsetX - this.x),\n          height: Math.abs(e.offsetY - this.y)\n        });\n        elem.transform({\n          x: xNew\n        }).transform({\n          y: yNew\n        });\n      }\n    }\n  }, {\n    key: \"createEllipse\",\n    value: function createEllipse(e) {\n      this.elem = this.svgArea.ellipse(0, 0).stroke(this.strokeColor).fill(this.fillColor);\n      this.elem.attr('stroke-width', 2);\n      this.elem.transform({\n        x: e.offsetX\n      }).transform({\n        y: e.offsetY\n      });\n    }\n  }, {\n    key: \"drawEllipse\",\n    value: function drawEllipse(e) {\n      if (e.shiftKey) {\n        this.elem.attr({\n          rx: Math.sqrt(Math.pow(e.offsetX - this.x, 2) + Math.pow(e.offsetY - this.y, 2)),\n          ry: Math.sqrt(Math.pow(e.offsetX - this.x, 2) + Math.pow(e.offsetY - this.y, 2))\n        });\n        this.elem.transform({\n          x: e.offsetX\n        }).transform({\n          y: e.offsetY\n        });\n      } else {\n        this.elem.attr({\n          rx: Math.abs(e.offsetX - this.x),\n          ry: Math.abs(e.offsetY - this.y)\n        });\n      }\n    }\n  }, {\n    key: \"createLine\",\n    value: function createLine(e) {\n      this.elem = this.svgArea.line(0, 0, 0, 0).stroke(this.strokeColor).fill(this.fillColor);\n      this.elem.attr('stroke-width', 3);\n      this.elem.transform({\n        x: e.offsetX\n      }).transform({\n        y: e.offsetY\n      });\n    }\n  }, {\n    key: \"drawLine\",\n    value: function drawLine(e) {\n      if (e.shiftKey) {\n        var xDelta = Math.abs(e.offsetX - this.x);\n        var yDelta = Math.abs(e.offsetY - this.y);\n        var xSign = (e.offsetX - this.x) / Math.abs(e.offsetX - this.x);\n        var ySign = (e.offsetY - this.y) / Math.abs(e.offsetY - this.y);\n        var xEnd, yEnd;\n\n        if (Math.min(xDelta, yDelta) / Math.max(xDelta, yDelta) > 0.5) {\n          xEnd = xSign * Math.max(xDelta, yDelta);\n          yEnd = ySign * Math.max(xDelta, yDelta);\n        } else {\n          if (xDelta < yDelta) {\n            xEnd = 0;\n            yEnd = ySign * yDelta;\n          } else {\n            xEnd = xSign * xDelta;\n            yEnd = 0;\n          }\n        }\n\n        this.elem.attr({\n          x2: xEnd,\n          y2: yEnd\n        });\n      } else {\n        this.elem.attr({\n          x2: e.offsetX - this.x,\n          y2: e.offsetY - this.y\n        });\n      }\n    }\n  }, {\n    key: \"drawPencilTrace\",\n    value: function drawPencilTrace(e) {\n      var arr = this.elem.array().value;\n      arr.push(['C', e.offsetX, e.offsetY, e.offsetX, e.offsetY, e.offsetX, e.offsetY]);\n      this.elem.plot(arr);\n    }\n  }, {\n    key: \"addPathNewNode\",\n    value: function addPathNewNode(e) {\n      console.log(this.segmentPathStraight);\n\n      if (this.segmentPathStraight) {\n        var arr = this.path.array().value;\n        arr.push(['C', e.offsetX, e.offsetY, e.offsetX, e.offsetY, e.offsetX, e.offsetY]);\n        this.path.plot(arr);\n        console.log(arr);\n      } else {}\n    }\n  }, {\n    key: \"finishDrawElem\",\n    value: function finishDrawElem() {\n      if (this.isEmptyElem(this.elem)) {\n        this.elem.remove();\n        this.elem = this.svgArea.last();\n\n        if (this.target.nodeName !== 'svg') {\n          this.type = 'select';\n          this.changeActiveButton(this.type);\n        }\n      } else {\n        if (this.elem !== null) {\n          this.elemCounter += 1;\n          this.elem.attr('id', \"svg_\".concat(this.elemCounter));\n          var previousElem = this.elem.previous();\n\n          if (previousElem.node.nodeName !== 'defs') {\n            this.removeSelectSingleElem(previousElem.previous());\n          }\n\n          if (this.elem.type === 'text') {\n            this.elem = this.elem.node.instance;\n          }\n\n          this.selectSingleElem(this.elem);\n        }\n      }\n    }\n  }, {\n    key: \"isEmptyElem\",\n    value: function isEmptyElem(elem) {\n      if (elem !== null) {\n        if (elem.width() === 0 && elem.height() === 0) return true;else return false;\n      }\n    } //                  GetAttribute\n\n  }, {\n    key: \"getAttr\",\n    value: function getAttr(elem) {\n      var svgAreaX = this.svgArea.rbox().x;\n      var svgAreaY = this.svgArea.rbox().y;\n      var matrix = new SVG.Matrix(elem);\n      var pointStart = new SVG.Point(0, 0);\n      var pointEnd = new SVG.Point(0, 0);\n      var size = null;\n\n      if (elem.type === 'line') {\n        pointEnd = new SVG.Point(elem.attr('x2'), elem.attr('y2'));\n      }\n\n      if (elem.type === 'text') {\n        size = elem.font('size');\n      }\n\n      var attrOBJ = {\n        type: elem.type,\n        id: elem.attr('id'),\n        class: elem.attr('class'),\n        angle: elem.transform('rotation'),\n        stroke: elem.attr('stroke-width'),\n        x: Math.round(elem.rbox().x - svgAreaX),\n        y: Math.round(elem.rbox().y - svgAreaY),\n        width: Math.round(elem.width()),\n        height: Math.round(elem.height()),\n        cx: Math.round(elem.rbox().cx - svgAreaX),\n        cy: Math.round(elem.rbox().cy - svgAreaY),\n        rx: Math.round(elem.width() / 2),\n        ry: Math.round(elem.height() / 2),\n        x1: Math.round(pointStart.transform(matrix).x + elem.attr('x1')),\n        y1: Math.round(pointStart.transform(matrix).y + elem.attr('y1')),\n        x2: Math.round(pointEnd.transform(matrix).x),\n        y2: Math.round(pointEnd.transform(matrix).y),\n        size: Math.round(size)\n      };\n      return attrOBJ;\n    }\n  }, {\n    key: \"removeSelect\",\n    value: function removeSelect() {\n      this.svgArea.each(function () {\n        if (this.hasClass('selectedElem')) {\n          this.removeClass('selectedElem');\n          this.resize('stop').selectize(false);\n        }\n      });\n      this.setSelectElements.clear();\n      this.selectElements = _toConsumableArray(this.setSelectElements);\n    }\n  }, {\n    key: \"onMouseMoveG\",\n    value: function onMouseMoveG() {\n      var _this7 = this;\n\n      var arrayG = _toConsumableArray(_toConsumableArray(this.rootElement.childNodes)[0].childNodes).filter(function (value) {\n        return value.tagName === 'g';\n      });\n\n      var arrayElementG = _toConsumableArray(arrayG[0].childNodes);\n\n      arrayElementG.shift();\n\n      for (var i = 0; i < arrayElementG.length; i += 1) {\n        arrayElementG[i].addEventListener('mousemove', function () {\n          console.log(_this7.selectElements);\n\n          if (_this7.selectElements.length === 1) {\n            _this7.appView.updateFunctionalArea(_this7.getAttr(_this7.selectElements[0]));\n          }\n        });\n      }\n    } // из контроллера часть alexk08\n\n  }, {\n    key: \"saveHistory\",\n    value: function saveHistory() {\n      var svgElements = this.svgArea.children();\n      var svgElementsWithoutG = svgElements.filter(function (initializer) {\n        return initializer.type !== 'g';\n      }).map(function (initializer) {\n        if (initializer.type === 'defs') {\n          return initializer;\n        }\n\n        if (initializer.type === 'text') {\n          return [initializer.type, initializer.attr(), initializer.node.childNodes[0].textContent];\n        }\n\n        if (initializer.type === 'path') {\n          if (initializer._segments) {\n            return [initializer.type, initializer._segments];\n          }\n\n          return [initializer.type, initializer.attr()];\n        }\n\n        return [initializer.type, initializer.attr()];\n      });\n      var svgProp = [this.svgArea.type, this.svgArea.attr()];\n      svgElementsWithoutG.push(svgProp);\n      this.history = this.history.slice(0, this.historyPosition + 1);\n      this.history.push(svgElementsWithoutG);\n      if (!this.isFirstSaveHistory) this.historyPosition++;\n      this.isFirstSaveHistory = false;\n    }\n  }, {\n    key: \"unDo\",\n    value: function unDo() {\n      var _this8 = this;\n\n      this.selectElements = [];\n      if (!this.historyPosition) return;\n      this.historyPosition -= 1;\n      this.svgArea.clear(); // this.history[this.historyPosition].forEach(initializer => this.svgArea.add(initializer));\n\n      this.history[this.historyPosition].forEach(function (data) {\n        if (data.type === 'defs') {\n          _this8.svgArea.add(data);\n\n          return;\n        }\n\n        _this8.drawAfterFirstLoading(data);\n      });\n    }\n  }, {\n    key: \"reDo\",\n    value: function reDo() {\n      var _this9 = this;\n\n      this.selectElements = [];\n      if (this.historyPosition > this.history.length - 2) return;\n      this.historyPosition += 1;\n      this.svgArea.clear(); // this.history[this.historyPosition].forEach(initializer => this.svgArea.add(initializer));\n\n      this.history[this.historyPosition].forEach(function (data) {\n        if (data.type === 'defs') {\n          _this9.svgArea.add(data);\n\n          return;\n        }\n\n        _this9.drawAfterFirstLoading(data);\n      });\n    }\n  }, {\n    key: \"getLastCondition\",\n    value: function getLastCondition() {\n      this.removeSelect();\n      var svgElements = this.svgArea.children();\n\n      var svgData = _toConsumableArray(svgElements.filter(function (initializer) {\n        return initializer.type !== 'defs';\n      }).map(function (initializer) {\n        if (initializer.type === 'text') {\n          return [initializer.type, initializer.attr(), initializer.node.childNodes[0].textContent];\n        }\n\n        if (initializer.type === 'path') {\n          if (initializer._segments) {\n            return [initializer.type, initializer._segments];\n          }\n\n          return [initializer.type, initializer.attr()];\n        }\n\n        return [initializer.type, initializer.attr()];\n      }));\n\n      var svgProp = [this.svgArea.type, this.svgArea.attr()];\n      svgData.push(svgProp);\n      return svgData;\n    }\n  }, {\n    key: \"loadLastCondition\",\n    value: function loadLastCondition() {\n      var _this10 = this;\n\n      if (!this.lastCondition || this.lastCondition.length === 0) return;\n      this.lastCondition.forEach(function (data) {\n        return _this10.drawAfterFirstLoading(data);\n      });\n    }\n  }, {\n    key: \"drawAfterFirstLoading\",\n    value: function drawAfterFirstLoading(data) {\n      var type = data[0];\n      var attr = data[1] || []; //костыль из-за pencil\n\n      var text = data[2];\n\n      if (type === 'svg') {\n        this.svgArea.size(attr.width, attr.height);\n      } else if (type === 'rect') {\n        this.svgArea.rect().attr(attr);\n      } else if (type === 'ellipse') {\n        this.svgArea.ellipse().attr(attr);\n      } else if (type === 'line') {\n        this.svgArea.line().attr(attr);\n      } else if (type === 'text') {\n        this.svgArea.text(\"\".concat(text)).attr(attr);\n      } else if (type === 'path') {\n        Array.isArray(attr) ? this.drawPathAfterLoading(attr) : this.svgArea.path().attr(attr);\n      }\n    }\n  }, {\n    key: \"drawPathAfterLoading\",\n    value: function drawPathAfterLoading(segments) {\n      var elem = this.svgArea.path();\n      segments.forEach(function (segment) {\n        if (segment.type === 'M') {\n          elem.M(segment.coords[0], segment.coords[1]);\n        } else if (segment.type === 'L') {\n          elem.L(segment.coords[0], segment.coords[1]);\n        } else if (segment.type === 'V') {\n          elem.V(segment.coords[0]);\n        } else if (segment.type === 'H') {\n          elem.H(segment.coords[0]);\n        }\n      });\n      elem.stroke(this.strokeColor).fill(this.fillColor);\n    }\n  }, {\n    key: \"createNewImage\",\n    value: function createNewImage() {\n      this.selectElements = [];\n      this.svgArea.each(function () {\n        if (this.type !== 'defs') this.remove();\n      });\n      this.closeNewImageModal();\n      this.history = [];\n      this.historyPosition = 0;\n      this.isFirstSaveHistory = true;\n      this.saveHistory();\n    }\n  }, {\n    key: \"openNewImageModal\",\n    value: function openNewImageModal() {\n      this.appView.newImageModal.classList.add('modal-new-image--show');\n    }\n  }, {\n    key: \"closeNewImageModal\",\n    value: function closeNewImageModal() {\n      this.appView.newImageModal.classList.remove('modal-new-image--show');\n    }\n  }, {\n    key: \"openModalSvgCode\",\n    value: function openModalSvgCode() {\n      var textArea = this.appView.svgCodeModal.querySelector('textarea');\n      textArea.innerHTML = '';\n      this.appView.svgCodeModal.classList.toggle('modal-svg-code--show');\n      this.removeSelect();\n      textArea.textContent = this.rootElement.innerHTML;\n    }\n  }, {\n    key: \"closeModalSvgCode\",\n    value: function closeModalSvgCode() {\n      this.appView.svgCodeModal.classList.remove('modal-svg-code--show');\n    }\n  }, {\n    key: \"openModalSettings\",\n    value: function openModalSettings() {\n      this.appView.settingsModal.classList.add('modal-settings--show');\n      var svgWidthInput = this.appView.settingsModal.querySelector('[data-modal-settings=\"width\"]');\n      var svgHeightInput = this.appView.settingsModal.querySelector('[data-modal-settings=\"height\"]');\n      svgWidthInput.focus();\n      svgWidthInput.value = this.svgArea.attr().width;\n      svgHeightInput.value = this.svgArea.attr().height;\n    }\n  }, {\n    key: \"closeModalSettings\",\n    value: function closeModalSettings() {\n      this.appView.settingsModal.classList.remove('modal-settings--show');\n    }\n  }, {\n    key: \"changeProperties\",\n    value: function changeProperties() {\n      var svgWidth = this.appView.settingsModal.querySelector('[data-modal-settings=\"width\"]').value;\n      var svgHeight = this.appView.settingsModal.querySelector('[data-modal-settings=\"height\"]').value; // this.resizeSvgArea(svgWidth, svgHeight);\n\n      this.svgArea.size(svgWidth, svgHeight);\n      this.saveHistory();\n    }\n  }, {\n    key: \"openModalSave\",\n    value: function openModalSave(flagStr) {\n      if (flagStr === 'server') {\n        this.appView.saveModal.classList.add('modal-save--server');\n      } else {\n        this.appView.saveModal.classList.add('modal-save--show');\n      }\n\n      this.appView.inputFileName.focus();\n    }\n  }, {\n    key: \"closeModalSave\",\n    value: function closeModalSave() {\n      this.appView.inputFileName.value = '';\n      this.appView.errorMessage.style.visibility = 'hidden';\n      this.appView.saveModal.classList.remove('modal-save--show', 'modal-save--server');\n    }\n  }, {\n    key: \"saveFile\",\n    value: function saveFile(fileName, flagStr) {\n      if (fileName === '') {\n        this.appView.errorMessage.style.visibility = 'visible';\n        return;\n      }\n\n      this.closeModalSave();\n      this.removeSelect();\n\n      if (flagStr === 'client') {\n        this.downloadClient(this.svgArea.svg(), fileName, 'image/svg+xml');\n      } else if (flagStr === 'server') {\n        this.downloadServer(this.svgArea.svg(), fileName, 'image/svg+xml');\n      }\n    }\n  }, {\n    key: \"downloadClient\",\n    value: function downloadClient(data, filename, type) {\n      var file = new Blob([data], {\n        type: type\n      });\n\n      if (window.navigator.msSaveOrOpenBlob) {\n        // IE10+\n        window.navigator.msSaveOrOpenBlob(file, filename);\n      } else {\n        // Others\n        var a = document.createElement('a');\n        var url = URL.createObjectURL(file);\n        a.href = url;\n        a.download = filename;\n        document.body.appendChild(a);\n        a.click();\n        setTimeout(function () {\n          document.body.removeChild(a);\n          window.URL.revokeObjectURL(url);\n        }, 0);\n      }\n    }\n  }, {\n    key: \"downloadServer\",\n    value: function downloadServer(data, filename, type) {\n      var xhr = new XMLHttpRequest();\n      console.log(this.idClient);\n      xhr.open('PUT', 'https://rs-demo-back.herokuapp.com/auth/save');\n      xhr.responseType = 'json';\n      xhr.setRequestHeader('Content-Type', 'application/json');\n      var id = this.idClient;\n      var filenames = filename;\n      var projects = this.getLastCondition(); // for (let i = 0; i < projects.length; i += 1) {\n      //   projects[i][1] = JSON.stringify(projects[i][1]);\n      // }\n\n      var json = {\n        id: id,\n        filenames: filenames,\n        projects: projects\n      };\n      console.log(this.getLastCondition());\n      console.log(json);\n      xhr.send(JSON.stringify(json)); // почему-то пишет cors, хотя все есть\n\n      xhr.onload = function () {\n        console.log(xhr.response);\n      };\n    }\n  }, {\n    key: \"uploadSVG\",\n    value: function uploadSVG(input) {\n      var _this11 = this;\n\n      var file = input.files[0];\n      var fileName = file.name.toLowerCase();\n\n      if (fileName.endsWith(FILE_TYPE)) {\n        var reader = new FileReader();\n        reader.addEventListener('load', function () {\n          _this11.svgArea.svg(reader.result);\n        });\n        reader.readAsText(file);\n      }\n    }\n  }, {\n    key: \"changeActiveButton\",\n    value: function changeActiveButton(buttonId) {\n      var activeButton = this.appView.toolsLeftContainer.querySelector('.active');\n      if (activeButton) activeButton.classList.remove('active');\n      this.appView.toolsLeftContainer.querySelector(\"#\".concat(buttonId)).classList.add('active');\n    } // часть по functionalArea 11alexey11\n\n  }, {\n    key: \"changePropertiesSVGElement\",\n    value: function changePropertiesSVGElement(target) {\n      this.appView.deleteVisibilityContextMenu();\n      var objSVG = this.selectElements[0];\n      var svgAreaX = this.svgArea.rbox().x;\n      var svgAreaY = this.svgArea.rbox().y;\n\n      switch (target.dataset[this.appView.propertiesDataAttribute]) {\n        case 'angle':\n          if (target.value.length !== 0) {\n            objSVG.rotate(target.value);\n          } else {\n            objSVG.rotate(0);\n          }\n\n          break;\n\n        case 'x':\n          var xDelta = objSVG.transform('x') - objSVG.rbox().x + svgAreaX;\n          objSVG.transform({\n            x: Number(target.value) + xDelta\n          });\n          break;\n\n        case 'y':\n          var yDelta = objSVG.transform('y') - objSVG.rbox().y + svgAreaY;\n          objSVG.transform({\n            y: Number(target.value) + yDelta\n          });\n          break;\n\n        case 'cx':\n          objSVG.transform({\n            x: Number(target.value) - objSVG.cx()\n          }); // Правильно только для неповернутых фигур\n\n          break;\n\n        case 'cy':\n          objSVG.transform({\n            y: Number(target.value) - objSVG.cy()\n          }); // Правильно только для неповернутых фигур\n\n          break;\n\n        case 'x1':\n          objSVG.attr('x1', Number(target.value) - objSVG.transform('x')); // Правильно только для неповернутых фигур\n\n          break;\n\n        case 'x2':\n          objSVG.attr('x2', Number(target.value) - objSVG.transform('x')); // Правильно только для неповернутых фигур\n\n          break;\n\n        case 'y1':\n          objSVG.attr('y1', Number(target.value) - objSVG.transform('y')); // Правильно только для неповернутых фигур\n\n          break;\n\n        case 'y2':\n          objSVG.attr('y2', Number(target.value) - objSVG.transform('y')); // Правильно только для неповернутых фигур\n\n          break;\n\n        case 'size':\n          if (target.value.length !== 0) {\n            objSVG.attr('font-size', target.value);\n          } else {\n            objSVG.attr('font-size', target.getAttribute('placeholder'));\n          }\n\n          break;\n\n        case 'stroke':\n          if (target.value.length !== 0) {\n            objSVG.attr('stroke-width', target.value);\n          } else {\n            objSVG.attr('stroke', target.getAttribute('placeholder'));\n          }\n\n          break;\n\n        default:\n          if (target.value.length !== 0) {\n            objSVG.attr(\"\".concat(target.dataset[this.appView.propertiesDataAttribute]), target.value);\n          } else {\n            objSVG.attr(\"\".concat(target.dataset[this.appView.propertiesDataAttribute]), target.getAttribute('placeholder'));\n          }\n\n          break;\n      }\n\n      this.saveHistory();\n    }\n  }, {\n    key: \"changeSelectProperty\",\n    value: function changeSelectProperty(target) {\n      this.appView.deleteVisibilityContextMenu();\n      var objSVG = this.selectElements[0];\n      objSVG.attr('font-family', target.value);\n      this.saveHistory();\n    }\n  }, {\n    key: \"alignElements\",\n    value: function alignElements(dataAttribute) {\n      var _this12 = this;\n\n      this.appView.deleteVisibilityContextMenu();\n\n      switch (dataAttribute) {\n        case 'align_horizontal_left':\n          this.selectElements.forEach(function (item) {\n            var xLast = item.transform('x');\n            item.transform({\n              x: xLast - item.rbox().x + _this12.svgArea.rbox().x\n            });\n          });\n          break;\n\n        case 'align_horizontal_right':\n          this.selectElements.forEach(function (item) {\n            var xLast = item.transform('x');\n            item.transform({\n              x: xLast - item.rbox().x2 + _this12.svgArea.rbox().x2\n            });\n          });\n          break;\n\n        case 'align_vertical_top':\n          this.selectElements.forEach(function (item) {\n            var yLast = item.transform('y');\n            item.transform({\n              y: yLast - item.rbox().y + _this12.svgArea.rbox().y\n            });\n          });\n          break;\n\n        case 'align_vertical_bottom':\n          this.selectElements.forEach(function (item) {\n            var yLast = item.transform('y');\n            item.transform({\n              y: yLast - item.rbox().y2 + _this12.svgArea.rbox().y2\n            });\n          });\n          break;\n\n        case 'align_horizontal_center':\n          this.selectElements.forEach(function (item) {\n            var xLast = item.transform('x');\n            item.transform({\n              x: xLast - item.rbox().cx + _this12.svgArea.rbox().cx\n            });\n          });\n          break;\n\n        case 'align_vertical_center':\n          this.selectElements.forEach(function (item) {\n            var yLast = item.transform('y');\n            item.transform({\n              y: yLast - item.rbox().cy + _this12.svgArea.rbox().cy\n            });\n          });\n          break;\n      }\n\n      this.saveHistory();\n    }\n  }, {\n    key: \"deleteElements\",\n    value: function deleteElements() {\n      for (var i = 0; i < this.selectElements.length; i += 1) {\n        this.selectElements[i].resize('stop').selectize(false);\n        this.selectElements[i].remove();\n      }\n\n      this.setSelectElements.clear();\n      this.selectElements = [];\n      this.appView.removeVisibilityPanel(this.selectElements);\n      this.appView.deleteVisibilityContextMenu();\n      this.saveHistory();\n    }\n  }, {\n    key: \"bringToFront\",\n    value: function bringToFront() {\n      if (this.selectElements.length === 1) {\n        this.selectElements[0].front();\n      }\n\n      this.appView.deleteVisibilityContextMenu();\n      this.saveHistory();\n    }\n  }, {\n    key: \"sendToBack\",\n    value: function sendToBack() {\n      if (this.selectElements.length === 1) {\n        this.selectElements[0].back();\n      }\n\n      this.appView.deleteVisibilityContextMenu();\n      this.saveHistory();\n    }\n  }, {\n    key: \"copyElements\",\n    value: function copyElements() {\n      this.copiedElements = this.selectElements;\n      this.appView.deleteVisibilityContextMenu();\n    }\n  }, {\n    key: \"pasteElements\",\n    value: function pasteElements() {\n      var _this13 = this;\n\n      if (this.copiedElements.length > 0) {\n        this.copiedElements.forEach(function (item) {\n          var elementCopy = item.clone();\n          elementCopy.attr('x', _this13.x);\n          elementCopy.attr('y', _this13.y);\n\n          _this13.svgArea.add(elementCopy);\n        });\n      }\n\n      this.appView.deleteVisibilityContextMenu();\n      this.saveHistory();\n    }\n  }, {\n    key: \"appearContextMenu\",\n    value: function appearContextMenu(e) {\n      e.preventDefault();\n      this.appView.contextMenuWindow.classList.remove('visibility-modal');\n      this.appView.contextMenuWindow.style.left = \"\".concat(e.pageX, \"px\");\n      this.appView.contextMenuWindow.style.top = \"\".concat(e.pageY, \"px\");\n\n      if (this.selectElements.length === 0 && this.copiedElements.length > 0) {\n        // выделено, скопировали (вызывается на svgArea)\n        this.appView.contextMenuWindow.childNodes[0].disabled = true;\n        this.appView.contextMenuWindow.childNodes[1].disabled = true;\n        this.appView.contextMenuWindow.childNodes[2].disabled = false;\n        this.appView.contextMenuWindow.childNodes[3].disabled = true;\n        this.appView.contextMenuWindow.childNodes[4].disabled = true;\n      } else if (this.selectElements.length > 0 && this.copiedElements.length === 0) {\n        // выделено, и не скопировали (вызывается на Element)\n        this.appView.contextMenuWindow.childNodes[0].disabled = false;\n        this.appView.contextMenuWindow.childNodes[1].disabled = false;\n        this.appView.contextMenuWindow.childNodes[2].disabled = true;\n        this.appView.contextMenuWindow.childNodes[3].disabled = false;\n        this.appView.contextMenuWindow.childNodes[4].disabled = false;\n      } else if (this.selectElements.length === 0 && this.copiedElements.length === 0) {\n        this.appView.contextMenuWindow.childNodes[0].disabled = true;\n        this.appView.contextMenuWindow.childNodes[1].disabled = true;\n        this.appView.contextMenuWindow.childNodes[2].disabled = true;\n        this.appView.contextMenuWindow.childNodes[3].disabled = true;\n        this.appView.contextMenuWindow.childNodes[4].disabled = true;\n      } else if (this.selectElements.length > 0 && this.copiedElements.length > 0) {\n        this.appView.contextMenuWindow.childNodes[0].disabled = false;\n        this.appView.contextMenuWindow.childNodes[1].disabled = false;\n        this.appView.contextMenuWindow.childNodes[2].disabled = false;\n        this.appView.contextMenuWindow.childNodes[3].disabled = false;\n        this.appView.contextMenuWindow.childNodes[4].disabled = false;\n      }\n    }\n  }]);\n\n  return SvgAreaModel;\n}();\n\n//# sourceURL=webpack:///./js/modules/models/SvgAreaModel.js?")},"./js/modules/views/AppView.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AppView\", function() { return AppView; });\n/* harmony import */ var _utils_createELement__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/createELement */ \"./js/utils/createELement.js\");\n/* harmony import */ var _ColorPicker__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ColorPicker */ \"./js/modules/views/ColorPicker.js\");\n/* harmony import */ var _utils_btn_names__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils/btn-names */ \"./js/utils/btn-names.js\");\n/* harmony import */ var _MainMenu__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./MainMenu */ \"./js/modules/views/MainMenu.js\");\n/* harmony import */ var _NewImageModal__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./NewImageModal */ \"./js/modules/views/NewImageModal.js\");\n/* harmony import */ var _SettingsModal__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./SettingsModal */ \"./js/modules/views/SettingsModal.js\");\n/* harmony import */ var _SvgCodeModal__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./SvgCodeModal */ \"./js/modules/views/SvgCodeModal.js\");\n/* harmony import */ var _SaveModal__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./SaveModal */ \"./js/modules/views/SaveModal.js\");\n/* harmony import */ var _models_MainViewModel__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../models/MainViewModel */ \"./js/modules/models/MainViewModel.js\");\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\n\n\n\n\n\n\n // const toolsBottomBtnName = ['red', 'green', 'blue'];\n// const MENU_BUTTONS_NAMES_EN = ['New Image', 'Save SVG', 'Import SVG', 'Document Properties', 'Get SVG-code', 'Undo', 'Redo'];\n// const CONTEXTMENU_NAMES_EN = ['Delete', 'Bring to Front', 'Send to Back'];\n// const TOOLS_LEFT_NAMES_EN = ['select', 'rect', 'ellipse', 'line', 'text', 'polyline', 'path', 'color'];\n// const MENU_BUTTONS_NAMES_RUS = ['Создать', 'Сохранить', 'Импортировать', 'Свойства документа', 'Получить код', 'Назад', 'Вперед'];\n// const CONTEXTMENU_NAMES_RUS = ['Удалить', 'На передний план', 'На задний план'];\n// const TOOLS_LEFT_NAMES_RUS = ['Выбрать элемент', 'Прямоугольник', 'Эллипс', 'Линия', 'Текст', 'Ломаная линия', 'Путь', 'Цвет'];\n\nvar AppView = /*#__PURE__*/function () {\n  function AppView(rootElement) {\n    _classCallCheck(this, AppView);\n\n    this.rootElement = rootElement;\n    this.headerElement = null;\n    this.footerElement = null;\n    this.footerContainer = null;\n    this.contentElement = null;\n    this.contentContainer = null;\n    this.toolsTopContainer = null;\n    this.toolsBottomContainer = null;\n    this.toolsLeftContainer = null;\n    this.workAreaContainer = null;\n    this.functionalAreaContainer = null;\n    this.switcherContainer = null;\n    this.contextMenuWindow = null;\n    this.menuButtonsDataAttribute = 'menu';\n    this.saveElementsDataAttribute = 'modalSave';\n    this.settingsElementsDataAttribute = 'modalSettings';\n    this.propertiesDataAttribute = 'property';\n    this.alignPanelDataAttribute = 'align';\n    this.newImageDataAttribute = 'newImage';\n    this.tabsDataAttribute = 'tab';\n    this.svgCodeDataAttribute = 'svgCode';\n    this.signInButtonsDataAttribute = 'register';\n    this.menuContainer = null;\n    this.newImageModal = null;\n    this.settingsModal = null;\n    this.svgCodeModal = null;\n    this.saveModalInstance = null;\n    this.saveModal = null;\n    this.inputFileName = null;\n    this.errorMessage = null;\n    this.tabs = []; //массив вкладок\n\n    this.tabControls = [];\n    this.countFamily = 5; // this.countAnchor = 3;\n\n    this.colorPicker = null;\n    this.rectContainerPanel = null;\n    this.lineContainerPanel = null;\n    this.ellipseContainerPanel = null;\n    this.textContainerPanel = null;\n    this.pencilContainerPanel = null;\n    this.alignContainerPanel = null;\n    this.selectProperty = null;\n    this.signInModal = null;\n  }\n\n  _createClass(AppView, [{\n    key: \"init\",\n    value: function init() {\n      this.menuContainer = new _MainMenu__WEBPACK_IMPORTED_MODULE_3__[\"MainMenu\"](this.menuButtonsDataAttribute).createMenuContainer();\n      this.newImageModal = new _NewImageModal__WEBPACK_IMPORTED_MODULE_4__[\"NewImageModal\"](this.newImageDataAttribute).createNewImageModal();\n      this.settingsModal = new _SettingsModal__WEBPACK_IMPORTED_MODULE_5__[\"SettingsModal\"](this.settingsElementsDataAttribute).createSettingsModal();\n      this.svgCodeModal = new _SvgCodeModal__WEBPACK_IMPORTED_MODULE_6__[\"SvgCodeModal\"](this.svgCodeDataAttribute).createSvgCodeModal();\n      this.saveModalInstance = new _SaveModal__WEBPACK_IMPORTED_MODULE_7__[\"SaveModal\"](this.saveElementsDataAttribute);\n      this.saveModal = this.saveModalInstance.createSaveModal();\n      this.inputFileName = this.saveModalInstance.createInputFileName();\n      this.errorMessage = this.saveModalInstance.createErrorMessage();\n      var wrapper = this.createWrapper();\n      this.headerElement = this.createHeader();\n      this.renderContent();\n      this.renderFooter();\n      this.rootElement.appendChild(wrapper);\n      wrapper.append(this.headerElement, this.contentElement, this.footerElement);\n      this.colorPicker = new _ColorPicker__WEBPACK_IMPORTED_MODULE_1__[\"ColorPicker\"](this.workAreaContainer);\n      this.colorPicker.init();\n      new _models_MainViewModel__WEBPACK_IMPORTED_MODULE_8__[\"MainViewModel\"](this).init(this.tabs.length - 1);\n    }\n  }, {\n    key: \"getCurrentRotation\",\n    value: function getCurrentRotation(item) {\n      var transform = item.attr().transform;\n\n      if (typeof transform !== 'undefined') {\n        var values = transform.split('(')[1].split(')')[0].split(',');\n        var angle = Math.round(Math.atan2(values[1], values[0]) * (180 / Math.PI));\n        return angle < 0 ? angle + 360 : angle;\n      }\n\n      return 0;\n    }\n  }, {\n    key: \"createContextMenuModal\",\n    value: function createContextMenuModal() {\n      var _this = this;\n\n      var contextMenuModal = document.createElement('div');\n      contextMenuModal.classList.add('modal-contextmenu', 'visibility-modal');\n      _utils_btn_names__WEBPACK_IMPORTED_MODULE_2__[\"CONTEXTMENU_NAMES_EN\"].forEach(function (item) {\n        var button = document.createElement('button');\n        button.setAttribute('type', 'button');\n        button.dataset[_this.propertiesDataAttribute] = item;\n        button.classList.add(\"modal-contextmenu__btn-\".concat(item.toLowerCase().split(' ').join('-')));\n        button.textContent = item;\n        contextMenuModal.append(button);\n      });\n      return contextMenuModal;\n    }\n  }, {\n    key: \"deleteVisibilityContextMenu\",\n    value: function deleteVisibilityContextMenu() {\n      this.contextMenuWindow.classList.add('visibility-modal');\n    }\n  }, {\n    key: \"removeVisibilityPanel\",\n    value: function removeVisibilityPanel(selectElements) {\n      if (selectElements.length === 0) {\n        _toConsumableArray(this.functionalAreaContainer.childNodes).forEach(function (item) {\n          return item.classList.add('visibility');\n        });\n      } else if (selectElements.length === 1) {\n        _toConsumableArray(this.functionalAreaContainer.childNodes).forEach(function (item) {\n          return item.classList.add('visibility');\n        });\n\n        switch (selectElements[0].type) {\n          case 'rect':\n            this.rectContainerPanel.classList.remove('visibility');\n            break;\n\n          case 'line':\n            this.lineContainerPanel.classList.remove('visibility');\n            break;\n\n          case 'text':\n            this.textContainerPanel.classList.remove('visibility');\n            break;\n\n          case 'ellipse':\n            this.ellipseContainerPanel.classList.remove('visibility');\n            break;\n\n          case 'path':\n            this.pencilContainerPanel.classList.remove('visibility');\n            break;\n        }\n      } else {\n        _toConsumableArray(this.functionalAreaContainer.childNodes).forEach(function (item) {\n          return item.classList.add('visibility');\n        });\n\n        this.alignContainerPanel.classList.remove('visibility');\n      }\n    }\n  }, {\n    key: \"updateFunctionalArea\",\n    value: function updateFunctionalArea(attribute) {\n      console.log(attribute);\n\n      switch (attribute.type) {\n        case 'rect':\n          var arrayLabelRect = _toConsumableArray(this.rectContainerPanel.childNodes).filter(function (item) {\n            return typeof item.childNodes[1] !== 'undefined';\n          });\n\n          arrayLabelRect[0].childNodes[1].value = attribute.id;\n          arrayLabelRect[2].childNodes[1].value = attribute.angle;\n          arrayLabelRect[3].childNodes[1].value = attribute.stroke;\n          arrayLabelRect[4].childNodes[1].value = attribute.x;\n          arrayLabelRect[5].childNodes[1].value = attribute.y;\n          arrayLabelRect[6].childNodes[1].value = attribute.width;\n          arrayLabelRect[7].childNodes[1].value = attribute.height;\n          break;\n\n        case 'line':\n          var arrayLabelLine = _toConsumableArray(this.lineContainerPanel.childNodes).filter(function (item) {\n            return typeof item.childNodes[1] !== 'undefined';\n          });\n\n          arrayLabelLine[0].childNodes[1].value = attribute.id;\n          arrayLabelLine[2].childNodes[1].value = attribute.angle;\n          arrayLabelLine[3].childNodes[1].value = attribute.stroke;\n          arrayLabelLine[4].childNodes[1].value = attribute.x1;\n          arrayLabelLine[5].childNodes[1].value = attribute.y1;\n          arrayLabelLine[6].childNodes[1].value = attribute.x2;\n          arrayLabelLine[7].childNodes[1].value = attribute.y2;\n          break;\n\n        case 'text':\n          var arrayLabelText = _toConsumableArray(this.textContainerPanel.childNodes).filter(function (item) {\n            return typeof item.childNodes[1] !== 'undefined';\n          });\n\n          arrayLabelText[0].childNodes[1].value = attribute.id;\n          arrayLabelText[2].childNodes[1].value = attribute.angle;\n          arrayLabelText[3].childNodes[1].value = attribute.stroke;\n          arrayLabelText[4].childNodes[1].value = attribute.x;\n          arrayLabelText[5].childNodes[1].value = attribute.y;\n          arrayLabelText[6].childNodes[1].value = attribute.size; // здесь долджно быть начертание\n\n          break;\n\n        case 'ellipse':\n          var arrayLabelEllipse = _toConsumableArray(this.ellipseContainerPanel.childNodes).filter(function (item) {\n            return typeof item.childNodes[1] !== 'undefined';\n          });\n\n          arrayLabelEllipse[0].childNodes[1].value = attribute.id;\n          arrayLabelEllipse[2].childNodes[1].value = attribute.angle;\n          arrayLabelEllipse[3].childNodes[1].value = attribute.stroke;\n          arrayLabelEllipse[4].childNodes[1].value = attribute.cx;\n          arrayLabelEllipse[5].childNodes[1].value = attribute.cy;\n          arrayLabelEllipse[6].childNodes[1].value = attribute.rx;\n          arrayLabelEllipse[7].childNodes[1].value = attribute.ry;\n          break;\n\n        case 'path':\n          var arrayLabelPencil = _toConsumableArray(this.pencilContainerPanel.childNodes).filter(function (item) {\n            return typeof item.childNodes[1] !== 'undefined';\n          });\n\n          arrayLabelPencil[0].childNodes[1].value = attribute.id; // id\n\n          arrayLabelPencil[2].childNodes[1].value = attribute.angle;\n          arrayLabelPencil[3].childNodes[1].value = attribute.stroke;\n          arrayLabelPencil[4].childNodes[1].value = attribute.x;\n          arrayLabelPencil[5].childNodes[1].value = attribute.y;\n          arrayLabelPencil[6].childNodes[1].value = attribute.width;\n          arrayLabelPencil[7].childNodes[1].value = attribute.height;\n          break;\n      }\n    }\n  }, {\n    key: \"createArrayNameBtn\",\n    value: function createArrayNameBtn(type) {\n      if (type === 'rect') {\n        return ['delete', 'id', 'class', 'angle', 'stroke-width', 'x', 'y', 'width', 'height'];\n      } else if (type === 'line') {\n        return ['delete', 'id', 'class', 'angle', 'stroke-width', 'x1', 'y1', 'x2', 'y2'];\n      } else if (type === 'text') {\n        return ['delete', 'id', 'class', 'angle', 'stroke-width', 'x', 'y', 'size', 'family', 'mark'];\n      } else if (type === 'ellipse') {\n        return ['delete', 'id', 'class', 'angle', 'stroke-width', 'cx', 'cy', 'rx', 'ry'];\n      } else if (type === 'path') {\n        return ['delete', 'id', 'class', 'angle', 'stroke-width', 'x', 'y', 'width', 'height'];\n      }\n\n      return ['delete', 'left', 'right', 'top', 'bottom', 'center', 'middle'];\n    }\n  }, {\n    key: \"createSelectElement\",\n    value: function createSelectElement(typeElement) {\n      this.selectProperty = document.createElement('select');\n      this.selectProperty.classList.add(\"tools-top__functional-area__container--\".concat(typeElement));\n\n      if (typeElement === 'family') {\n        var familyClasses = ['serif', 'sans-serif', 'cursive', 'fantasy', 'monospace'];\n\n        for (var i = 0; i < this.countFamily; i += 1) {\n          var option = document.createElement('option');\n          option.textContent = familyClasses[i];\n          this.selectProperty.append(option);\n        }\n      }\n\n      return this.selectProperty;\n    }\n  }, {\n    key: \"createFunctionalAreaAlignmentElements\",\n    value: function createFunctionalAreaAlignmentElements(containerPanel) {\n      var _this2 = this;\n\n      _utils_btn_names__WEBPACK_IMPORTED_MODULE_2__[\"ALIGNMENT_ICONS\"].forEach(function (item) {\n        var btn = document.createElement('button');\n        btn.setAttribute('type', 'button');\n        btn.dataset[_this2.alignPanelDataAttribute] = item;\n        btn.classList.add('tools-top__functional-area__container__btn--click');\n        btn.innerHTML = \"<i class=\\\"material-icons\\\">\".concat(item, \"</i>\");\n        containerPanel.append(btn);\n      });\n    }\n  }, {\n    key: \"createFunctionalAreaElements\",\n    value: function createFunctionalAreaElements(containerPanel, arrayBtn) {\n      var j = 0;\n\n      for (var i = 0; i < arrayBtn.length; i += 1) {\n        var containerButton = document.createElement('div');\n        containerButton.classList.add('tools-top__functional-area__container');\n\n        if (arrayBtn[i] === 'delete' || arrayBtn[i] === 'convert') {\n          var button = document.createElement('button');\n          button.dataset[this.propertiesDataAttribute] = arrayBtn[i];\n          button.classList.add('tools-top__functional-area__container__btn--click');\n\n          if (arrayBtn[i] === 'delete') {\n            button.innerHTML = '<i class=\"material-icons\">disabled_by_default</i>';\n          } else {\n            button.innerHTML = '<i class=\"material-icons\">timeline</i>';\n          }\n\n          containerButton.append(button);\n          containerPanel.append(containerButton);\n        } else if (arrayBtn[i] === 'stroke-width' || arrayBtn[i] === 'angle' || arrayBtn[i] === 'width' || arrayBtn[i] === 'height') {\n          var icon = document.createElement('img');\n          icon.setAttribute('src', \"../../img/content/\".concat(_utils_btn_names__WEBPACK_IMPORTED_MODULE_2__[\"FUNCTIONAL_AREA_ICONS\"][j]));\n          icon.setAttribute('alt', arrayBtn[i]);\n\n          var _button = document.createElement('input');\n\n          _button.setAttribute('input', 'text');\n\n          _button.dataset[this.propertiesDataAttribute] = arrayBtn[i];\n\n          _button.classList.add('tools-top__functional-area__container__btn--keyup');\n\n          containerButton.append(icon, _button);\n          containerPanel.append(containerButton);\n          j += 1;\n        } else if (arrayBtn[i] === 'family') {\n          containerButton.append(this.createSelectElement(arrayBtn[i]));\n          containerPanel.append(containerButton);\n        } else {\n          var span = document.createElement('span');\n          span.textContent = arrayBtn[i];\n\n          var _button2 = document.createElement('input');\n\n          _button2.setAttribute('input', 'text');\n\n          _button2.dataset[this.propertiesDataAttribute] = arrayBtn[i];\n\n          _button2.classList.add('tools-top__functional-area__container__btn--keyup');\n\n          containerButton.append(span, _button2);\n          containerPanel.append(containerButton);\n        }\n      }\n    }\n  }, {\n    key: \"createFunctionalAreaPanels\",\n    value: function createFunctionalAreaPanels(functionalArea) {\n      this.rectContainerPanel = document.createElement('div');\n      this.rectContainerPanel.classList.add('tools-top__functional-area__rect', 'visibility');\n      var arrayRectBtn = this.createArrayNameBtn('rect');\n      this.createFunctionalAreaElements(this.rectContainerPanel, arrayRectBtn);\n      this.lineContainerPanel = document.createElement('div');\n      this.lineContainerPanel.classList.add('tools-top__functional-area__line', 'visibility');\n      var arrayLineBtn = this.createArrayNameBtn('line');\n      this.createFunctionalAreaElements(this.lineContainerPanel, arrayLineBtn);\n      this.textContainerPanel = document.createElement('div');\n      this.textContainerPanel.classList.add('tools-top__functional-area__text', 'visibility');\n      var arrayTextBtn = this.createArrayNameBtn('text');\n      this.createFunctionalAreaElements(this.textContainerPanel, arrayTextBtn);\n      this.ellipseContainerPanel = document.createElement('div');\n      this.ellipseContainerPanel.classList.add('tools-top__functional-area__ellipse', 'visibility');\n      var arrayEllipseBtn = this.createArrayNameBtn('ellipse');\n      this.createFunctionalAreaElements(this.ellipseContainerPanel, arrayEllipseBtn);\n      this.pencilContainerPanel = document.createElement('div');\n      this.pencilContainerPanel.classList.add('tools-top__functional-area__pencil', 'visibility');\n      var arrayPencilBtn = this.createArrayNameBtn('path');\n      this.createFunctionalAreaElements(this.pencilContainerPanel, arrayPencilBtn);\n      this.alignContainerPanel = document.createElement('div');\n      this.alignContainerPanel.classList.add('tools-top__functional-area__align', 'visibility');\n      this.createFunctionalAreaAlignmentElements(this.alignContainerPanel);\n      functionalArea.append(this.rectContainerPanel, this.lineContainerPanel, this.textContainerPanel, this.ellipseContainerPanel, this.pencilContainerPanel, this.alignContainerPanel);\n    }\n  }, {\n    key: \"createFunctionalArea\",\n    value: function createFunctionalArea() {\n      var functionalArea = Object(_utils_createELement__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])('div', ['tools-top__functional-area']);\n      this.createFunctionalAreaPanels(functionalArea);\n      return functionalArea;\n    }\n  }, {\n    key: \"createSwitcherContainer\",\n    value: function createSwitcherContainer() {\n      var switcherContainer = document.createElement('div');\n      switcherContainer.classList.add('tools-top__switcher-area');\n      this.checkSwitcher = document.createElement('input');\n      var labelForSwitcher = document.createElement('label');\n      this.checkSwitcher.classList.add('tools-top__switcher-area__switcher-lang');\n      this.checkSwitcher.setAttribute('type', 'checkbox');\n      this.checkSwitcher.setAttribute('id', 'switcher-lang');\n      labelForSwitcher.setAttribute('for', 'switcher-lang');\n      labelForSwitcher.textContent = 'RU';\n      switcherContainer.append(this.checkSwitcher, labelForSwitcher);\n      return switcherContainer;\n    }\n  }, {\n    key: \"createToolsTop\",\n    value: function createToolsTop() {\n      var toolsTop = Object(_utils_createELement__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])('div', ['tools-top']);\n      this.functionalAreaContainer = this.createFunctionalArea();\n      this.switcherContainer = this.createSwitcherContainer();\n      toolsTop.append(this.menuContainer, this.functionalAreaContainer, this.switcherContainer);\n      return toolsTop;\n    }\n  }, {\n    key: \"createWorkArea\",\n    value: function createWorkArea() {\n      var workAreaContainer = Object(_utils_createELement__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])('div', ['work-area']);\n      return workAreaContainer;\n    }\n  }, {\n    key: \"renderTab\",\n    value: function renderTab() {\n      var tabsCount = this.tabs.length;\n      var tab = Object(_utils_createELement__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])('div', ['tab', 'tab--active'], {\n        id: \"tab\".concat(tabsCount)\n      });\n      this.tabs = [].concat(_toConsumableArray(this.tabs), [tab]);\n      this.workAreaContainer.append(tab);\n    }\n  }, {\n    key: \"createToolsBottom\",\n    value: function createToolsBottom() {\n      var toolsBottomContainer = Object(_utils_createELement__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])('div', ['tools-bottom']);\n      var buttonNewTab = Object(_utils_createELement__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])('button', ['tools-bottom__new-tab-button'], {\n        type: 'button'\n      });\n      buttonNewTab.dataset[\"\".concat(this.tabsDataAttribute)] = 'new';\n      buttonNewTab.innerHTML = \"<svg width=\\\"20\\\" height=\\\"20\\\"><use xlink:href=\\\"#icon-new\\\"></use></svg>\";\n      toolsBottomContainer.append(buttonNewTab);\n      return toolsBottomContainer;\n    }\n  }, {\n    key: \"renderTabControl\",\n    value: function renderTabControl() {\n      var tabControlsCount = this.tabControls.length;\n      var tabControlWrapper = Object(_utils_createELement__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])('div', ['tools-bottom__control-wrap']);\n      var tabControl = Object(_utils_createELement__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])('div', ['tools-bottom__tab-control', 'tools-bottom__tab-control--active'], false, \"SVG \".concat(tabControlsCount));\n      var closeButton = Object(_utils_createELement__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])('button', ['tools-bottom__tab-close'], {\n        type: 'button'\n      });\n      closeButton.innerHTML = \"<svg width=\\\"30\\\" height=\\\"30\\\"><use xlink:href=\\\"#icon-close\\\"></use></svg>\";\n      tabControl.dataset[\"\".concat(this.tabsDataAttribute)] = tabControlsCount;\n      closeButton.dataset[\"\".concat(this.tabsDataAttribute)] = 'close';\n      tabControlWrapper.append(tabControl, closeButton);\n      this.tabControls = [].concat(_toConsumableArray(this.tabControls), [tabControl]);\n      this.toolsBottomContainer.append(tabControlWrapper);\n    }\n  }, {\n    key: \"createToolsLeft\",\n    value: function createToolsLeft() {\n      var toolsLeftContainer = Object(_utils_createELement__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])('div', ['tools-left']);\n      _utils_btn_names__WEBPACK_IMPORTED_MODULE_2__[\"TOOLS_LEFT_NAMES_EN\"].forEach(function (item) {\n        var tooltip = Object(_utils_createELement__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])('span', ['tooltip', 'tooltip-right'], false, \"\".concat(item));\n        toolsLeftContainer.append(tooltip);\n        var btn = Object(_utils_createELement__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])('button', false, {\n          id: \"\".concat(item)\n        });\n        if (item === 'select') btn.classList.add('active');\n        btn.append(tooltip);\n        toolsLeftContainer.append(btn);\n\n        if (item === 'fill' || item === 'stroke') {\n          btn.innerHTML = \"<svg width=\\\"30\\\" height=\\\"30\\\"><use xlink:href=\\\"#icon-color\\\"></use></svg>\";\n          return;\n        }\n\n        btn.innerHTML = \"<svg width=\\\"30\\\" height=\\\"30\\\"><use xlink:href=\\\"#icon-\".concat(item, \"\\\"></use></svg>\");\n      });\n      return toolsLeftContainer;\n    }\n  }, {\n    key: \"createWrapper\",\n    value: function createWrapper() {\n      var wrapper = Object(_utils_createELement__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])('div', ['wrapper']);\n      return wrapper;\n    }\n  }, {\n    key: \"createHeader\",\n    value: function createHeader() {\n      var header = Object(_utils_createELement__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])('header', ['header']);\n      var title = Object(_utils_createELement__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])('h1', ['header__title'], false, 'SVG EDITOR');\n      header.append(title);\n      return header;\n    }\n  }, {\n    key: \"renderContent\",\n    value: function renderContent() {\n      this.contextMenuWindow = this.createContextMenuModal();\n      this.toolsTopContainer = this.createToolsTop();\n      this.toolsLeftContainer = this.createToolsLeft();\n      this.workAreaContainer = this.createWorkArea();\n      this.renderTab();\n      this.toolsBottomContainer = this.createToolsBottom();\n      this.renderTabControl();\n      this.contentElement = Object(_utils_createELement__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])('main', ['main']);\n      this.contentContainer = Object(_utils_createELement__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])('div', ['container']);\n      this.contentElement.appendChild(this.contentContainer);\n      this.toolsRightContainer = Object(_utils_createELement__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])('div', ['tools-right']);\n      var button = Object(_utils_createELement__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])('button', ['tools-right__sign-in'], {\n        'type': 'button'\n      }, 'Sign In');\n      button.dataset[this.signInButtonsDataAttribute] = 'Sign In';\n      this.toolsRightContainer.append(button);\n      this.contentContainer.append(this.toolsTopContainer, this.toolsLeftContainer, this.toolsRightContainer, this.toolsBottomContainer, this.workAreaContainer, this.saveModal, this.settingsModal, this.svgCodeModal, this.contextMenuWindow, this.newImageModal);\n    }\n  }, {\n    key: \"renderFooter\",\n    value: function renderFooter() {\n      // const yearSpan = createElement('span', ['copyright__year'], false, '2020 ©');\n      // const by = createElement('span', false, false, 'by');\n      // const student1Link = createElement('a', ['copyright__student-link'], {href: 'https://github.com/alexk08', target: '__blank'}, 'Aleksandr Krasinikov');\n      // const student2Link = createElement('a', ['copyright__student-link'], {href: 'https://github.com/11alexey11', target: '__blank'}, 'Alexey Yanvarev');\n      // const student3Link = createElement('a', ['copyright__student-link'], {href: 'https://github.com/gtm003', target: '__blank'}, 'Tatyana Grigorovich');\n      // const logo = createElement('img', ['copyright__logo-rs'], {\n      //   src: 'img/svg/rs_school_js.svg',\n      //   alt: 'Logo RS School',\n      //   width: '100px'\n      // });\n      // const courseLink = createElement('a', ['copyright__course-link'], {href: 'https://rs.school/js/', target: '__blank'});\n      // courseLink.appendChild(logo);\n      // const copyrightElement = createElement('div', ['copyright']);\n      // copyrightElement.append(yearSpan, by, student1Link, student2Link, student3Link, courseLink);\n      this.footerElement = Object(_utils_createELement__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])('footer', ['footer']); // this.footerContainer = createElement('div', ['container']);\n      // this.footerContainer.append(copyrightElement);\n      // this.footerElement.appendChild(this.footerContainer);\n    }\n  }]);\n\n  return AppView;\n}();\n\n//# sourceURL=webpack:///./js/modules/views/AppView.js?")},"./js/modules/views/ColorPicker.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ColorPicker\", function() { return ColorPicker; });\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar RGBA = ['R', 'G', 'B', 'A'];\nvar USER_ANSWER = ['OK', 'CANSEL'];\nvar ColorPicker = /*#__PURE__*/function () {\n  function ColorPicker(rootElement) {\n    _classCallCheck(this, ColorPicker);\n\n    this.rootElement = rootElement;\n    this.selectColorContainer = null;\n    this.pallete = null;\n    this.ctxPallete = null;\n    this.transparency = null;\n    this.ctxTransparency = null;\n    this.ctxNewColor = null;\n    this.selectRGBA = null;\n    this.currenColorContainer = null;\n    this.rgba = [0, 0, 0, 1];\n    this.color = 'rgba(0, 0, 0, 1)';\n    this.onPalleteClick = this.onPalleteClick.bind(this);\n    this.onTransparencyClick = this.onTransparencyClick.bind(this);\n    this.onSelectRGBAChange = this.onSelectRGBAChange.bind(this);\n  }\n\n  _createClass(ColorPicker, [{\n    key: \"init\",\n    value: function init() {\n      this.selectColorContainer = document.createElement('div');\n      this.selectColorContainer.classList.add('color-picker');\n      this.rootElement.append(this.selectColorContainer);\n      this.renderPallete(this.selectColorContainer);\n      this.renderTransparency(this.selectColorContainer);\n      this.renderNewColor(this.selectColorContainer);\n      this.renderSelectRGBA(this.selectColorContainer, RGBA);\n      this.renderBtnUserAnswerContainer(this.selectColorContainer, USER_ANSWER);\n      this.pallete.addEventListener('click', this.onPalleteClick);\n      this.transparency.addEventListener('click', this.onTransparencyClick);\n      this.selectRGBA.addEventListener('change', this.onSelectRGBAChange);\n    }\n  }, {\n    key: \"onPalleteClick\",\n    value: function onPalleteClick(e) {\n      this.pickColor(e);\n      this.updateTransparency();\n      this.updateSelectRGBA();\n      this.updateNewColor();\n    }\n  }, {\n    key: \"onTransparencyClick\",\n    value: function onTransparencyClick(e) {\n      this.pickTransparency(e);\n      this.updateSelectRGBA();\n      this.updateNewColor();\n    }\n  }, {\n    key: \"onSelectRGBAChange\",\n    value: function onSelectRGBAChange() {\n      this.changeSelectRGBA();\n      this.updateTransparency();\n      this.updateNewColor();\n    }\n  }, {\n    key: \"renderPallete\",\n    value: function renderPallete(rootElement) {\n      this.pallete = document.createElement('canvas');\n      this.pallete.classList.add('pallete');\n      rootElement.append(this.pallete);\n      this.ctxPallete = this.pallete.getContext('2d');\n      var gradient = this.pallete.getContext('2d').createLinearGradient(0, 0, this.pallete.width, 0);\n      gradient.addColorStop(0, '#ff0000');\n      gradient.addColorStop(1 / 6, '#ffff00');\n      gradient.addColorStop(1 / 6 * 2, '#00ff00');\n      gradient.addColorStop(1 / 6 * 3, '#00ffff');\n      gradient.addColorStop(1 / 6 * 4, '#0000ff');\n      gradient.addColorStop(1 / 6 * 5, '#ff00ff');\n      gradient.addColorStop(1, '#ff0000');\n      this.pallete.getContext('2d').fillStyle = gradient;\n      this.pallete.getContext('2d').fillRect(0, 0, this.pallete.width, this.pallete.height);\n      gradient = this.pallete.getContext('2d').createLinearGradient(0, 0, 0, this.pallete.height);\n      gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');\n      gradient.addColorStop(0.5, 'rgba(255, 255, 255, 0)');\n      gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');\n      this.pallete.getContext('2d').fillStyle = gradient;\n      this.pallete.getContext('2d').fillRect(0, 0, this.pallete.width, this.pallete.height);\n      gradient = this.pallete.getContext('2d').createLinearGradient(0, 0, 0, this.pallete.height);\n      gradient.addColorStop(0, 'rgba(0, 0, 0, 0)');\n      gradient.addColorStop(0.5, 'rgba(0, 0, 0, 0)');\n      gradient.addColorStop(1, 'rgba(0, 0, 0, 1)');\n      this.pallete.getContext('2d').fillStyle = gradient;\n      this.pallete.getContext('2d').fillRect(0, 0, this.pallete.width, this.pallete.height);\n    }\n  }, {\n    key: \"renderTransparency\",\n    value: function renderTransparency(rootElement) {\n      this.transparency = document.createElement('canvas');\n      this.transparency.classList.add('transparency');\n      this.transparency.width = 210;\n      this.transparency.height = 30;\n      rootElement.append(this.transparency);\n      this.ctxTransparency = this.transparency.getContext('2d');\n      this.renderUnderlayer(this.ctxTransparency, 210, 30, 5);\n      var gradient = this.ctxTransparency.createLinearGradient(0, 0, 210, 0);\n      var colorStart = \"rgba(\".concat(this.rgba[0], \", \").concat(this.rgba[1], \", \").concat(this.rgba[2], \", 1)\");\n      gradient.addColorStop(0, colorStart);\n      var colorEnd = \"rgba(\".concat(this.rgba[0], \", \").concat(this.rgba[1], \", \").concat(this.rgba[2], \", 0)\");\n      gradient.addColorStop(1, colorEnd);\n      this.ctxTransparency.fillStyle = gradient;\n      this.ctxTransparency.fillRect(0, 0, 210, 30);\n    }\n  }, {\n    key: \"renderUnderlayer\",\n    value: function renderUnderlayer(ctx, width, height, cellSize) {\n      ctx.fillStyle = '#fff';\n      ctx.fillRect(0, 0, width, height);\n      ctx.fillStyle = '#ccc';\n\n      for (var i = 0; i < width / cellSize; i += 2) {\n        for (var j = 0; j < height / cellSize; j += 2) {\n          ctx.fillRect(i * cellSize, j * cellSize, cellSize, cellSize);\n          ctx.fillRect((i + 1) * cellSize, (j + 1) * cellSize, cellSize, cellSize);\n        }\n      }\n    }\n  }, {\n    key: \"renderNewColor\",\n    value: function renderNewColor(rootElement) {\n      var newColor = document.createElement('canvas');\n      newColor.classList.add('new-color');\n      newColor.width = 60;\n      newColor.height = 30;\n      rootElement.append(newColor);\n      this.ctxNewColor = newColor.getContext('2d');\n      this.renderUnderlayer(this.ctxNewColor, 60, 30, 5);\n      this.ctxNewColor.fillStyle = this.color;\n      this.ctxNewColor.fillRect(0, 0, 60, 30);\n    }\n  }, {\n    key: \"renderSelectRGBA\",\n    value: function renderSelectRGBA(rootElement, valueNames) {\n      var _this = this;\n\n      this.selectRGBA = document.createElement('div');\n      this.selectRGBA.classList.add('btn-RGBA_container');\n      rootElement.append(this.selectRGBA);\n      valueNames.forEach(function (elem, index) {\n        var name = document.createElement('span');\n        name.innerHTML = \"\".concat(elem, \": \");\n        var btnValue = document.createElement('input');\n        btnValue.setAttribute('type', 'text');\n        btnValue.id = \"input-\".concat(elem);\n        btnValue.setAttribute('placeholder', \"\".concat(_this.rgba[index]));\n\n        _this.selectRGBA.append(name, btnValue);\n      });\n    }\n  }, {\n    key: \"renderBtnUserAnswerContainer\",\n    value: function renderBtnUserAnswerContainer(rootElement, value) {\n      var _this2 = this;\n\n      this.btnUserAnswerContainer = document.createElement('div');\n      this.btnUserAnswerContainer.classList.add('btn-user-answer_container');\n      rootElement.append(this.btnUserAnswerContainer);\n      value.forEach(function (elem) {\n        var btn = document.createElement('input');\n        btn.setAttribute('type', 'button');\n        btn.setAttribute('value', elem);\n        btn.setAttribute('id', elem);\n\n        _this2.btnUserAnswerContainer.append(btn);\n      });\n    }\n  }, {\n    key: \"pickColor\",\n    value: function pickColor(e) {\n      var x = e.layerX;\n      var y = e.layerY;\n      var pixel = this.ctxPallete.getImageData(x, y, 1, 1);\n\n      for (var i = 0; i < 3; i += 1) {\n        this.rgba[i] = pixel.data[i];\n      }\n\n      this.color = \"rgba(\".concat(this.rgba[0], \", \").concat(this.rgba[1], \", \").concat(this.rgba[2], \", \").concat(this.rgba[3], \")\");\n    }\n  }, {\n    key: \"pickTransparency\",\n    value: function pickTransparency(e) {\n      this.rgba[3] = (1 - e.layerX / 210).toFixed(2);\n      this.color = \"rgba(\".concat(this.rgba[0], \", \").concat(this.rgba[1], \", \").concat(this.rgba[2], \", \").concat(this.rgba[3], \")\");\n    }\n  }, {\n    key: \"changeSelectRGBA\",\n    value: function changeSelectRGBA() {\n      var _this3 = this;\n\n      var btnValue = _toConsumableArray(this.selectRGBA.childNodes).filter(function (node) {\n        return node.tagName === 'INPUT';\n      });\n\n      btnValue.forEach(function (btn, index) {\n        if (btn.value !== '') _this3.rgba[index] = Number(btn.value);\n        _this3.color = \"rgba(\".concat(_this3.rgba[0], \", \").concat(_this3.rgba[1], \", \").concat(_this3.rgba[2], \", \").concat(_this3.rgba[3], \")\");\n      });\n    }\n  }, {\n    key: \"updateTransparency\",\n    value: function updateTransparency() {\n      this.renderUnderlayer(this.ctxTransparency, 210, 30, 5);\n      var gradient = this.ctxTransparency.createLinearGradient(0, 0, 210, 0);\n      var colorStart = \"rgba(\".concat(this.rgba[0], \", \").concat(this.rgba[1], \", \").concat(this.rgba[2], \", 1)\");\n      gradient.addColorStop(0, colorStart);\n      var colorEnd = \"rgba(\".concat(this.rgba[0], \", \").concat(this.rgba[1], \", \").concat(this.rgba[2], \", 0)\");\n      gradient.addColorStop(1, colorEnd);\n      this.ctxTransparency.fillStyle = gradient;\n      this.ctxTransparency.fillRect(0, 0, 210, 30);\n    }\n  }, {\n    key: \"updateNewColor\",\n    value: function updateNewColor() {\n      this.renderUnderlayer(this.ctxNewColor, 60, 30, 5);\n      this.ctxNewColor.fillStyle = this.color;\n      this.ctxNewColor.fillRect(0, 0, 60, 30);\n    }\n  }, {\n    key: \"updateSelectRGBA\",\n    value: function updateSelectRGBA() {\n      var _this4 = this;\n\n      var btnValue = _toConsumableArray(this.selectRGBA.childNodes).filter(function (node) {\n        return node.tagName === 'INPUT';\n      });\n\n      btnValue.forEach(function (btn, index) {\n        return btn.value = _this4.rgba[index];\n      });\n    }\n  }, {\n    key: \"openColorPicker\",\n    value: function openColorPicker() {\n      this.selectColorContainer.classList.add('open');\n    }\n  }, {\n    key: \"closeColorPicker\",\n    value: function closeColorPicker() {\n      this.selectColorContainer.classList.remove('open');\n    }\n  }]);\n\n  return ColorPicker;\n}();\n\n//# sourceURL=webpack:///./js/modules/views/ColorPicker.js?")},"./js/modules/views/MainMenu.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MainMenu", function() { return MainMenu; });\n/* harmony import */ var _utils_btn_names__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/btn-names */ "./js/utils/btn-names.js");\n/* harmony import */ var _utils_createELement__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/createELement */ "./js/utils/createELement.js");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\nvar MainMenu = /*#__PURE__*/function () {\n  function MainMenu(menuButtonsDataAttribute) {\n    _classCallCheck(this, MainMenu);\n\n    this.menuButtonsDataAttribute = menuButtonsDataAttribute;\n  }\n\n  _createClass(MainMenu, [{\n    key: "createMenuContainer",\n    value: function createMenuContainer() {\n      var _this = this;\n\n      var menuContainer = Object(_utils_createELement__WEBPACK_IMPORTED_MODULE_1__["createElement"])(\'div\', [\'tools-top__menu-area\']);\n      menuContainer.classList.add();\n      _utils_btn_names__WEBPACK_IMPORTED_MODULE_0__["MENU_BUTTONS_NAMES_EN"].forEach(function (item) {\n        if (item === \'Undo\') {\n          var button = Object(_utils_createELement__WEBPACK_IMPORTED_MODULE_1__["createElement"])(\'button\', false, {\n            type: \'button\'\n          });\n          button.dataset["".concat(_this.menuButtonsDataAttribute)] = "".concat(item);\n          button.innerHTML = "<svg width=\\"25\\" height=\\"25\\"><use xlink:href=\\"#icon-".concat(item.toLowerCase(), "\\"></use></svg>");\n          menuContainer.appendChild(button);\n          return;\n        }\n\n        if (item === \'Redo\') {\n          var _button = Object(_utils_createELement__WEBPACK_IMPORTED_MODULE_1__["createElement"])(\'button\', false, {\n            type: \'button\'\n          });\n\n          _button.dataset["".concat(_this.menuButtonsDataAttribute)] = "".concat(item);\n          _button.innerHTML = "<svg width=\\"25\\" height=\\"25\\"><use xlink:href=\\"#icon-".concat(item.toLowerCase(), "\\"></use></svg>");\n          menuContainer.appendChild(_button);\n          return;\n        }\n\n        if (item !== \'Import\') {\n          var _button2 = Object(_utils_createELement__WEBPACK_IMPORTED_MODULE_1__["createElement"])(\'button\', false, {\n            type: \'button\'\n          }, "".concat(item));\n\n          _button2.dataset["".concat(_this.menuButtonsDataAttribute)] = "".concat(item);\n          menuContainer.appendChild(_button2);\n        } else {\n          var inputFileUpload = Object(_utils_createELement__WEBPACK_IMPORTED_MODULE_1__["createElement"])(\'input\', false, {\n            type: \'file\',\n            id: \'upload-file\'\n          });\n          inputFileUpload.dataset["".concat(_this.menuButtonsDataAttribute)] = "".concat(item);\n          inputFileUpload.style.display = \'none\';\n          var labelFileUpload = Object(_utils_createELement__WEBPACK_IMPORTED_MODULE_1__["createElement"])(\'label\', false, {\n            for: \'upload-file\'\n          }, "".concat(item));\n          menuContainer.append(labelFileUpload, inputFileUpload);\n        }\n      });\n      return menuContainer;\n    }\n  }]);\n\n  return MainMenu;\n}();\n\n//# sourceURL=webpack:///./js/modules/views/MainMenu.js?')},"./js/modules/views/NewImageModal.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NewImageModal\", function() { return NewImageModal; });\n/* harmony import */ var _utils_createELement__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/createELement */ \"./js/utils/createELement.js\");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\nvar NewImageModal = /*#__PURE__*/function () {\n  function NewImageModal(newImageDataAttribute) {\n    _classCallCheck(this, NewImageModal);\n\n    this.newImageDataAttribute = newImageDataAttribute;\n  }\n\n  _createClass(NewImageModal, [{\n    key: \"createNewImageModal\",\n    value: function createNewImageModal() {\n      var newImageModal = Object(_utils_createELement__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])('div', ['modal-new-image']);\n      var modalText = Object(_utils_createELement__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])('div', ['modal-new-image__text']);\n      var p1 = Object(_utils_createELement__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])('div', false, false, 'Do you want to clear the drawing?');\n      var p2 = Object(_utils_createELement__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])('div', false, false, 'This will also erase your undo history!');\n      modalText.append(p1, p2);\n      var buttonsContainer = Object(_utils_createELement__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])('div', ['modal-new-image__btns']);\n      var okButton = Object(_utils_createELement__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])('button', false, {\n        type: 'button'\n      }, 'OK');\n      okButton.dataset[\"\".concat(this.newImageDataAttribute)] = 'ok';\n      var cancelButton = Object(_utils_createELement__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])('button', false, {\n        type: 'button'\n      }, 'Cancel');\n      cancelButton.dataset[\"\".concat(this.newImageDataAttribute)] = 'cancel';\n      buttonsContainer.append(okButton, cancelButton);\n      newImageModal.append(modalText, buttonsContainer);\n      return newImageModal;\n    }\n  }]);\n\n  return NewImageModal;\n}();\n\n//# sourceURL=webpack:///./js/modules/views/NewImageModal.js?")},"./js/modules/views/SaveModal.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SaveModal\", function() { return SaveModal; });\n/* harmony import */ var _utils_createELement__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/createELement */ \"./js/utils/createELement.js\");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\nvar SaveModal = /*#__PURE__*/function () {\n  function SaveModal(saveElementsDataAttribute) {\n    _classCallCheck(this, SaveModal);\n\n    this.saveElementsDataAttribute = saveElementsDataAttribute;\n    this.inputFileName = null;\n    this.errorMessage = null;\n  }\n\n  _createClass(SaveModal, [{\n    key: \"createInputFileName\",\n    value: function createInputFileName() {\n      return this.inputFileName;\n    }\n  }, {\n    key: \"createErrorMessage\",\n    value: function createErrorMessage() {\n      return this.errorMessage;\n    }\n  }, {\n    key: \"createSaveModal\",\n    value: function createSaveModal() {\n      var saveModal = Object(_utils_createELement__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])('div', ['modal-save']);\n      this.inputFileName = Object(_utils_createELement__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])('input', ['modal-save__file-name'], {\n        type: 'text'\n      });\n      this.inputFileName.dataset[\"\".concat(this.saveElementsDataAttribute)] = 'name';\n      var modalTitle = Object(_utils_createELement__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])('div', ['modal-save__title'], false, 'Safe file as:');\n      var saveButton = Object(_utils_createELement__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])('button', ['modal-save__save-btn'], {\n        type: 'button'\n      }, 'Save');\n      saveButton.dataset[\"\".concat(this.saveElementsDataAttribute)] = 'save';\n      var closeButton = Object(_utils_createELement__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])('button', ['modal-save__close-btn'], {\n        type: 'button'\n      }, 'Cancel');\n      closeButton.dataset[\"\".concat(this.saveElementsDataAttribute)] = 'cancel';\n      var btnsContainer = Object(_utils_createELement__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])('div', ['modal-save__btns']);\n      btnsContainer.append(saveButton, closeButton);\n      this.errorMessage = Object(_utils_createELement__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])('div', ['modal-save__clue'], false, 'Please enter the file name');\n      this.errorMessage.style.visibility = 'hidden';\n      saveModal.append(modalTitle, this.errorMessage, this.inputFileName, btnsContainer);\n      return saveModal;\n    }\n  }]);\n\n  return SaveModal;\n}();\n\n//# sourceURL=webpack:///./js/modules/views/SaveModal.js?")},"./js/modules/views/SettingsModal.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SettingsModal\", function() { return SettingsModal; });\n/* harmony import */ var _utils_createELement__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/createELement */ \"./js/utils/createELement.js\");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\nvar SettingsModal = /*#__PURE__*/function () {\n  function SettingsModal(settingsElementsDataAttribute) {\n    _classCallCheck(this, SettingsModal);\n\n    this.settingsElementsDataAttribute = settingsElementsDataAttribute;\n  }\n\n  _createClass(SettingsModal, [{\n    key: \"createSettingsModal\",\n    value: function createSettingsModal() {\n      var settingsModal = Object(_utils_createELement__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])('div', ['modal-settings']);\n      var modalTitle = Object(_utils_createELement__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])('div', ['modal-settings__title'], false, 'SVG-Document Settings');\n      var widthSvg = Object(_utils_createELement__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])('div', ['modal-settings__svg-width']);\n      var widthSvgInput = Object(_utils_createELement__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])('input', false, {\n        type: 'text',\n        id: 'svg-width-input'\n      });\n      widthSvgInput.dataset[\"\".concat(this.settingsElementsDataAttribute)] = 'width';\n      var widthSvgLabel = Object(_utils_createELement__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])('label', false, {\n        for: 'svg-width-input'\n      }, 'SVG-area Width');\n      widthSvg.append(widthSvgLabel, widthSvgInput);\n      var heightSvg = Object(_utils_createELement__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])('div', ['modal-settings__svg-height']);\n      var heightSvgInput = Object(_utils_createELement__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])('input', false, {\n        type: 'text',\n        id: 'svg-height-input'\n      });\n      heightSvgInput.dataset[\"\".concat(this.settingsElementsDataAttribute)] = 'height';\n      var heightSvgLabel = Object(_utils_createELement__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])('label', false, {\n        for: 'svg-height-input'\n      }, 'SVG-area Height');\n      heightSvg.append(heightSvgLabel, heightSvgInput);\n      var saveButton = Object(_utils_createELement__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])('button', ['modal-settings__save-btn'], {\n        type: 'button'\n      }, 'Save');\n      saveButton.dataset[\"\".concat(this.settingsElementsDataAttribute)] = 'save';\n      var closeButton = Object(_utils_createELement__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])('button', ['modal-settings__close-btn'], {\n        type: 'button'\n      }, 'Cancel');\n      closeButton.dataset[\"\".concat(this.settingsElementsDataAttribute)] = 'cancel';\n      var btnsContainer = Object(_utils_createELement__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])('div', ['modal-settings__btns']);\n      btnsContainer.append(saveButton, closeButton);\n      settingsModal.append(modalTitle, widthSvg, heightSvg, btnsContainer);\n      return settingsModal;\n    }\n  }]);\n\n  return SettingsModal;\n}();\n\n//# sourceURL=webpack:///./js/modules/views/SettingsModal.js?")},"./js/modules/views/SignInModal.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SignInModal\", function() { return SignInModal; });\n/* harmony import */ var _utils_createELement__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/createELement */ \"./js/utils/createELement.js\");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\nvar SignInModal = /*#__PURE__*/function () {\n  function SignInModal(appView, rootElement) {\n    _classCallCheck(this, SignInModal);\n\n    this.appView = appView;\n    this.rootElement = rootElement;\n  }\n\n  _createClass(SignInModal, [{\n    key: \"createSignInModal\",\n    value: function createSignInModal(flag) {\n      this.removeSignInModal();\n      var signInModal = Object(_utils_createELement__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])('div', ['modal-sign-in']);\n\n      if (flag) {\n        var containerField = Object(_utils_createELement__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])('div', ['modal-sign-in__field']);\n        var emailField = Object(_utils_createELement__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])('input', [], {\n          'type': 'text',\n          'placeholder': 'Email'\n        });\n        var passwordField = Object(_utils_createELement__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])('input', [], {\n          'type': 'password',\n          'placeholder': 'Password'\n        });\n        containerField.append(emailField, passwordField);\n        var containerMessage = Object(_utils_createELement__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])('div', ['modal-sign-in__message']);\n        var signUpAddInformationContainer = Object(_utils_createELement__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])('div', ['modal-sign-in__unregistered']);\n        var signUpDiv = Object(_utils_createELement__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])('div', ['modal-sign-in__inf'], {}, 'Not registered?');\n        var signUpButton = Object(_utils_createELement__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])('input', ['modal-sign-in__btn'], {\n          'type': 'button',\n          'value': 'Sign Up'\n        });\n        signUpButton.dataset[this.appView.signInButtonsDataAttribute] = 'Sign Up';\n        signUpAddInformationContainer.append(signUpDiv, signUpButton);\n        var signUpButtonsContainer = Object(_utils_createELement__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])('div', ['modal-sign-in__container-btn']);\n        var signInButton = Object(_utils_createELement__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])('input', ['modal-sign-in__container-btn__sign-in'], {\n          'type': 'submit',\n          'value': 'Sign In'\n        });\n        signInButton.dataset[this.appView.signInButtonsDataAttribute] = 'Sign In';\n        var cancelButton = Object(_utils_createELement__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])('input', ['modal-sign-in__container-btn__cancel'], {\n          'type': 'submit',\n          'value': 'Cancel'\n        });\n        cancelButton.dataset[this.appView.signInButtonsDataAttribute] = 'Cancel';\n        signUpButtonsContainer.append(signInButton, cancelButton);\n        signInModal.append(containerField, containerMessage, signUpAddInformationContainer, signUpButtonsContainer);\n      } else {\n        var _containerField = Object(_utils_createELement__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])('div', ['modal-sign-in__field']);\n\n        var usernameField = Object(_utils_createELement__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])('input', ['modal-sign-in__field'], {\n          'type': 'text',\n          'placeholder': 'Username'\n        });\n\n        var _emailField = Object(_utils_createELement__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])('input', ['modal-sign-in__field'], {\n          'type': 'text',\n          'placeholder': 'Email'\n        });\n\n        var _passwordField = Object(_utils_createELement__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])('input', ['modal-sign-in__field'], {\n          'type': 'password',\n          'placeholder': 'Password'\n        });\n\n        _containerField.append(usernameField, _emailField, _passwordField);\n\n        var _containerMessage = Object(_utils_createELement__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])('div', ['modal-sign-in__message']);\n\n        var _signUpButtonsContainer = Object(_utils_createELement__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])('div', ['modal-sign-in__container-btn']);\n\n        var _signInButton = Object(_utils_createELement__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])('input', ['modal-sign-in__container-btn__sign-in'], {\n          'type': 'submit',\n          'value': 'Sign Up'\n        });\n\n        _signInButton.dataset[this.appView.signInButtonsDataAttribute] = 'Sign Up';\n\n        var _cancelButton = Object(_utils_createELement__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])('input', ['modal-sign-in__container-btn__cancel'], {\n          'type': 'submit',\n          'value': 'Cancel'\n        });\n\n        _cancelButton.dataset[this.appView.signInButtonsDataAttribute] = 'Cancel';\n\n        _signUpButtonsContainer.append(_signInButton, _cancelButton);\n\n        signInModal.append(_containerField, _containerMessage, _signUpButtonsContainer);\n      }\n\n      this.rootElement.append(signInModal);\n      return signInModal;\n    }\n  }, {\n    key: \"removeSignInModal\",\n    value: function removeSignInModal() {\n      var container = this.appView.signInModal;\n\n      if (container !== null) {\n        container.remove();\n      }\n    }\n  }, {\n    key: \"changeButtonSign\",\n    value: function changeButtonSign(flag) {\n      if (flag) {\n        this.appView.toolsRightContainer.childNodes[0].textContent = 'Sign Out';\n        this.appView.toolsRightContainer.childNodes[0].dataset[this.appView.signInButtonsDataAttribute] = 'Sign Out';\n      } else {\n        this.appView.toolsRightContainer.childNodes[0].textContent = 'Sign In';\n        this.appView.toolsRightContainer.childNodes[0].dataset[this.appView.signInButtonsDataAttribute] = 'Sign In';\n      }\n    }\n  }, {\n    key: \"createProfile\",\n    value: function createProfile() {\n      var buttonOpen = Object(_utils_createELement__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])('button', ['tools-right__open'], {\n        'type': 'button'\n      }, 'Open Files');\n      buttonOpen.dataset[this.appView.signInButtonsDataAttribute] = 'Open';\n      var buttonSave = Object(_utils_createELement__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])('button', ['tools-right__save'], {\n        'type': 'button'\n      }, 'Save in Profile');\n      buttonSave.dataset[this.appView.signInButtonsDataAttribute] = 'Save';\n      this.appView.toolsRightContainer.append(buttonOpen, buttonSave);\n    }\n  }, {\n    key: \"createModalOpen\",\n    value: function createModalOpen(arrayFiles) {\n      this.containerModalOpenFiles = Object(_utils_createELement__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])('div', ['modal--open']);\n      var contentButtons = Object(_utils_createELement__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])('div', ['modal--open__content']);\n\n      for (var i = 0; i < arrayFiles.length; i += 1) {\n        var btn = Object(_utils_createELement__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])('input', ['modal--open__content__btn'], {\n          'type': 'button',\n          'value': \"\".concat(arrayFiles[i])\n        });\n        btn.dataset[this.appView.signInButtonsDataAttribute] = 'File';\n        contentButtons.append(btn);\n      }\n\n      var btnCancel = Object(_utils_createELement__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])('input', ['modal--open__content__cancel'], {\n        'type': 'button',\n        'value': 'Cancel'\n      });\n      btnCancel.dataset[this.appView.signInButtonsDataAttribute] = 'Cancel';\n      this.containerModalOpenFiles.append(contentButtons, btnCancel);\n      this.rootElement.append(this.containerModalOpenFiles);\n    }\n  }]);\n\n  return SignInModal;\n}();\n\n//# sourceURL=webpack:///./js/modules/views/SignInModal.js?")},"./js/modules/views/SvgCodeModal.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SvgCodeModal\", function() { return SvgCodeModal; });\n/* harmony import */ var _utils_createELement__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/createELement */ \"./js/utils/createELement.js\");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\nvar SvgCodeModal = /*#__PURE__*/function () {\n  function SvgCodeModal(dataAttribute) {\n    _classCallCheck(this, SvgCodeModal);\n\n    this.svgCodeDataAttribute = dataAttribute;\n  }\n\n  _createClass(SvgCodeModal, [{\n    key: \"createSvgCodeModal\",\n    value: function createSvgCodeModal() {\n      var svgCodeModal = Object(_utils_createELement__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])('div', ['modal-svg-code']);\n      var textArea = Object(_utils_createELement__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])('textarea', ['modal-svg-code__textarea'], {\n        readonly: 'true',\n        spellcheck: 'false'\n      });\n      var title = Object(_utils_createELement__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])('div', ['modal-svg-code__title'], false, 'SVG-code');\n      var btnsContainer = Object(_utils_createELement__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])('div', ['modal-svg-code__btns']);\n      var btnClose = Object(_utils_createELement__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])('button', ['modal-svg-code__close'], {\n        type: 'button'\n      }, 'Cancel');\n      btnClose.dataset[this.svgCodeDataAttribute] = 'cancel';\n      btnsContainer.append(btnClose);\n      svgCodeModal.append(title, textArea, btnsContainer);\n      return svgCodeModal;\n    }\n  }]);\n\n  return SvgCodeModal;\n}();\n\n//# sourceURL=webpack:///./js/modules/views/SvgCodeModal.js?")},"./js/utils/btn-names.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toolsBottomBtnName\", function() { return toolsBottomBtnName; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MENU_BUTTONS_NAMES_EN\", function() { return MENU_BUTTONS_NAMES_EN; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CONTEXTMENU_NAMES_EN\", function() { return CONTEXTMENU_NAMES_EN; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TOOLS_LEFT_NAMES_EN\", function() { return TOOLS_LEFT_NAMES_EN; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MENU_BUTTONS_NAMES_RUS\", function() { return MENU_BUTTONS_NAMES_RUS; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CONTEXTMENU_NAMES_RUS\", function() { return CONTEXTMENU_NAMES_RUS; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TOOLS_LEFT_NAMES_RUS\", function() { return TOOLS_LEFT_NAMES_RUS; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FUNCTIONAL_AREA_ICONS\", function() { return FUNCTIONAL_AREA_ICONS; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ALIGNMENT_ICONS\", function() { return ALIGNMENT_ICONS; });\nvar toolsBottomBtnName = ['red', 'green', 'blue'];\nvar MENU_BUTTONS_NAMES_EN = ['Create', 'Save', 'Import', 'Properties', 'Get the code', 'Undo', 'Redo'];\nvar CONTEXTMENU_NAMES_EN = ['Delete', 'Copy', 'Paste', 'Bring to Front', 'Send to Back'];\nvar TOOLS_LEFT_NAMES_EN = ['select', 'rect', 'ellipse', 'line', 'text', 'pencil', 'path', 'fill', 'stroke'];\nvar MENU_BUTTONS_NAMES_RUS = ['Создать', 'Сохранить', 'Импортировать', 'Свойства документа', 'Получить код', 'Назад', 'Вперед'];\nvar CONTEXTMENU_NAMES_RUS = ['Удалить', 'Копировать', 'Вставить', 'На передний план', 'На задний план'];\nvar TOOLS_LEFT_NAMES_RUS = ['Выбрать элемент', 'Прямоугольник', 'Эллипс', 'Линия', 'Текст', 'Карандаш', 'Путь', 'Цвет заливки', 'Цвет контура'];\nvar FUNCTIONAL_AREA_ICONS = ['angle.svg', 'line_weight.svg', 'width.svg', 'height.svg'];\nvar ALIGNMENT_ICONS = ['disabled_by_default', 'timeline', 'align_horizontal_left', 'align_horizontal_right', 'align_vertical_top', 'align_vertical_bottom', 'align_horizontal_center', 'align_vertical_center'];\n\n\n//# sourceURL=webpack:///./js/utils/btn-names.js?")},"./js/utils/createELement.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createElement", function() { return createElement; });\nfunction _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }\n\nvar createElement = function createElement(tagName, classList, attributes, textContent) {\n  // tagName - string\n  // classList - array of string\n  // attributes - object\n  // dataAttributes - object - пока без дата-атрибутов\n  // textContent - string\n  classList = Array.isArray(classList) ? classList : false;\n  attributes = _typeof(attributes) !== undefined ? attributes : false;\n  textContent = typeof textContent === \'string\' ? textContent : false;\n  var element = document.createElement(tagName);\n  if (classList) classList.forEach(function (item) {\n    return element.classList.add(item);\n  });\n\n  if (attributes) {\n    for (var prop in attributes) {\n      element.setAttribute(prop, attributes[prop]);\n    }\n  }\n\n  if (textContent) element.textContent = textContent;\n  return element;\n};\n\n\n\n//# sourceURL=webpack:///./js/utils/createELement.js?')},"./js/utils/ie-fix.js":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ieFix", function() { return ieFix; });\n/* eslint-disable */\nvar ieFix = function ieFix() {\n  // Polyfills\n  //---------------------------------\n  // forEach\n  if (window.NodeList && !NodeList.prototype.forEach) {\n    NodeList.prototype.forEach = function (callback, thisArg) {\n      thisArg = thisArg || window;\n\n      for (var i = 0; i < this.length; i++) {\n        callback.call(thisArg, this[i], i, this);\n      }\n    };\n  } // includes\n\n\n  if (!Array.prototype.includes) {\n    Object.defineProperty(Array.prototype, \'includes\', {\n      value: function value(searchElement, fromIndex) {\n        if (this == null) {\n          throw new TypeError(\'"this" is null or not defined\');\n        }\n\n        var o = Object(this);\n        var len = o.length >>> 0;\n\n        if (len === 0) {\n          return false;\n        }\n\n        var n = fromIndex | 0;\n        var k = Math.max(n >= 0 ? n : len - Math.abs(n), 0);\n\n        function sameValueZero(x, y) {\n          return x === y || typeof x === \'number\' && typeof y === \'number\' && isNaN(x) && isNaN(y);\n        }\n\n        while (k < len) {\n          if (sameValueZero(o[k], searchElement)) {\n            return true;\n          }\n\n          k++;\n        }\n\n        return false;\n      }\n    });\n  } // matches\n\n\n  if (!Element.prototype.matches) {\n    Element.prototype.matches = Element.prototype.matchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector || Element.prototype.oMatchesSelector || Element.prototype.webkitMatchesSelector || function (s) {\n      var matches = (this.document || this.ownerDocument).querySelectorAll(s);\n      var i = matches.length; // eslint-disable-next-line no-empty\n\n      while (--i >= 0 && matches.item(i) !== this) {}\n\n      return i > -1;\n    };\n  } // closest\n\n\n  if (!Element.prototype.matches) {\n    Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;\n  }\n\n  if (!Element.prototype.closest) {\n    Element.prototype.closest = function (s) {\n      var el = this;\n\n      do {\n        if (el.matches(s)) {\n          return el;\n        }\n\n        el = el.parentElement || el.parentNode;\n      } while (el !== null && el.nodeType === 1);\n\n      return null;\n    };\n  } // prepend\n\n\n  (function (arr) {\n    arr.forEach(function (item) {\n      if (item.hasOwnProperty("prepend")) {\n        return;\n      }\n\n      Object.defineProperty(item, "prepend", {\n        configurable: true,\n        enumerable: true,\n        writable: true,\n        value: function prepend() {\n          // eslint-disable-next-line prefer-rest-params\n          var argArr = Array.prototype.slice.call(arguments);\n          var docFrag = document.createDocumentFragment();\n          argArr.forEach(function (argItem) {\n            var isNode = argItem instanceof Node;\n            docFrag.appendChild(isNode ? argItem : document.createTextNode(String(argItem)));\n          });\n          this.insertBefore(docFrag, this.firstChild);\n        }\n      });\n    });\n  })([Element.prototype, Document.prototype, DocumentFragment.prototype]); // append\n\n\n  (function (arr) {\n    arr.forEach(function (item) {\n      if (item.hasOwnProperty("append")) {\n        return;\n      }\n\n      Object.defineProperty(item, "append", {\n        configurable: true,\n        enumerable: true,\n        writable: true,\n        value: function append() {\n          // eslint-disable-next-line prefer-rest-params\n          var argArr = Array.prototype.slice.call(arguments);\n          var docFrag = document.createDocumentFragment();\n          argArr.forEach(function (argItem) {\n            var isNode = argItem instanceof Node;\n            docFrag.appendChild(isNode ? argItem : document.createTextNode(String(argItem)));\n          });\n          this.appendChild(docFrag);\n        }\n      });\n    });\n  })([Element.prototype, Document.prototype, DocumentFragment.prototype]); // before\n\n\n  (function (arr) {\n    arr.forEach(function (item) {\n      if (item.hasOwnProperty("before")) {\n        return;\n      }\n\n      Object.defineProperty(item, "before", {\n        configurable: true,\n        enumerable: true,\n        writable: true,\n        value: function before() {\n          // eslint-disable-next-line prefer-rest-params\n          var argArr = Array.prototype.slice.call(arguments);\n          var docFrag = document.createDocumentFragment();\n          argArr.forEach(function (argItem) {\n            var isNode = argItem instanceof Node;\n            docFrag.appendChild(isNode ? argItem : document.createTextNode(String(argItem)));\n          });\n          this.parentNode.insertBefore(docFrag, this);\n        }\n      });\n    });\n  })([Element.prototype, CharacterData.prototype, DocumentType.prototype]); // remove\n\n\n  (function (arr) {\n    arr.forEach(function (item) {\n      if (item.hasOwnProperty("remove")) {\n        return;\n      }\n\n      Object.defineProperty(item, "remove", {\n        configurable: true,\n        enumerable: true,\n        writable: true,\n        value: function remove() {\n          if (this.parentNode !== null) {\n            this.parentNode.removeChild(this);\n          }\n        }\n      });\n    });\n  })([Element.prototype, CharacterData.prototype, DocumentType.prototype]); // startsWith\n\n\n  if (!String.prototype.startsWith) {\n    // eslint-disable-next-line no-extend-native\n    Object.defineProperty(String.prototype, "startsWith", {\n      value: function value(search, rawPos) {\n        var pos = rawPos > 0 ? rawPos | 0 : 0;\n        return this.substring(pos, pos + search.length) === search;\n      }\n    });\n  } // Fixes\n  //---------------------------------\n  // ie download\n\n\n  var ie11Download = function ie11Download(el) {\n    if (el.href === "") {\n      throw Error("The element has no href value.");\n    }\n\n    var filename = el.getAttribute("download");\n\n    if (filename === null || filename === "") {\n      var tmp = el.href.split("/");\n      filename = tmp[tmp.length - 1];\n    }\n\n    el.addEventListener("click", function (evt) {\n      evt.preventDefault();\n      var xhr = new XMLHttpRequest();\n\n      xhr.onloadstart = function () {\n        xhr.responseType = "blob";\n      };\n\n      xhr.onload = function () {\n        navigator.msSaveOrOpenBlob(xhr.response, filename);\n      };\n\n      xhr.open("GET", el.href, true);\n      xhr.send();\n    });\n  };\n\n  if (window.navigator.msSaveBlob) {\n    var downloadLinks = document.querySelectorAll("a[download]");\n\n    if (downloadLinks.length) {\n      downloadLinks.forEach(function (el) {\n        ie11Download(el);\n      });\n    }\n  } // ie svg focus fix\n\n\n  var unfocusableSvg = function unfocusableSvg() {\n    if (!(!!window.MSInputMethodContext && !!document.documentMode)) {\n      return;\n    }\n\n    var svg = document.querySelectorAll(\'svg\');\n    svg.forEach(function (el) {\n      el.setAttribute(\'focusable\', \'false\');\n    });\n  };\n\n  unfocusableSvg(); //ie footer nailing\n\n  var ieFooterNailing = function ieFooterNailing() {\n    var main = document.querySelector(\'main\');\n    var header = document.querySelector(\'.header\');\n    var footer = document.querySelector(\'.footer\');\n    var headerH;\n    var footerH;\n    var mainHMin;\n\n    if (!main || !(!!window.MSInputMethodContext && !!document.documentMode)) {\n      return;\n    }\n\n    var mainHeight = function mainHeight() {\n      // eslint-disable-next-line no-unused-expressions\n      header ? headerH = header.getBoundingClientRect().height : headerH = 0; // eslint-disable-next-line no-unused-expressions\n\n      footer ? footerH = footer.getBoundingClientRect().height : footerH = 0;\n      mainHMin = window.innerHeight;\n      main.style.minHeight = mainHMin - (headerH + footerH) + \'px\';\n    };\n\n    document.addEventListener(\'loadDOMContentLoaded\', mainHeight());\n    window.addEventListener(\'resize\', mainHeight);\n  };\n\n  ieFooterNailing();\n};\n\n\n\n//# sourceURL=webpack:///./js/utils/ie-fix.js?')},"./js/vendor/svg.js":function(module,exports,__webpack_require__){eval("var __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/*!\n* svg.js - A lightweight library for manipulating and animating SVG.\n* @version 2.7.1\n* https://svgdotjs.github.io/\n*\n* @copyright Wout Fierens <wout@mick-wout.com>\n* @license MIT\n*\n* BUILT: Fri Nov 30 2018 10:01:55 GMT+0100 (GMT+01:00)\n*/\n;\n\n(function (root, factory) {\n  /* istanbul ignore next */\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n      return factory(root, root.document);\n    }).call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n})(typeof window !== \"undefined\" ? window : this, function (window, document) {\n  // Find global reference - uses 'this' by default when available,\n  // falls back to 'window' otherwise (for bundlers like Webpack)\n  var globalRef = typeof this !== \"undefined\" ? this : window; // The main wrapping element\n\n  var SVG = globalRef.SVG = function (element) {\n    if (SVG.supported) {\n      element = new SVG.Doc(element);\n      if (!SVG.parser.draw) SVG.prepare();\n      return element;\n    }\n  }; // Default namespaces\n\n\n  SVG.ns = 'http://www.w3.org/2000/svg';\n  SVG.xmlns = 'http://www.w3.org/2000/xmlns/';\n  SVG.xlink = 'http://www.w3.org/1999/xlink';\n  SVG.svgjs = 'http://svgjs.com/svgjs'; // Svg support test\n\n  SVG.supported = function () {\n    return !!document.createElementNS && !!document.createElementNS(SVG.ns, 'svg').createSVGRect;\n  }(); // Don't bother to continue if SVG is not supported\n\n\n  if (!SVG.supported) return false; // Element id sequence\n\n  SVG.did = 1000; // Get next named element id\n\n  SVG.eid = function (name) {\n    return 'Svgjs' + capitalize(name) + SVG.did++;\n  }; // Method for element creation\n\n\n  SVG.create = function (name) {\n    // create element\n    var element = document.createElementNS(this.ns, name); // apply unique id\n\n    element.setAttribute('id', this.eid(name));\n    return element;\n  }; // Method for extending objects\n\n\n  SVG.extend = function () {\n    var modules, methods, key, i; // Get list of modules\n\n    modules = [].slice.call(arguments); // Get object with extensions\n\n    methods = modules.pop();\n\n    for (i = modules.length - 1; i >= 0; i--) {\n      if (modules[i]) for (key in methods) {\n        modules[i].prototype[key] = methods[key];\n      }\n    } // Make sure SVG.Set inherits any newly added methods\n\n\n    if (SVG.Set && SVG.Set.inherit) SVG.Set.inherit();\n  }; // Invent new element\n\n\n  SVG.invent = function (config) {\n    // Create element initializer\n    var initializer = typeof config.create == 'function' ? config.create : function () {\n      this.constructor.call(this, SVG.create(config.create));\n    }; // Inherit prototype\n\n    if (config.inherit) initializer.prototype = new config.inherit(); // Extend with methods\n\n    if (config.extend) SVG.extend(initializer, config.extend); // Attach construct method to parent\n\n    if (config.construct) SVG.extend(config.parent || SVG.Container, config.construct);\n    return initializer;\n  }; // Adopt existing svg elements\n\n\n  SVG.adopt = function (node) {\n    // check for presence of node\n    if (!node) return null; // make sure a node isn't already adopted\n\n    if (node.instance) return node.instance; // initialize variables\n\n    var element; // adopt with element-specific settings\n\n    if (node.nodeName == 'svg') element = node.parentNode instanceof window.SVGElement ? new SVG.Nested() : new SVG.Doc();else if (node.nodeName == 'linearGradient') element = new SVG.Gradient('linear');else if (node.nodeName == 'radialGradient') element = new SVG.Gradient('radial');else if (SVG[capitalize(node.nodeName)]) element = new SVG[capitalize(node.nodeName)]();else element = new SVG.Element(node); // ensure references\n\n    element.type = node.nodeName;\n    element.node = node;\n    node.instance = element; // SVG.Class specific preparations\n\n    if (element instanceof SVG.Doc) element.namespace().defs(); // pull svgjs data from the dom (getAttributeNS doesn't work in html5)\n\n    element.setData(JSON.parse(node.getAttribute('svgjs:data')) || {});\n    return element;\n  }; // Initialize parsing element\n\n\n  SVG.prepare = function () {\n    // Select document body and create invisible svg element\n    var body = document.getElementsByTagName('body')[0],\n        draw = (body ? new SVG.Doc(body) : SVG.adopt(document.documentElement).nested()).size(2, 0); // Create parser object\n\n    SVG.parser = {\n      body: body || document.documentElement,\n      draw: draw.style('opacity:0;position:absolute;left:-100%;top:-100%;overflow:hidden').attr('focusable', 'false').node,\n      poly: draw.polyline().node,\n      path: draw.path().node,\n      native: SVG.create('svg')\n    };\n  };\n\n  SVG.parser = {\n    native: SVG.create('svg')\n  };\n  document.addEventListener('DOMContentLoaded', function () {\n    if (!SVG.parser.draw) SVG.prepare();\n  }, false); // Storage for regular expressions\n\n  SVG.regex = {\n    // Parse unit value\n    numberAndUnit: /^([+-]?(\\d+(\\.\\d*)?|\\.\\d+)(e[+-]?\\d+)?)([a-z%]*)$/i // Parse hex value\n    ,\n    hex: /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i // Parse rgb value\n    ,\n    rgb: /rgb\\((\\d+),(\\d+),(\\d+)\\)/ // Parse reference id\n    ,\n    reference: /#([a-z0-9\\-_]+)/i // splits a transformation chain\n    ,\n    transforms: /\\)\\s*,?\\s*/ // Whitespace\n    ,\n    whitespace: /\\s/g // Test hex value\n    ,\n    isHex: /^#[a-f0-9]{3,6}$/i // Test rgb value\n    ,\n    isRgb: /^rgb\\(/ // Test css declaration\n    ,\n    isCss: /[^:]+:[^;]+;?/ // Test for blank string\n    ,\n    isBlank: /^(\\s+)?$/ // Test for numeric string\n    ,\n    isNumber: /^[+-]?(\\d+(\\.\\d*)?|\\.\\d+)(e[+-]?\\d+)?$/i // Test for percent value\n    ,\n    isPercent: /^-?[\\d\\.]+%$/ // Test for image url\n    ,\n    isImage: /\\.(jpg|jpeg|png|gif|svg)(\\?[^=]+.*)?/i // split at whitespace and comma\n    ,\n    delimiter: /[\\s,]+/ // The following regex are used to parse the d attribute of a path\n    // Matches all hyphens which are not after an exponent\n    ,\n    hyphen: /([^e])\\-/gi // Replaces and tests for all path letters\n    ,\n    pathLetters: /[MLHVCSQTAZ]/gi // yes we need this one, too\n    ,\n    isPathLetter: /[MLHVCSQTAZ]/i // matches 0.154.23.45\n    ,\n    numbersWithDots: /((\\d?\\.\\d+(?:e[+-]?\\d+)?)((?:\\.\\d+(?:e[+-]?\\d+)?)+))+/gi // matches .\n    ,\n    dots: /\\./g\n  };\n  SVG.utils = {\n    // Map function\n    map: function map(array, block) {\n      var i,\n          il = array.length,\n          result = [];\n\n      for (i = 0; i < il; i++) {\n        result.push(block(array[i]));\n      }\n\n      return result;\n    } // Filter function\n    ,\n    filter: function filter(array, block) {\n      var i,\n          il = array.length,\n          result = [];\n\n      for (i = 0; i < il; i++) {\n        if (block(array[i])) result.push(array[i]);\n      }\n\n      return result;\n    } // Degrees to radians\n    ,\n    radians: function radians(d) {\n      return d % 360 * Math.PI / 180;\n    } // Radians to degrees\n    ,\n    degrees: function degrees(r) {\n      return r * 180 / Math.PI % 360;\n    },\n    filterSVGElements: function filterSVGElements(nodes) {\n      return this.filter(nodes, function (el) {\n        return el instanceof window.SVGElement;\n      });\n    }\n  };\n  SVG.defaults = {\n    // Default attribute values\n    attrs: {\n      // fill and stroke\n      'fill-opacity': 1,\n      'stroke-opacity': 1,\n      'stroke-width': 0,\n      'stroke-linejoin': 'miter',\n      'stroke-linecap': 'butt',\n      fill: '#000000',\n      stroke: '#000000',\n      opacity: 1 // position\n      ,\n      x: 0,\n      y: 0,\n      cx: 0,\n      cy: 0 // size\n      ,\n      width: 0,\n      height: 0 // radius\n      ,\n      r: 0,\n      rx: 0,\n      ry: 0 // gradient\n      ,\n      offset: 0,\n      'stop-opacity': 1,\n      'stop-color': '#000000' // text\n      ,\n      'font-size': 16,\n      'font-family': 'Helvetica, Arial, sans-serif',\n      'text-anchor': 'start'\n    }\n  }; // Module for color convertions\n\n  SVG.Color = function (color) {\n    var match; // initialize defaults\n\n    this.r = 0;\n    this.g = 0;\n    this.b = 0;\n    if (!color) return; // parse color\n\n    if (typeof color === 'string') {\n      if (SVG.regex.isRgb.test(color)) {\n        // get rgb values\n        match = SVG.regex.rgb.exec(color.replace(SVG.regex.whitespace, '')); // parse numeric values\n\n        this.r = parseInt(match[1]);\n        this.g = parseInt(match[2]);\n        this.b = parseInt(match[3]);\n      } else if (SVG.regex.isHex.test(color)) {\n        // get hex values\n        match = SVG.regex.hex.exec(fullHex(color)); // parse numeric values\n\n        this.r = parseInt(match[1], 16);\n        this.g = parseInt(match[2], 16);\n        this.b = parseInt(match[3], 16);\n      }\n    } else if (_typeof(color) === 'object') {\n      this.r = color.r;\n      this.g = color.g;\n      this.b = color.b;\n    }\n  };\n\n  SVG.extend(SVG.Color, {\n    // Default to hex conversion\n    toString: function toString() {\n      return this.toHex();\n    } // Build hex value\n    ,\n    toHex: function toHex() {\n      return '#' + compToHex(this.r) + compToHex(this.g) + compToHex(this.b);\n    } // Build rgb value\n    ,\n    toRgb: function toRgb() {\n      return 'rgb(' + [this.r, this.g, this.b].join() + ')';\n    } // Calculate true brightness\n    ,\n    brightness: function brightness() {\n      return this.r / 255 * 0.30 + this.g / 255 * 0.59 + this.b / 255 * 0.11;\n    } // Make color morphable\n    ,\n    morph: function morph(color) {\n      this.destination = new SVG.Color(color);\n      return this;\n    } // Get morphed color at given position\n    ,\n    at: function at(pos) {\n      // make sure a destination is defined\n      if (!this.destination) return this; // normalise pos\n\n      pos = pos < 0 ? 0 : pos > 1 ? 1 : pos; // generate morphed color\n\n      return new SVG.Color({\n        r: ~~(this.r + (this.destination.r - this.r) * pos),\n        g: ~~(this.g + (this.destination.g - this.g) * pos),\n        b: ~~(this.b + (this.destination.b - this.b) * pos)\n      });\n    }\n  }); // Testers\n  // Test if given value is a color string\n\n  SVG.Color.test = function (color) {\n    color += '';\n    return SVG.regex.isHex.test(color) || SVG.regex.isRgb.test(color);\n  }; // Test if given value is a rgb object\n\n\n  SVG.Color.isRgb = function (color) {\n    return color && typeof color.r == 'number' && typeof color.g == 'number' && typeof color.b == 'number';\n  }; // Test if given value is a color\n\n\n  SVG.Color.isColor = function (color) {\n    return SVG.Color.isRgb(color) || SVG.Color.test(color);\n  }; // Module for array conversion\n\n\n  SVG.Array = function (array, fallback) {\n    array = (array || []).valueOf(); // if array is empty and fallback is provided, use fallback\n\n    if (array.length == 0 && fallback) array = fallback.valueOf(); // parse array\n\n    this.value = this.parse(array);\n  };\n\n  SVG.extend(SVG.Array, {\n    // Make array morphable\n    morph: function morph(array) {\n      this.destination = this.parse(array); // normalize length of arrays\n\n      if (this.value.length != this.destination.length) {\n        var lastValue = this.value[this.value.length - 1],\n            lastDestination = this.destination[this.destination.length - 1];\n\n        while (this.value.length > this.destination.length) {\n          this.destination.push(lastDestination);\n        }\n\n        while (this.value.length < this.destination.length) {\n          this.value.push(lastValue);\n        }\n      }\n\n      return this;\n    } // Clean up any duplicate points\n    ,\n    settle: function settle() {\n      // find all unique values\n      for (var i = 0, il = this.value.length, seen = []; i < il; i++) {\n        if (seen.indexOf(this.value[i]) == -1) seen.push(this.value[i]);\n      } // set new value\n\n\n      return this.value = seen;\n    } // Get morphed array at given position\n    ,\n    at: function at(pos) {\n      // make sure a destination is defined\n      if (!this.destination) return this; // generate morphed array\n\n      for (var i = 0, il = this.value.length, array = []; i < il; i++) {\n        array.push(this.value[i] + (this.destination[i] - this.value[i]) * pos);\n      }\n\n      return new SVG.Array(array);\n    } // Convert array to string\n    ,\n    toString: function toString() {\n      return this.value.join(' ');\n    } // Real value\n    ,\n    valueOf: function valueOf() {\n      return this.value;\n    } // Parse whitespace separated string\n    ,\n    parse: function parse(array) {\n      array = array.valueOf(); // if already is an array, no need to parse it\n\n      if (Array.isArray(array)) return array;\n      return this.split(array);\n    } // Strip unnecessary whitespace\n    ,\n    split: function split(string) {\n      return string.trim().split(SVG.regex.delimiter).map(parseFloat);\n    } // Reverse array\n    ,\n    reverse: function reverse() {\n      this.value.reverse();\n      return this;\n    },\n    clone: function clone() {\n      var clone = new this.constructor();\n      clone.value = array_clone(this.value);\n      return clone;\n    }\n  }); // Poly points array\n\n  SVG.PointArray = function (array, fallback) {\n    SVG.Array.call(this, array, fallback || [[0, 0]]);\n  }; // Inherit from SVG.Array\n\n\n  SVG.PointArray.prototype = new SVG.Array();\n  SVG.PointArray.prototype.constructor = SVG.PointArray;\n  SVG.extend(SVG.PointArray, {\n    // Convert array to string\n    toString: function toString() {\n      // convert to a poly point string\n      for (var i = 0, il = this.value.length, array = []; i < il; i++) {\n        array.push(this.value[i].join(','));\n      }\n\n      return array.join(' ');\n    } // Convert array to line object\n    ,\n    toLine: function toLine() {\n      return {\n        x1: this.value[0][0],\n        y1: this.value[0][1],\n        x2: this.value[1][0],\n        y2: this.value[1][1]\n      };\n    } // Get morphed array at given position\n    ,\n    at: function at(pos) {\n      // make sure a destination is defined\n      if (!this.destination) return this; // generate morphed point string\n\n      for (var i = 0, il = this.value.length, array = []; i < il; i++) {\n        array.push([this.value[i][0] + (this.destination[i][0] - this.value[i][0]) * pos, this.value[i][1] + (this.destination[i][1] - this.value[i][1]) * pos]);\n      }\n\n      return new SVG.PointArray(array);\n    } // Parse point string and flat array\n    ,\n    parse: function parse(array) {\n      var points = [];\n      array = array.valueOf(); // if it is an array\n\n      if (Array.isArray(array)) {\n        // and it is not flat, there is no need to parse it\n        if (Array.isArray(array[0])) {\n          // make sure to use a clone\n          return array.map(function (el) {\n            return el.slice();\n          });\n        } else if (array[0].x != null) {\n          // allow point objects to be passed\n          return array.map(function (el) {\n            return [el.x, el.y];\n          });\n        }\n      } else {\n        // Else, it is considered as a string\n        // parse points\n        array = array.trim().split(SVG.regex.delimiter).map(parseFloat);\n      } // validate points - https://svgwg.org/svg2-draft/shapes.html#DataTypePoints\n      // Odd number of coordinates is an error. In such cases, drop the last odd coordinate.\n\n\n      if (array.length % 2 !== 0) array.pop(); // wrap points in two-tuples and parse points as floats\n\n      for (var i = 0, len = array.length; i < len; i = i + 2) {\n        points.push([array[i], array[i + 1]]);\n      }\n\n      return points;\n    } // Move point string\n    ,\n    move: function move(x, y) {\n      var box = this.bbox(); // get relative offset\n\n      x -= box.x;\n      y -= box.y; // move every point\n\n      if (!isNaN(x) && !isNaN(y)) for (var i = this.value.length - 1; i >= 0; i--) {\n        this.value[i] = [this.value[i][0] + x, this.value[i][1] + y];\n      }\n      return this;\n    } // Resize poly string\n    ,\n    size: function size(width, height) {\n      var i,\n          box = this.bbox(); // recalculate position of all points according to new size\n\n      for (i = this.value.length - 1; i >= 0; i--) {\n        if (box.width) this.value[i][0] = (this.value[i][0] - box.x) * width / box.width + box.x;\n        if (box.height) this.value[i][1] = (this.value[i][1] - box.y) * height / box.height + box.y;\n      }\n\n      return this;\n    } // Get bounding box of points\n    ,\n    bbox: function bbox() {\n      SVG.parser.poly.setAttribute('points', this.toString());\n      return SVG.parser.poly.getBBox();\n    }\n  });\n  var pathHandlers = {\n    M: function M(c, p, p0) {\n      p.x = p0.x = c[0];\n      p.y = p0.y = c[1];\n      return ['M', p.x, p.y];\n    },\n    L: function L(c, p) {\n      p.x = c[0];\n      p.y = c[1];\n      return ['L', c[0], c[1]];\n    },\n    H: function H(c, p) {\n      p.x = c[0];\n      return ['H', c[0]];\n    },\n    V: function V(c, p) {\n      p.y = c[0];\n      return ['V', c[0]];\n    },\n    C: function C(c, p) {\n      p.x = c[4];\n      p.y = c[5];\n      return ['C', c[0], c[1], c[2], c[3], c[4], c[5]];\n    },\n    S: function S(c, p) {\n      p.x = c[2];\n      p.y = c[3];\n      return ['S', c[0], c[1], c[2], c[3]];\n    },\n    Q: function Q(c, p) {\n      p.x = c[2];\n      p.y = c[3];\n      return ['Q', c[0], c[1], c[2], c[3]];\n    },\n    T: function T(c, p) {\n      p.x = c[0];\n      p.y = c[1];\n      return ['T', c[0], c[1]];\n    },\n    Z: function Z(c, p, p0) {\n      p.x = p0.x;\n      p.y = p0.y;\n      return ['Z'];\n    },\n    A: function A(c, p) {\n      p.x = c[5];\n      p.y = c[6];\n      return ['A', c[0], c[1], c[2], c[3], c[4], c[5], c[6]];\n    }\n  };\n  var mlhvqtcsa = 'mlhvqtcsaz'.split('');\n\n  for (var i = 0, il = mlhvqtcsa.length; i < il; ++i) {\n    pathHandlers[mlhvqtcsa[i]] = function (i) {\n      return function (c, p, p0) {\n        if (i == 'H') c[0] = c[0] + p.x;else if (i == 'V') c[0] = c[0] + p.y;else if (i == 'A') {\n          c[5] = c[5] + p.x, c[6] = c[6] + p.y;\n        } else for (var j = 0, jl = c.length; j < jl; ++j) {\n          c[j] = c[j] + (j % 2 ? p.y : p.x);\n        }\n        return pathHandlers[i](c, p, p0);\n      };\n    }(mlhvqtcsa[i].toUpperCase());\n  } // Path points array\n\n\n  SVG.PathArray = function (array, fallback) {\n    SVG.Array.call(this, array, fallback || [['M', 0, 0]]);\n  }; // Inherit from SVG.Array\n\n\n  SVG.PathArray.prototype = new SVG.Array();\n  SVG.PathArray.prototype.constructor = SVG.PathArray;\n  SVG.extend(SVG.PathArray, {\n    // Convert array to string\n    toString: function toString() {\n      return arrayToString(this.value);\n    } // Move path string\n    ,\n    move: function move(x, y) {\n      // get bounding box of current situation\n      var box = this.bbox(); // get relative offset\n\n      x -= box.x;\n      y -= box.y;\n\n      if (!isNaN(x) && !isNaN(y)) {\n        // move every point\n        for (var l, i = this.value.length - 1; i >= 0; i--) {\n          l = this.value[i][0];\n\n          if (l == 'M' || l == 'L' || l == 'T') {\n            this.value[i][1] += x;\n            this.value[i][2] += y;\n          } else if (l == 'H') {\n            this.value[i][1] += x;\n          } else if (l == 'V') {\n            this.value[i][1] += y;\n          } else if (l == 'C' || l == 'S' || l == 'Q') {\n            this.value[i][1] += x;\n            this.value[i][2] += y;\n            this.value[i][3] += x;\n            this.value[i][4] += y;\n\n            if (l == 'C') {\n              this.value[i][5] += x;\n              this.value[i][6] += y;\n            }\n          } else if (l == 'A') {\n            this.value[i][6] += x;\n            this.value[i][7] += y;\n          }\n        }\n      }\n\n      return this;\n    } // Resize path string\n    ,\n    size: function size(width, height) {\n      // get bounding box of current situation\n      var i,\n          l,\n          box = this.bbox(); // recalculate position of all points according to new size\n\n      for (i = this.value.length - 1; i >= 0; i--) {\n        l = this.value[i][0];\n\n        if (l == 'M' || l == 'L' || l == 'T') {\n          this.value[i][1] = (this.value[i][1] - box.x) * width / box.width + box.x;\n          this.value[i][2] = (this.value[i][2] - box.y) * height / box.height + box.y;\n        } else if (l == 'H') {\n          this.value[i][1] = (this.value[i][1] - box.x) * width / box.width + box.x;\n        } else if (l == 'V') {\n          this.value[i][1] = (this.value[i][1] - box.y) * height / box.height + box.y;\n        } else if (l == 'C' || l == 'S' || l == 'Q') {\n          this.value[i][1] = (this.value[i][1] - box.x) * width / box.width + box.x;\n          this.value[i][2] = (this.value[i][2] - box.y) * height / box.height + box.y;\n          this.value[i][3] = (this.value[i][3] - box.x) * width / box.width + box.x;\n          this.value[i][4] = (this.value[i][4] - box.y) * height / box.height + box.y;\n\n          if (l == 'C') {\n            this.value[i][5] = (this.value[i][5] - box.x) * width / box.width + box.x;\n            this.value[i][6] = (this.value[i][6] - box.y) * height / box.height + box.y;\n          }\n        } else if (l == 'A') {\n          // resize radii\n          this.value[i][1] = this.value[i][1] * width / box.width;\n          this.value[i][2] = this.value[i][2] * height / box.height; // move position values\n\n          this.value[i][6] = (this.value[i][6] - box.x) * width / box.width + box.x;\n          this.value[i][7] = (this.value[i][7] - box.y) * height / box.height + box.y;\n        }\n      }\n\n      return this;\n    } // Test if the passed path array use the same path data commands as this path array\n    ,\n    equalCommands: function equalCommands(pathArray) {\n      var i, il, equalCommands;\n      pathArray = new SVG.PathArray(pathArray);\n      equalCommands = this.value.length === pathArray.value.length;\n\n      for (i = 0, il = this.value.length; equalCommands && i < il; i++) {\n        equalCommands = this.value[i][0] === pathArray.value[i][0];\n      }\n\n      return equalCommands;\n    } // Make path array morphable\n    ,\n    morph: function morph(pathArray) {\n      pathArray = new SVG.PathArray(pathArray);\n\n      if (this.equalCommands(pathArray)) {\n        this.destination = pathArray;\n      } else {\n        this.destination = null;\n      }\n\n      return this;\n    } // Get morphed path array at given position\n    ,\n    at: function at(pos) {\n      // make sure a destination is defined\n      if (!this.destination) return this;\n      var sourceArray = this.value,\n          destinationArray = this.destination.value,\n          array = [],\n          pathArray = new SVG.PathArray(),\n          i,\n          il,\n          j,\n          jl; // Animate has specified in the SVG spec\n      // See: https://www.w3.org/TR/SVG11/paths.html#PathElement\n\n      for (i = 0, il = sourceArray.length; i < il; i++) {\n        array[i] = [sourceArray[i][0]];\n\n        for (j = 1, jl = sourceArray[i].length; j < jl; j++) {\n          array[i][j] = sourceArray[i][j] + (destinationArray[i][j] - sourceArray[i][j]) * pos;\n        } // For the two flags of the elliptical arc command, the SVG spec say:\n        // Flags and booleans are interpolated as fractions between zero and one, with any non-zero value considered to be a value of one/true\n        // Elliptical arc command as an array followed by corresponding indexes:\n        // ['A', rx, ry, x-axis-rotation, large-arc-flag, sweep-flag, x, y]\n        //   0    1   2        3                 4             5      6  7\n\n\n        if (array[i][0] === 'A') {\n          array[i][4] = +(array[i][4] != 0);\n          array[i][5] = +(array[i][5] != 0);\n        }\n      } // Directly modify the value of a path array, this is done this way for performance\n\n\n      pathArray.value = array;\n      return pathArray;\n    } // Absolutize and parse path to array\n    ,\n    parse: function parse(array) {\n      // if it's already a patharray, no need to parse it\n      if (array instanceof SVG.PathArray) return array.valueOf(); // prepare for parsing\n\n      var i,\n          x0,\n          y0,\n          s,\n          seg,\n          arr,\n          x = 0,\n          y = 0,\n          paramCnt = {\n        'M': 2,\n        'L': 2,\n        'H': 1,\n        'V': 1,\n        'C': 6,\n        'S': 4,\n        'Q': 4,\n        'T': 2,\n        'A': 7,\n        'Z': 0\n      };\n\n      if (typeof array == 'string') {\n        array = array.replace(SVG.regex.numbersWithDots, pathRegReplace) // convert 45.123.123 to 45.123 .123\n        .replace(SVG.regex.pathLetters, ' $& ') // put some room between letters and numbers\n        .replace(SVG.regex.hyphen, '$1 -') // add space before hyphen\n        .trim() // trim\n        .split(SVG.regex.delimiter); // split into array\n      } else {\n        array = array.reduce(function (prev, curr) {\n          return [].concat.call(prev, curr);\n        }, []);\n      } // array now is an array containing all parts of a path e.g. ['M', '0', '0', 'L', '30', '30' ...]\n\n\n      var arr = [],\n          p = new SVG.Point(),\n          p0 = new SVG.Point(),\n          index = 0,\n          len = array.length;\n\n      do {\n        // Test if we have a path letter\n        if (SVG.regex.isPathLetter.test(array[index])) {\n          s = array[index];\n          ++index; // If last letter was a move command and we got no new, it defaults to [L]ine\n        } else if (s == 'M') {\n          s = 'L';\n        } else if (s == 'm') {\n          s = 'l';\n        }\n\n        arr.push(pathHandlers[s].call(null, array.slice(index, index = index + paramCnt[s.toUpperCase()]).map(parseFloat), p, p0));\n      } while (len > index);\n\n      return arr;\n    } // Get bounding box of path\n    ,\n    bbox: function bbox() {\n      SVG.parser.path.setAttribute('d', this.toString());\n      return SVG.parser.path.getBBox();\n    }\n  }); // Module for unit convertions\n\n  SVG.Number = SVG.invent({\n    // Initialize\n    create: function create(value, unit) {\n      // initialize defaults\n      this.value = 0;\n      this.unit = unit || ''; // parse value\n\n      if (typeof value === 'number') {\n        // ensure a valid numeric value\n        this.value = isNaN(value) ? 0 : !isFinite(value) ? value < 0 ? -3.4e+38 : +3.4e+38 : value;\n      } else if (typeof value === 'string') {\n        unit = value.match(SVG.regex.numberAndUnit);\n\n        if (unit) {\n          // make value numeric\n          this.value = parseFloat(unit[1]); // normalize\n\n          if (unit[5] == '%') this.value /= 100;else if (unit[5] == 's') this.value *= 1000; // store unit\n\n          this.unit = unit[5];\n        }\n      } else {\n        if (value instanceof SVG.Number) {\n          this.value = value.valueOf();\n          this.unit = value.unit;\n        }\n      }\n    } // Add methods\n    ,\n    extend: {\n      // Stringalize\n      toString: function toString() {\n        return (this.unit == '%' ? ~~(this.value * 1e8) / 1e6 : this.unit == 's' ? this.value / 1e3 : this.value) + this.unit;\n      },\n      toJSON: function toJSON() {\n        return this.toString();\n      },\n      // Convert to primitive\n      valueOf: function valueOf() {\n        return this.value;\n      } // Add number\n      ,\n      plus: function plus(number) {\n        number = new SVG.Number(number);\n        return new SVG.Number(this + number, this.unit || number.unit);\n      } // Subtract number\n      ,\n      minus: function minus(number) {\n        number = new SVG.Number(number);\n        return new SVG.Number(this - number, this.unit || number.unit);\n      } // Multiply number\n      ,\n      times: function times(number) {\n        number = new SVG.Number(number);\n        return new SVG.Number(this * number, this.unit || number.unit);\n      } // Divide number\n      ,\n      divide: function divide(number) {\n        number = new SVG.Number(number);\n        return new SVG.Number(this / number, this.unit || number.unit);\n      } // Convert to different unit\n      ,\n      to: function to(unit) {\n        var number = new SVG.Number(this);\n        if (typeof unit === 'string') number.unit = unit;\n        return number;\n      } // Make number morphable\n      ,\n      morph: function morph(number) {\n        this.destination = new SVG.Number(number);\n\n        if (number.relative) {\n          this.destination.value += this.value;\n        }\n\n        return this;\n      } // Get morphed number at given position\n      ,\n      at: function at(pos) {\n        // Make sure a destination is defined\n        if (!this.destination) return this; // Generate new morphed number\n\n        return new SVG.Number(this.destination).minus(this).times(pos).plus(this);\n      }\n    }\n  });\n  SVG.Element = SVG.invent({\n    // Initialize node\n    create: function create(node) {\n      // make stroke value accessible dynamically\n      this._stroke = SVG.defaults.attrs.stroke;\n      this._event = null;\n      this._events = {}; // initialize data object\n\n      this.dom = {}; // create circular reference\n\n      if (this.node = node) {\n        this.type = node.nodeName;\n        this.node.instance = this;\n        this._events = node._events || {}; // store current attribute value\n\n        this._stroke = node.getAttribute('stroke') || this._stroke;\n      }\n    } // Add class methods\n    ,\n    extend: {\n      // Move over x-axis\n      x: function x(_x) {\n        return this.attr('x', _x);\n      } // Move over y-axis\n      ,\n      y: function y(_y) {\n        return this.attr('y', _y);\n      } // Move by center over x-axis\n      ,\n      cx: function cx(x) {\n        return x == null ? this.x() + this.width() / 2 : this.x(x - this.width() / 2);\n      } // Move by center over y-axis\n      ,\n      cy: function cy(y) {\n        return y == null ? this.y() + this.height() / 2 : this.y(y - this.height() / 2);\n      } // Move element to given x and y values\n      ,\n      move: function move(x, y) {\n        return this.x(x).y(y);\n      } // Move element by its center\n      ,\n      center: function center(x, y) {\n        return this.cx(x).cy(y);\n      } // Set width of element\n      ,\n      width: function width(_width) {\n        return this.attr('width', _width);\n      } // Set height of element\n      ,\n      height: function height(_height) {\n        return this.attr('height', _height);\n      } // Set element size to given width and height\n      ,\n      size: function size(width, height) {\n        var p = proportionalSize(this, width, height);\n        return this.width(new SVG.Number(p.width)).height(new SVG.Number(p.height));\n      } // Clone element\n      ,\n      clone: function clone(parent) {\n        // write dom data to the dom so the clone can pickup the data\n        this.writeDataToDom(); // clone element and assign new id\n\n        var clone = assignNewId(this.node.cloneNode(true)); // insert the clone in the given parent or after myself\n\n        if (parent) parent.add(clone);else this.after(clone);\n        return clone;\n      } // Remove element\n      ,\n      remove: function remove() {\n        if (this.parent()) this.parent().removeElement(this);\n        return this;\n      } // Replace element\n      ,\n      replace: function replace(element) {\n        this.after(element).remove();\n        return element;\n      } // Add element to given container and return self\n      ,\n      addTo: function addTo(parent) {\n        return parent.put(this);\n      } // Add element to given container and return container\n      ,\n      putIn: function putIn(parent) {\n        return parent.add(this);\n      } // Get / set id\n      ,\n      id: function id(_id) {\n        return this.attr('id', _id);\n      } // Checks whether the given point inside the bounding box of the element\n      ,\n      inside: function inside(x, y) {\n        var box = this.bbox();\n        return x > box.x && y > box.y && x < box.x + box.width && y < box.y + box.height;\n      } // Show element\n      ,\n      show: function show() {\n        return this.style('display', '');\n      } // Hide element\n      ,\n      hide: function hide() {\n        return this.style('display', 'none');\n      } // Is element visible?\n      ,\n      visible: function visible() {\n        return this.style('display') != 'none';\n      } // Return id on string conversion\n      ,\n      toString: function toString() {\n        return this.attr('id');\n      } // Return array of classes on the node\n      ,\n      classes: function classes() {\n        var attr = this.attr('class');\n        return attr == null ? [] : attr.trim().split(SVG.regex.delimiter);\n      } // Return true if class exists on the node, false otherwise\n      ,\n      hasClass: function hasClass(name) {\n        return this.classes().indexOf(name) != -1;\n      } // Add class to the node\n      ,\n      addClass: function addClass(name) {\n        if (!this.hasClass(name)) {\n          var array = this.classes();\n          array.push(name);\n          this.attr('class', array.join(' '));\n        }\n\n        return this;\n      } // Remove class from the node\n      ,\n      removeClass: function removeClass(name) {\n        if (this.hasClass(name)) {\n          this.attr('class', this.classes().filter(function (c) {\n            return c != name;\n          }).join(' '));\n        }\n\n        return this;\n      } // Toggle the presence of a class on the node\n      ,\n      toggleClass: function toggleClass(name) {\n        return this.hasClass(name) ? this.removeClass(name) : this.addClass(name);\n      } // Get referenced element form attribute value\n      ,\n      reference: function reference(attr) {\n        return SVG.get(this.attr(attr));\n      } // Returns the parent element instance\n      ,\n      parent: function parent(type) {\n        var parent = this; // check for parent\n\n        if (!parent.node.parentNode) return null; // get parent element\n\n        parent = SVG.adopt(parent.node.parentNode);\n        if (!type) return parent; // loop trough ancestors if type is given\n\n        while (parent && parent.node instanceof window.SVGElement) {\n          if (typeof type === 'string' ? parent.matches(type) : parent instanceof type) return parent;\n          if (!parent.node.parentNode || parent.node.parentNode.nodeName == '#document' || parent.node.parentNode.nodeName == '#document-fragment') return null; // #759, #720\n\n          parent = SVG.adopt(parent.node.parentNode);\n        }\n      } // Get parent document\n      ,\n      doc: function doc() {\n        return this instanceof SVG.Doc ? this : this.parent(SVG.Doc);\n      } // return array of all ancestors of given type up to the root svg\n      ,\n      parents: function parents(type) {\n        var parents = [],\n            parent = this;\n\n        do {\n          parent = parent.parent(type);\n          if (!parent || !parent.node) break;\n          parents.push(parent);\n        } while (parent.parent);\n\n        return parents;\n      } // matches the element vs a css selector\n      ,\n      matches: function matches(selector) {\n        return _matches(this.node, selector);\n      } // Returns the svg node to call native svg methods on it\n      ,\n      native: function native() {\n        return this.node;\n      } // Import raw svg\n      ,\n      svg: function svg(_svg) {\n        // create temporary holder\n        var well = document.createElement('svg'); // act as a setter if svg is given\n\n        if (_svg && this instanceof SVG.Parent) {\n          // dump raw svg\n          well.innerHTML = '<svg>' + _svg.replace(/\\n/, '').replace(/<([\\w:-]+)([^<]+?)\\/>/g, '<$1$2></$1>') + '</svg>'; // transplant nodes\n\n          for (var i = 0, il = well.firstChild.childNodes.length; i < il; i++) {\n            this.node.appendChild(well.firstChild.firstChild);\n          } // otherwise act as a getter\n\n        } else {\n          // create a wrapping svg element in case of partial content\n          well.appendChild(_svg = document.createElement('svg')); // write svgjs data to the dom\n\n          this.writeDataToDom(); // insert a copy of this node\n\n          _svg.appendChild(this.node.cloneNode(true)); // return target element\n\n\n          return well.innerHTML.replace(/^<svg>/, '').replace(/<\\/svg>$/, '');\n        }\n\n        return this;\n      } // write svgjs data to the dom\n      ,\n      writeDataToDom: function writeDataToDom() {\n        // dump variables recursively\n        if (this.each || this.lines) {\n          var fn = this.each ? this : this.lines();\n          fn.each(function () {\n            this.writeDataToDom();\n          });\n        } // remove previously set data\n\n\n        this.node.removeAttribute('svgjs:data');\n        if (Object.keys(this.dom).length) this.node.setAttribute('svgjs:data', JSON.stringify(this.dom)); // see #428\n\n        return this;\n      } // set given data to the elements data property\n      ,\n      setData: function setData(o) {\n        this.dom = o;\n        return this;\n      },\n      is: function is(obj) {\n        return _is(this, obj);\n      }\n    }\n  });\n  SVG.easing = {\n    '-': function _(pos) {\n      return pos;\n    },\n    '<>': function _(pos) {\n      return -Math.cos(pos * Math.PI) / 2 + 0.5;\n    },\n    '>': function _(pos) {\n      return Math.sin(pos * Math.PI / 2);\n    },\n    '<': function _(pos) {\n      return -Math.cos(pos * Math.PI / 2) + 1;\n    }\n  };\n\n  SVG.morph = function (pos) {\n    return function (from, to) {\n      return new SVG.MorphObj(from, to).at(pos);\n    };\n  };\n\n  SVG.Situation = SVG.invent({\n    create: function create(o) {\n      this.init = false;\n      this.reversed = false;\n      this.reversing = false;\n      this.duration = new SVG.Number(o.duration).valueOf();\n      this.delay = new SVG.Number(o.delay).valueOf();\n      this.start = +new Date() + this.delay;\n      this.finish = this.start + this.duration;\n      this.ease = o.ease; // this.loop is incremented from 0 to this.loops\n      // it is also incremented when in an infinite loop (when this.loops is true)\n\n      this.loop = 0;\n      this.loops = false;\n      this.animations = {// functionToCall: [list of morphable objects]\n        // e.g. move: [SVG.Number, SVG.Number]\n      };\n      this.attrs = {// holds all attributes which are not represented from a function svg.js provides\n        // e.g. someAttr: SVG.Number\n      };\n      this.styles = {// holds all styles which should be animated\n        // e.g. fill-color: SVG.Color\n      };\n      this.transforms = [// holds all transformations as transformation objects\n        // e.g. [SVG.Rotate, SVG.Translate, SVG.Matrix]\n      ];\n      this.once = {// functions to fire at a specific position\n        // e.g. \"0.5\": function foo(){}\n      };\n    }\n  });\n  SVG.FX = SVG.invent({\n    create: function create(element) {\n      this._target = element;\n      this.situations = [];\n      this.active = false;\n      this.situation = null;\n      this.paused = false;\n      this.lastPos = 0;\n      this.pos = 0; // The absolute position of an animation is its position in the context of its complete duration (including delay and loops)\n      // When performing a delay, absPos is below 0 and when performing a loop, its value is above 1\n\n      this.absPos = 0;\n      this._speed = 1;\n    },\n    extend: {\n      /**\n       * sets or returns the target of this animation\n       * @param o object || number In case of Object it holds all parameters. In case of number its the duration of the animation\n       * @param ease function || string Function which should be used for easing or easing keyword\n       * @param delay Number indicating the delay before the animation starts\n       * @return target || this\n       */\n      animate: function animate(o, ease, delay) {\n        if (_typeof(o) == 'object') {\n          ease = o.ease;\n          delay = o.delay;\n          o = o.duration;\n        }\n\n        var situation = new SVG.Situation({\n          duration: o || 1000,\n          delay: delay || 0,\n          ease: SVG.easing[ease || '-'] || ease\n        });\n        this.queue(situation);\n        return this;\n      }\n      /**\n       * sets a delay before the next element of the queue is called\n       * @param delay Duration of delay in milliseconds\n       * @return this.target()\n       */\n      ,\n      delay: function delay(_delay) {\n        // The delay is performed by an empty situation with its duration\n        // attribute set to the duration of the delay\n        var situation = new SVG.Situation({\n          duration: _delay,\n          delay: 0,\n          ease: SVG.easing['-']\n        });\n        return this.queue(situation);\n      }\n      /**\n       * sets or returns the target of this animation\n       * @param null || target SVG.Element which should be set as new target\n       * @return target || this\n       */\n      ,\n      target: function target(_target) {\n        if (_target && _target instanceof SVG.Element) {\n          this._target = _target;\n          return this;\n        }\n\n        return this._target;\n      } // returns the absolute position at a given time\n      ,\n      timeToAbsPos: function timeToAbsPos(timestamp) {\n        return (timestamp - this.situation.start) / (this.situation.duration / this._speed);\n      } // returns the timestamp from a given absolute positon\n      ,\n      absPosToTime: function absPosToTime(absPos) {\n        return this.situation.duration / this._speed * absPos + this.situation.start;\n      } // starts the animationloop\n      ,\n      startAnimFrame: function startAnimFrame() {\n        this.stopAnimFrame();\n        this.animationFrame = window.requestAnimationFrame(function () {\n          this.step();\n        }.bind(this));\n      } // cancels the animationframe\n      ,\n      stopAnimFrame: function stopAnimFrame() {\n        window.cancelAnimationFrame(this.animationFrame);\n      } // kicks off the animation - only does something when the queue is currently not active and at least one situation is set\n      ,\n      start: function start() {\n        // dont start if already started\n        if (!this.active && this.situation) {\n          this.active = true;\n          this.startCurrent();\n        }\n\n        return this;\n      } // start the current situation\n      ,\n      startCurrent: function startCurrent() {\n        this.situation.start = +new Date() + this.situation.delay / this._speed;\n        this.situation.finish = this.situation.start + this.situation.duration / this._speed;\n        return this.initAnimations().step();\n      }\n      /**\n       * adds a function / Situation to the animation queue\n       * @param fn function / situation to add\n       * @return this\n       */\n      ,\n      queue: function queue(fn) {\n        if (typeof fn == 'function' || fn instanceof SVG.Situation) this.situations.push(fn);\n        if (!this.situation) this.situation = this.situations.shift();\n        return this;\n      }\n      /**\n       * pulls next element from the queue and execute it\n       * @return this\n       */\n      ,\n      dequeue: function dequeue() {\n        // stop current animation\n        this.stop(); // get next animation from queue\n\n        this.situation = this.situations.shift();\n\n        if (this.situation) {\n          if (this.situation instanceof SVG.Situation) {\n            this.start();\n          } else {\n            // If it is not a SVG.Situation, then it is a function, we execute it\n            this.situation.call(this);\n          }\n        }\n\n        return this;\n      } // updates all animations to the current state of the element\n      // this is important when one property could be changed from another property\n      ,\n      initAnimations: function initAnimations() {\n        var i, j, source;\n        var s = this.situation;\n        if (s.init) return this;\n\n        for (i in s.animations) {\n          source = this.target()[i]();\n\n          if (!Array.isArray(source)) {\n            source = [source];\n          }\n\n          if (!Array.isArray(s.animations[i])) {\n            s.animations[i] = [s.animations[i]];\n          } //if(s.animations[i].length > source.length) {\n          //  source.concat = source.concat(s.animations[i].slice(source.length, s.animations[i].length))\n          //}\n\n\n          for (j = source.length; j--;) {\n            // The condition is because some methods return a normal number instead\n            // of a SVG.Number\n            if (s.animations[i][j] instanceof SVG.Number) source[j] = new SVG.Number(source[j]);\n            s.animations[i][j] = source[j].morph(s.animations[i][j]);\n          }\n        }\n\n        for (i in s.attrs) {\n          s.attrs[i] = new SVG.MorphObj(this.target().attr(i), s.attrs[i]);\n        }\n\n        for (i in s.styles) {\n          s.styles[i] = new SVG.MorphObj(this.target().style(i), s.styles[i]);\n        }\n\n        s.initialTransformation = this.target().matrixify();\n        s.init = true;\n        return this;\n      },\n      clearQueue: function clearQueue() {\n        this.situations = [];\n        return this;\n      },\n      clearCurrent: function clearCurrent() {\n        this.situation = null;\n        return this;\n      }\n      /** stops the animation immediately\n       * @param jumpToEnd A Boolean indicating whether to complete the current animation immediately.\n       * @param clearQueue A Boolean indicating whether to remove queued animation as well.\n       * @return this\n       */\n      ,\n      stop: function stop(jumpToEnd, clearQueue) {\n        var active = this.active;\n        this.active = false;\n\n        if (clearQueue) {\n          this.clearQueue();\n        }\n\n        if (jumpToEnd && this.situation) {\n          // initialize the situation if it was not\n          !active && this.startCurrent();\n          this.atEnd();\n        }\n\n        this.stopAnimFrame();\n        return this.clearCurrent();\n      }\n      /** resets the element to the state where the current element has started\n       * @return this\n       */\n      ,\n      reset: function reset() {\n        if (this.situation) {\n          var temp = this.situation;\n          this.stop();\n          this.situation = temp;\n          this.atStart();\n        }\n\n        return this;\n      } // Stop the currently-running animation, remove all queued animations, and complete all animations for the element.\n      ,\n      finish: function finish() {\n        this.stop(true, false);\n\n        while (this.dequeue().situation && this.stop(true, false)) {\n          ;\n        }\n\n        this.clearQueue().clearCurrent();\n        return this;\n      } // set the internal animation pointer at the start position, before any loops, and updates the visualisation\n      ,\n      atStart: function atStart() {\n        return this.at(0, true);\n      } // set the internal animation pointer at the end position, after all the loops, and updates the visualisation\n      ,\n      atEnd: function atEnd() {\n        if (this.situation.loops === true) {\n          // If in a infinite loop, we end the current iteration\n          this.situation.loops = this.situation.loop + 1;\n        }\n\n        if (typeof this.situation.loops == 'number') {\n          // If performing a finite number of loops, we go after all the loops\n          return this.at(this.situation.loops, true);\n        } else {\n          // If no loops, we just go at the end\n          return this.at(1, true);\n        }\n      } // set the internal animation pointer to the specified position and updates the visualisation\n      // if isAbsPos is true, pos is treated as an absolute position\n      ,\n      at: function at(pos, isAbsPos) {\n        var durDivSpd = this.situation.duration / this._speed;\n        this.absPos = pos; // If pos is not an absolute position, we convert it into one\n\n        if (!isAbsPos) {\n          if (this.situation.reversed) this.absPos = 1 - this.absPos;\n          this.absPos += this.situation.loop;\n        }\n\n        this.situation.start = +new Date() - this.absPos * durDivSpd;\n        this.situation.finish = this.situation.start + durDivSpd;\n        return this.step(true);\n      }\n      /**\n       * sets or returns the speed of the animations\n       * @param speed null || Number The new speed of the animations\n       * @return Number || this\n       */\n      ,\n      speed: function speed(_speed) {\n        if (_speed === 0) return this.pause();\n\n        if (_speed) {\n          this._speed = _speed; // We use an absolute position here so that speed can affect the delay before the animation\n\n          return this.at(this.absPos, true);\n        } else return this._speed;\n      } // Make loopable\n      ,\n      loop: function loop(times, reverse) {\n        var c = this.last(); // store total loops\n\n        c.loops = times != null ? times : true;\n        c.loop = 0;\n        if (reverse) c.reversing = true;\n        return this;\n      } // pauses the animation\n      ,\n      pause: function pause() {\n        this.paused = true;\n        this.stopAnimFrame();\n        return this;\n      } // unpause the animation\n      ,\n      play: function play() {\n        if (!this.paused) return this;\n        this.paused = false; // We use an absolute position here so that the delay before the animation can be paused\n\n        return this.at(this.absPos, true);\n      }\n      /**\n       * toggle or set the direction of the animation\n       * true sets direction to backwards while false sets it to forwards\n       * @param reversed Boolean indicating whether to reverse the animation or not (default: toggle the reverse status)\n       * @return this\n       */\n      ,\n      reverse: function reverse(reversed) {\n        var c = this.last();\n        if (typeof reversed == 'undefined') c.reversed = !c.reversed;else c.reversed = reversed;\n        return this;\n      }\n      /**\n       * returns a float from 0-1 indicating the progress of the current animation\n       * @param eased Boolean indicating whether the returned position should be eased or not\n       * @return number\n       */\n      ,\n      progress: function progress(easeIt) {\n        return easeIt ? this.situation.ease(this.pos) : this.pos;\n      }\n      /**\n       * adds a callback function which is called when the current animation is finished\n       * @param fn Function which should be executed as callback\n       * @return number\n       */\n      ,\n      after: function after(fn) {\n        var c = this.last(),\n            wrapper = function wrapper(e) {\n          if (e.detail.situation == c) {\n            fn.call(this, c);\n            this.off('finished.fx', wrapper); // prevent memory leak\n          }\n        };\n\n        this.target().on('finished.fx', wrapper);\n        return this._callStart();\n      } // adds a callback which is called whenever one animation step is performed\n      ,\n      during: function during(fn) {\n        var c = this.last(),\n            wrapper = function wrapper(e) {\n          if (e.detail.situation == c) {\n            fn.call(this, e.detail.pos, SVG.morph(e.detail.pos), e.detail.eased, c);\n          }\n        }; // see above\n\n\n        this.target().off('during.fx', wrapper).on('during.fx', wrapper);\n        this.after(function () {\n          this.off('during.fx', wrapper);\n        });\n        return this._callStart();\n      } // calls after ALL animations in the queue are finished\n      ,\n      afterAll: function afterAll(fn) {\n        var wrapper = function wrapper(e) {\n          fn.call(this);\n          this.off('allfinished.fx', wrapper);\n        }; // see above\n\n\n        this.target().off('allfinished.fx', wrapper).on('allfinished.fx', wrapper);\n        return this._callStart();\n      } // calls on every animation step for all animations\n      ,\n      duringAll: function duringAll(fn) {\n        var wrapper = function wrapper(e) {\n          fn.call(this, e.detail.pos, SVG.morph(e.detail.pos), e.detail.eased, e.detail.situation);\n        };\n\n        this.target().off('during.fx', wrapper).on('during.fx', wrapper);\n        this.afterAll(function () {\n          this.off('during.fx', wrapper);\n        });\n        return this._callStart();\n      },\n      last: function last() {\n        return this.situations.length ? this.situations[this.situations.length - 1] : this.situation;\n      } // adds one property to the animations\n      ,\n      add: function add(method, args, type) {\n        this.last()[type || 'animations'][method] = args;\n        return this._callStart();\n      }\n      /** perform one step of the animation\n       *  @param ignoreTime Boolean indicating whether to ignore time and use position directly or recalculate position based on time\n       *  @return this\n       */\n      ,\n      step: function step(ignoreTime) {\n        // convert current time to an absolute position\n        if (!ignoreTime) this.absPos = this.timeToAbsPos(+new Date()); // This part convert an absolute position to a position\n\n        if (this.situation.loops !== false) {\n          var absPos, absPosInt, lastLoop; // If the absolute position is below 0, we just treat it as if it was 0\n\n          absPos = Math.max(this.absPos, 0);\n          absPosInt = Math.floor(absPos);\n\n          if (this.situation.loops === true || absPosInt < this.situation.loops) {\n            this.pos = absPos - absPosInt;\n            lastLoop = this.situation.loop;\n            this.situation.loop = absPosInt;\n          } else {\n            this.absPos = this.situation.loops;\n            this.pos = 1; // The -1 here is because we don't want to toggle reversed when all the loops have been completed\n\n            lastLoop = this.situation.loop - 1;\n            this.situation.loop = this.situation.loops;\n          }\n\n          if (this.situation.reversing) {\n            // Toggle reversed if an odd number of loops as occured since the last call of step\n            this.situation.reversed = this.situation.reversed != Boolean((this.situation.loop - lastLoop) % 2);\n          }\n        } else {\n          // If there are no loop, the absolute position must not be above 1\n          this.absPos = Math.min(this.absPos, 1);\n          this.pos = this.absPos;\n        } // while the absolute position can be below 0, the position must not be below 0\n\n\n        if (this.pos < 0) this.pos = 0;\n        if (this.situation.reversed) this.pos = 1 - this.pos; // apply easing\n\n        var eased = this.situation.ease(this.pos); // call once-callbacks\n\n        for (var i in this.situation.once) {\n          if (i > this.lastPos && i <= eased) {\n            this.situation.once[i].call(this.target(), this.pos, eased);\n            delete this.situation.once[i];\n          }\n        } // fire during callback with position, eased position and current situation as parameter\n\n\n        if (this.active) this.target().fire('during', {\n          pos: this.pos,\n          eased: eased,\n          fx: this,\n          situation: this.situation\n        }); // the user may call stop or finish in the during callback\n        // so make sure that we still have a valid situation\n\n        if (!this.situation) {\n          return this;\n        } // apply the actual animation to every property\n\n\n        this.eachAt(); // do final code when situation is finished\n\n        if (this.pos == 1 && !this.situation.reversed || this.situation.reversed && this.pos == 0) {\n          // stop animation callback\n          this.stopAnimFrame(); // fire finished callback with current situation as parameter\n\n          this.target().fire('finished', {\n            fx: this,\n            situation: this.situation\n          });\n\n          if (!this.situations.length) {\n            this.target().fire('allfinished'); // Recheck the length since the user may call animate in the afterAll callback\n\n            if (!this.situations.length) {\n              this.target().off('.fx'); // there shouldnt be any binding left, but to make sure...\n\n              this.active = false;\n            }\n          } // start next animation\n\n\n          if (this.active) this.dequeue();else this.clearCurrent();\n        } else if (!this.paused && this.active) {\n          // we continue animating when we are not at the end\n          this.startAnimFrame();\n        } // save last eased position for once callback triggering\n\n\n        this.lastPos = eased;\n        return this;\n      } // calculates the step for every property and calls block with it\n      ,\n      eachAt: function eachAt() {\n        var i,\n            len,\n            at,\n            self = this,\n            target = this.target(),\n            s = this.situation; // apply animations which can be called trough a method\n\n        for (i in s.animations) {\n          at = [].concat(s.animations[i]).map(function (el) {\n            return typeof el !== 'string' && el.at ? el.at(s.ease(self.pos), self.pos) : el;\n          });\n          target[i].apply(target, at);\n        } // apply animation which has to be applied with attr()\n\n\n        for (i in s.attrs) {\n          at = [i].concat(s.attrs[i]).map(function (el) {\n            return typeof el !== 'string' && el.at ? el.at(s.ease(self.pos), self.pos) : el;\n          });\n          target.attr.apply(target, at);\n        } // apply animation which has to be applied with style()\n\n\n        for (i in s.styles) {\n          at = [i].concat(s.styles[i]).map(function (el) {\n            return typeof el !== 'string' && el.at ? el.at(s.ease(self.pos), self.pos) : el;\n          });\n          target.style.apply(target, at);\n        } // animate initialTransformation which has to be chained\n\n\n        if (s.transforms.length) {\n          // get initial initialTransformation\n          at = s.initialTransformation;\n\n          for (i = 0, len = s.transforms.length; i < len; i++) {\n            // get next transformation in chain\n            var a = s.transforms[i]; // multiply matrix directly\n\n            if (a instanceof SVG.Matrix) {\n              if (a.relative) {\n                at = at.multiply(new SVG.Matrix().morph(a).at(s.ease(this.pos)));\n              } else {\n                at = at.morph(a).at(s.ease(this.pos));\n              }\n\n              continue;\n            } // when transformation is absolute we have to reset the needed transformation first\n\n\n            if (!a.relative) a.undo(at.extract()); // and reapply it after\n\n            at = at.multiply(a.at(s.ease(this.pos)));\n          } // set new matrix on element\n\n\n          target.matrix(at);\n        }\n\n        return this;\n      } // adds an once-callback which is called at a specific position and never again\n      ,\n      once: function once(pos, fn, isEased) {\n        var c = this.last();\n        if (!isEased) pos = c.ease(pos);\n        c.once[pos] = fn;\n        return this;\n      },\n      _callStart: function _callStart() {\n        setTimeout(function () {\n          this.start();\n        }.bind(this), 0);\n        return this;\n      }\n    },\n    parent: SVG.Element // Add method to parent elements\n    ,\n    construct: {\n      // Get fx module or create a new one, then animate with given duration and ease\n      animate: function animate(o, ease, delay) {\n        return (this.fx || (this.fx = new SVG.FX(this))).animate(o, ease, delay);\n      },\n      delay: function delay(_delay2) {\n        return (this.fx || (this.fx = new SVG.FX(this))).delay(_delay2);\n      },\n      stop: function stop(jumpToEnd, clearQueue) {\n        if (this.fx) this.fx.stop(jumpToEnd, clearQueue);\n        return this;\n      },\n      finish: function finish() {\n        if (this.fx) this.fx.finish();\n        return this;\n      } // Pause current animation\n      ,\n      pause: function pause() {\n        if (this.fx) this.fx.pause();\n        return this;\n      } // Play paused current animation\n      ,\n      play: function play() {\n        if (this.fx) this.fx.play();\n        return this;\n      } // Set/Get the speed of the animations\n      ,\n      speed: function speed(_speed2) {\n        if (this.fx) if (_speed2 == null) return this.fx.speed();else this.fx.speed(_speed2);\n        return this;\n      }\n    }\n  }); // MorphObj is used whenever no morphable object is given\n\n  SVG.MorphObj = SVG.invent({\n    create: function create(from, to) {\n      // prepare color for morphing\n      if (SVG.Color.isColor(to)) return new SVG.Color(from).morph(to); // check if we have a list of values\n\n      if (SVG.regex.delimiter.test(from)) {\n        // prepare path for morphing\n        if (SVG.regex.pathLetters.test(from)) return new SVG.PathArray(from).morph(to); // prepare value list for morphing\n        else return new SVG.Array(from).morph(to);\n      } // prepare number for morphing\n\n\n      if (SVG.regex.numberAndUnit.test(to)) return new SVG.Number(from).morph(to); // prepare for plain morphing\n\n      this.value = from;\n      this.destination = to;\n    },\n    extend: {\n      at: function at(pos, real) {\n        return real < 1 ? this.value : this.destination;\n      },\n      valueOf: function valueOf() {\n        return this.value;\n      }\n    }\n  });\n  SVG.extend(SVG.FX, {\n    // Add animatable attributes\n    attr: function attr(a, v, relative) {\n      // apply attributes individually\n      if (_typeof(a) == 'object') {\n        for (var key in a) {\n          this.attr(key, a[key]);\n        }\n      } else {\n        this.add(a, v, 'attrs');\n      }\n\n      return this;\n    } // Add animatable styles\n    ,\n    style: function style(s, v) {\n      if (_typeof(s) == 'object') for (var key in s) {\n        this.style(key, s[key]);\n      } else this.add(s, v, 'styles');\n      return this;\n    } // Animatable x-axis\n    ,\n    x: function x(_x2, relative) {\n      if (this.target() instanceof SVG.G) {\n        this.transform({\n          x: _x2\n        }, relative);\n        return this;\n      }\n\n      var num = new SVG.Number(_x2);\n      num.relative = relative;\n      return this.add('x', num);\n    } // Animatable y-axis\n    ,\n    y: function y(_y2, relative) {\n      if (this.target() instanceof SVG.G) {\n        this.transform({\n          y: _y2\n        }, relative);\n        return this;\n      }\n\n      var num = new SVG.Number(_y2);\n      num.relative = relative;\n      return this.add('y', num);\n    } // Animatable center x-axis\n    ,\n    cx: function cx(x) {\n      return this.add('cx', new SVG.Number(x));\n    } // Animatable center y-axis\n    ,\n    cy: function cy(y) {\n      return this.add('cy', new SVG.Number(y));\n    } // Add animatable move\n    ,\n    move: function move(x, y) {\n      return this.x(x).y(y);\n    } // Add animatable center\n    ,\n    center: function center(x, y) {\n      return this.cx(x).cy(y);\n    } // Add animatable size\n    ,\n    size: function size(width, height) {\n      if (this.target() instanceof SVG.Text) {\n        // animate font size for Text elements\n        this.attr('font-size', width);\n      } else {\n        // animate bbox based size for all other elements\n        var box;\n\n        if (!width || !height) {\n          box = this.target().bbox();\n        }\n\n        if (!width) {\n          width = box.width / box.height * height;\n        }\n\n        if (!height) {\n          height = box.height / box.width * width;\n        }\n\n        this.add('width', new SVG.Number(width)).add('height', new SVG.Number(height));\n      }\n\n      return this;\n    } // Add animatable width\n    ,\n    width: function width(_width2) {\n      return this.add('width', new SVG.Number(_width2));\n    } // Add animatable height\n    ,\n    height: function height(_height2) {\n      return this.add('height', new SVG.Number(_height2));\n    } // Add animatable plot\n    ,\n    plot: function plot(a, b, c, d) {\n      // Lines can be plotted with 4 arguments\n      if (arguments.length == 4) {\n        return this.plot([a, b, c, d]);\n      }\n\n      return this.add('plot', new (this.target().morphArray)(a));\n    } // Add leading method\n    ,\n    leading: function leading(value) {\n      return this.target().leading ? this.add('leading', new SVG.Number(value)) : this;\n    } // Add animatable viewbox\n    ,\n    viewbox: function viewbox(x, y, width, height) {\n      if (this.target() instanceof SVG.Container) {\n        this.add('viewbox', new SVG.ViewBox(x, y, width, height));\n      }\n\n      return this;\n    },\n    update: function update(o) {\n      if (this.target() instanceof SVG.Stop) {\n        if (typeof o == 'number' || o instanceof SVG.Number) {\n          return this.update({\n            offset: arguments[0],\n            color: arguments[1],\n            opacity: arguments[2]\n          });\n        }\n\n        if (o.opacity != null) this.attr('stop-opacity', o.opacity);\n        if (o.color != null) this.attr('stop-color', o.color);\n        if (o.offset != null) this.attr('offset', o.offset);\n      }\n\n      return this;\n    }\n  });\n  SVG.Box = SVG.invent({\n    create: function create(x, y, width, height) {\n      if (_typeof(x) == 'object' && !(x instanceof SVG.Element)) {\n        // chromes getBoundingClientRect has no x and y property\n        return SVG.Box.call(this, x.left != null ? x.left : x.x, x.top != null ? x.top : x.y, x.width, x.height);\n      } else if (arguments.length == 4) {\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n      } // add center, right, bottom...\n\n\n      fullBox(this);\n    },\n    extend: {\n      // Merge rect box with another, return a new instance\n      merge: function merge(box) {\n        var b = new this.constructor(); // merge boxes\n\n        b.x = Math.min(this.x, box.x);\n        b.y = Math.min(this.y, box.y);\n        b.width = Math.max(this.x + this.width, box.x + box.width) - b.x;\n        b.height = Math.max(this.y + this.height, box.y + box.height) - b.y;\n        return fullBox(b);\n      },\n      transform: function transform(m) {\n        var xMin = Infinity,\n            xMax = -Infinity,\n            yMin = Infinity,\n            yMax = -Infinity,\n            p,\n            bbox;\n        var pts = [new SVG.Point(this.x, this.y), new SVG.Point(this.x2, this.y), new SVG.Point(this.x, this.y2), new SVG.Point(this.x2, this.y2)];\n        pts.forEach(function (p) {\n          p = p.transform(m);\n          xMin = Math.min(xMin, p.x);\n          xMax = Math.max(xMax, p.x);\n          yMin = Math.min(yMin, p.y);\n          yMax = Math.max(yMax, p.y);\n        });\n        bbox = new this.constructor();\n        bbox.x = xMin;\n        bbox.width = xMax - xMin;\n        bbox.y = yMin;\n        bbox.height = yMax - yMin;\n        fullBox(bbox);\n        return bbox;\n      }\n    }\n  });\n  SVG.BBox = SVG.invent({\n    // Initialize\n    create: function create(element) {\n      SVG.Box.apply(this, [].slice.call(arguments)); // get values if element is given\n\n      if (element instanceof SVG.Element) {\n        var box; // yes this is ugly, but Firefox can be a pain when it comes to elements that are not yet rendered\n\n        try {\n          if (!document.documentElement.contains) {\n            // This is IE - it does not support contains() for top-level SVGs\n            var topParent = element.node;\n\n            while (topParent.parentNode) {\n              topParent = topParent.parentNode;\n            }\n\n            if (topParent != document) throw new Exception('Element not in the dom');\n          } else {\n            // the element is NOT in the dom, throw error\n            if (!document.documentElement.contains(element.node)) throw new Exception('Element not in the dom');\n          } // find native bbox\n\n\n          box = element.node.getBBox();\n        } catch (e) {\n          if (element instanceof SVG.Shape) {\n            var clone = element.clone(SVG.parser.draw.instance).show();\n            box = clone.node.getBBox();\n            clone.remove();\n          } else {\n            box = {\n              x: element.node.clientLeft,\n              y: element.node.clientTop,\n              width: element.node.clientWidth,\n              height: element.node.clientHeight\n            };\n          }\n        }\n\n        SVG.Box.call(this, box);\n      }\n    } // Define ancestor\n    ,\n    inherit: SVG.Box // Define Parent\n    ,\n    parent: SVG.Element // Constructor\n    ,\n    construct: {\n      // Get bounding box\n      bbox: function bbox() {\n        return new SVG.BBox(this);\n      }\n    }\n  });\n  SVG.BBox.prototype.constructor = SVG.BBox;\n  SVG.extend(SVG.Element, {\n    tbox: function tbox() {\n      console.warn('Use of TBox is deprecated and mapped to RBox. Use .rbox() instead.');\n      return this.rbox(this.doc());\n    }\n  });\n  SVG.RBox = SVG.invent({\n    // Initialize\n    create: function create(element) {\n      SVG.Box.apply(this, [].slice.call(arguments));\n\n      if (element instanceof SVG.Element) {\n        SVG.Box.call(this, element.node.getBoundingClientRect());\n      }\n    },\n    inherit: SVG.Box // define Parent\n    ,\n    parent: SVG.Element,\n    extend: {\n      addOffset: function addOffset() {\n        // offset by window scroll position, because getBoundingClientRect changes when window is scrolled\n        this.x += window.pageXOffset;\n        this.y += window.pageYOffset;\n        return this;\n      }\n    } // Constructor\n    ,\n    construct: {\n      // Get rect box\n      rbox: function rbox(el) {\n        if (el) return new SVG.RBox(this).transform(el.screenCTM().inverse());\n        return new SVG.RBox(this).addOffset();\n      }\n    }\n  });\n  SVG.RBox.prototype.constructor = SVG.RBox;\n  SVG.Matrix = SVG.invent({\n    // Initialize\n    create: function create(source) {\n      var i,\n          base = arrayToMatrix([1, 0, 0, 1, 0, 0]); // ensure source as object\n\n      source = source instanceof SVG.Element ? source.matrixify() : typeof source === 'string' ? arrayToMatrix(source.split(SVG.regex.delimiter).map(parseFloat)) : arguments.length == 6 ? arrayToMatrix([].slice.call(arguments)) : Array.isArray(source) ? arrayToMatrix(source) : _typeof(source) === 'object' ? source : base; // merge source\n\n      for (i = abcdef.length - 1; i >= 0; --i) {\n        this[abcdef[i]] = source[abcdef[i]] != null ? source[abcdef[i]] : base[abcdef[i]];\n      }\n    } // Add methods\n    ,\n    extend: {\n      // Extract individual transformations\n      extract: function extract() {\n        // find delta transform points\n        var px = deltaTransformPoint(this, 0, 1),\n            py = deltaTransformPoint(this, 1, 0),\n            skewX = 180 / Math.PI * Math.atan2(px.y, px.x) - 90;\n        return {\n          // translation\n          x: this.e,\n          y: this.f,\n          transformedX: (this.e * Math.cos(skewX * Math.PI / 180) + this.f * Math.sin(skewX * Math.PI / 180)) / Math.sqrt(this.a * this.a + this.b * this.b),\n          transformedY: (this.f * Math.cos(skewX * Math.PI / 180) + this.e * Math.sin(-skewX * Math.PI / 180)) / Math.sqrt(this.c * this.c + this.d * this.d) // skew\n          ,\n          skewX: -skewX,\n          skewY: 180 / Math.PI * Math.atan2(py.y, py.x) // scale\n          ,\n          scaleX: Math.sqrt(this.a * this.a + this.b * this.b),\n          scaleY: Math.sqrt(this.c * this.c + this.d * this.d) // rotation\n          ,\n          rotation: skewX,\n          a: this.a,\n          b: this.b,\n          c: this.c,\n          d: this.d,\n          e: this.e,\n          f: this.f,\n          matrix: new SVG.Matrix(this)\n        };\n      } // Clone matrix\n      ,\n      clone: function clone() {\n        return new SVG.Matrix(this);\n      } // Morph one matrix into another\n      ,\n      morph: function morph(matrix) {\n        // store new destination\n        this.destination = new SVG.Matrix(matrix);\n        return this;\n      } // Get morphed matrix at a given position\n      ,\n      at: function at(pos) {\n        // make sure a destination is defined\n        if (!this.destination) return this; // calculate morphed matrix at a given position\n\n        var matrix = new SVG.Matrix({\n          a: this.a + (this.destination.a - this.a) * pos,\n          b: this.b + (this.destination.b - this.b) * pos,\n          c: this.c + (this.destination.c - this.c) * pos,\n          d: this.d + (this.destination.d - this.d) * pos,\n          e: this.e + (this.destination.e - this.e) * pos,\n          f: this.f + (this.destination.f - this.f) * pos\n        });\n        return matrix;\n      } // Multiplies by given matrix\n      ,\n      multiply: function multiply(matrix) {\n        return new SVG.Matrix(this.native().multiply(parseMatrix(matrix).native()));\n      } // Inverses matrix\n      ,\n      inverse: function inverse() {\n        return new SVG.Matrix(this.native().inverse());\n      } // Translate matrix\n      ,\n      translate: function translate(x, y) {\n        return new SVG.Matrix(this.native().translate(x || 0, y || 0));\n      } // Scale matrix\n      ,\n      scale: function scale(x, y, cx, cy) {\n        // support uniformal scale\n        if (arguments.length == 1) {\n          y = x;\n        } else if (arguments.length == 3) {\n          cy = cx;\n          cx = y;\n          y = x;\n        }\n\n        return this.around(cx, cy, new SVG.Matrix(x, 0, 0, y, 0, 0));\n      } // Rotate matrix\n      ,\n      rotate: function rotate(r, cx, cy) {\n        // convert degrees to radians\n        r = SVG.utils.radians(r);\n        return this.around(cx, cy, new SVG.Matrix(Math.cos(r), Math.sin(r), -Math.sin(r), Math.cos(r), 0, 0));\n      } // Flip matrix on x or y, at a given offset\n      ,\n      flip: function flip(a, o) {\n        return a == 'x' ? this.scale(-1, 1, o, 0) : a == 'y' ? this.scale(1, -1, 0, o) : this.scale(-1, -1, a, o != null ? o : a);\n      } // Skew\n      ,\n      skew: function skew(x, y, cx, cy) {\n        // support uniformal skew\n        if (arguments.length == 1) {\n          y = x;\n        } else if (arguments.length == 3) {\n          cy = cx;\n          cx = y;\n          y = x;\n        } // convert degrees to radians\n\n\n        x = SVG.utils.radians(x);\n        y = SVG.utils.radians(y);\n        return this.around(cx, cy, new SVG.Matrix(1, Math.tan(y), Math.tan(x), 1, 0, 0));\n      } // SkewX\n      ,\n      skewX: function skewX(x, cx, cy) {\n        return this.skew(x, 0, cx, cy);\n      } // SkewY\n      ,\n      skewY: function skewY(y, cx, cy) {\n        return this.skew(0, y, cx, cy);\n      } // Transform around a center point\n      ,\n      around: function around(cx, cy, matrix) {\n        return this.multiply(new SVG.Matrix(1, 0, 0, 1, cx || 0, cy || 0)).multiply(matrix).multiply(new SVG.Matrix(1, 0, 0, 1, -cx || 0, -cy || 0));\n      } // Convert to native SVGMatrix\n      ,\n      native: function native() {\n        // create new matrix\n        var matrix = SVG.parser.native.createSVGMatrix(); // update with current values\n\n        for (var i = abcdef.length - 1; i >= 0; i--) {\n          matrix[abcdef[i]] = this[abcdef[i]];\n        }\n\n        return matrix;\n      } // Convert matrix to string\n      ,\n      toString: function toString() {\n        // Construct the matrix directly, avoid values that are too small\n        return 'matrix(' + float32String(this.a) + ',' + float32String(this.b) + ',' + float32String(this.c) + ',' + float32String(this.d) + ',' + float32String(this.e) + ',' + float32String(this.f) + ')';\n      }\n    } // Define parent\n    ,\n    parent: SVG.Element // Add parent method\n    ,\n    construct: {\n      // Get current matrix\n      ctm: function ctm() {\n        return new SVG.Matrix(this.node.getCTM());\n      },\n      // Get current screen matrix\n      screenCTM: function screenCTM() {\n        /* https://bugzilla.mozilla.org/show_bug.cgi?id=1344537\n           This is needed because FF does not return the transformation matrix\n           for the inner coordinate system when getScreenCTM() is called on nested svgs.\n           However all other Browsers do that */\n        if (this instanceof SVG.Nested) {\n          var rect = this.rect(1, 1);\n          var m = rect.node.getScreenCTM();\n          rect.remove();\n          return new SVG.Matrix(m);\n        }\n\n        return new SVG.Matrix(this.node.getScreenCTM());\n      }\n    }\n  });\n  SVG.Point = SVG.invent({\n    // Initialize\n    create: function create(x, y) {\n      var i,\n          source,\n          base = {\n        x: 0,\n        y: 0\n      }; // ensure source as object\n\n      source = Array.isArray(x) ? {\n        x: x[0],\n        y: x[1]\n      } : _typeof(x) === 'object' ? {\n        x: x.x,\n        y: x.y\n      } : x != null ? {\n        x: x,\n        y: y != null ? y : x\n      } : base; // If y has no value, then x is used has its value\n      // merge source\n\n      this.x = source.x;\n      this.y = source.y;\n    } // Add methods\n    ,\n    extend: {\n      // Clone point\n      clone: function clone() {\n        return new SVG.Point(this);\n      } // Morph one point into another\n      ,\n      morph: function morph(x, y) {\n        // store new destination\n        this.destination = new SVG.Point(x, y);\n        return this;\n      } // Get morphed point at a given position\n      ,\n      at: function at(pos) {\n        // make sure a destination is defined\n        if (!this.destination) return this; // calculate morphed matrix at a given position\n\n        var point = new SVG.Point({\n          x: this.x + (this.destination.x - this.x) * pos,\n          y: this.y + (this.destination.y - this.y) * pos\n        });\n        return point;\n      } // Convert to native SVGPoint\n      ,\n      native: function native() {\n        // create new point\n        var point = SVG.parser.native.createSVGPoint(); // update with current values\n\n        point.x = this.x;\n        point.y = this.y;\n        return point;\n      } // transform point with matrix\n      ,\n      transform: function transform(matrix) {\n        return new SVG.Point(this.native().matrixTransform(matrix.native()));\n      }\n    }\n  });\n  SVG.extend(SVG.Element, {\n    // Get point\n    point: function point(x, y) {\n      return new SVG.Point(x, y).transform(this.screenCTM().inverse());\n    }\n  });\n  SVG.extend(SVG.Element, {\n    // Set svg element attribute\n    attr: function attr(a, v, n) {\n      // act as full getter\n      if (a == null) {\n        // get an object of attributes\n        a = {};\n        v = this.node.attributes;\n\n        for (n = v.length - 1; n >= 0; n--) {\n          a[v[n].nodeName] = SVG.regex.isNumber.test(v[n].nodeValue) ? parseFloat(v[n].nodeValue) : v[n].nodeValue;\n        }\n\n        return a;\n      } else if (_typeof(a) == 'object') {\n        // apply every attribute individually if an object is passed\n        for (v in a) {\n          this.attr(v, a[v]);\n        }\n      } else if (v === null) {\n        // remove value\n        this.node.removeAttribute(a);\n      } else if (v == null) {\n        // act as a getter if the first and only argument is not an object\n        v = this.node.getAttribute(a);\n        return v == null ? SVG.defaults.attrs[a] : SVG.regex.isNumber.test(v) ? parseFloat(v) : v;\n      } else {\n        // BUG FIX: some browsers will render a stroke if a color is given even though stroke width is 0\n        if (a == 'stroke-width') this.attr('stroke', parseFloat(v) > 0 ? this._stroke : null);else if (a == 'stroke') this._stroke = v; // convert image fill and stroke to patterns\n\n        if (a == 'fill' || a == 'stroke') {\n          if (SVG.regex.isImage.test(v)) v = this.doc().defs().image(v, 0, 0);\n          if (v instanceof SVG.Image) v = this.doc().defs().pattern(0, 0, function () {\n            this.add(v);\n          });\n        } // ensure correct numeric values (also accepts NaN and Infinity)\n\n\n        if (typeof v === 'number') v = new SVG.Number(v); // ensure full hex color\n        else if (SVG.Color.isColor(v)) v = new SVG.Color(v); // parse array values\n          else if (Array.isArray(v)) v = new SVG.Array(v); // if the passed attribute is leading...\n\n        if (a == 'leading') {\n          // ... call the leading method instead\n          if (this.leading) this.leading(v);\n        } else {\n          // set given attribute on node\n          typeof n === 'string' ? this.node.setAttributeNS(n, a, v.toString()) : this.node.setAttribute(a, v.toString());\n        } // rebuild if required\n\n\n        if (this.rebuild && (a == 'font-size' || a == 'x')) this.rebuild(a, v);\n      }\n\n      return this;\n    }\n  });\n  SVG.extend(SVG.Element, {\n    // Add transformations\n    transform: function transform(o, relative) {\n      // get target in case of the fx module, otherwise reference this\n      var target = this,\n          matrix,\n          bbox; // act as a getter\n\n      if (_typeof(o) !== 'object') {\n        // get current matrix\n        matrix = new SVG.Matrix(target).extract();\n        return typeof o === 'string' ? matrix[o] : matrix;\n      } // get current matrix\n\n\n      matrix = new SVG.Matrix(target); // ensure relative flag\n\n      relative = !!relative || !!o.relative; // act on matrix\n\n      if (o.a != null) {\n        matrix = relative ? // relative\n        matrix.multiply(new SVG.Matrix(o)) : // absolute\n        new SVG.Matrix(o); // act on rotation\n      } else if (o.rotation != null) {\n        // ensure centre point\n        ensureCentre(o, target); // apply transformation\n\n        matrix = relative ? // relative\n        matrix.rotate(o.rotation, o.cx, o.cy) : // absolute\n        matrix.rotate(o.rotation - matrix.extract().rotation, o.cx, o.cy); // act on scale\n      } else if (o.scale != null || o.scaleX != null || o.scaleY != null) {\n        // ensure centre point\n        ensureCentre(o, target); // ensure scale values on both axes\n\n        o.scaleX = o.scale != null ? o.scale : o.scaleX != null ? o.scaleX : 1;\n        o.scaleY = o.scale != null ? o.scale : o.scaleY != null ? o.scaleY : 1;\n\n        if (!relative) {\n          // absolute; multiply inversed values\n          var e = matrix.extract();\n          o.scaleX = o.scaleX * 1 / e.scaleX;\n          o.scaleY = o.scaleY * 1 / e.scaleY;\n        }\n\n        matrix = matrix.scale(o.scaleX, o.scaleY, o.cx, o.cy); // act on skew\n      } else if (o.skew != null || o.skewX != null || o.skewY != null) {\n        // ensure centre point\n        ensureCentre(o, target); // ensure skew values on both axes\n\n        o.skewX = o.skew != null ? o.skew : o.skewX != null ? o.skewX : 0;\n        o.skewY = o.skew != null ? o.skew : o.skewY != null ? o.skewY : 0;\n\n        if (!relative) {\n          // absolute; reset skew values\n          var e = matrix.extract();\n          matrix = matrix.multiply(new SVG.Matrix().skew(e.skewX, e.skewY, o.cx, o.cy).inverse());\n        }\n\n        matrix = matrix.skew(o.skewX, o.skewY, o.cx, o.cy); // act on flip\n      } else if (o.flip) {\n        if (o.flip == 'x' || o.flip == 'y') {\n          o.offset = o.offset == null ? target.bbox()['c' + o.flip] : o.offset;\n        } else {\n          if (o.offset == null) {\n            bbox = target.bbox();\n            o.flip = bbox.cx;\n            o.offset = bbox.cy;\n          } else {\n            o.flip = o.offset;\n          }\n        }\n\n        matrix = new SVG.Matrix().flip(o.flip, o.offset); // act on translate\n      } else if (o.x != null || o.y != null) {\n        if (relative) {\n          // relative\n          matrix = matrix.translate(o.x, o.y);\n        } else {\n          // absolute\n          if (o.x != null) matrix.e = o.x;\n          if (o.y != null) matrix.f = o.y;\n        }\n      }\n\n      return this.attr('transform', matrix);\n    }\n  });\n  SVG.extend(SVG.FX, {\n    transform: function transform(o, relative) {\n      // get target in case of the fx module, otherwise reference this\n      var target = this.target(),\n          matrix,\n          bbox; // act as a getter\n\n      if (_typeof(o) !== 'object') {\n        // get current matrix\n        matrix = new SVG.Matrix(target).extract();\n        return typeof o === 'string' ? matrix[o] : matrix;\n      } // ensure relative flag\n\n\n      relative = !!relative || !!o.relative; // act on matrix\n\n      if (o.a != null) {\n        matrix = new SVG.Matrix(o); // act on rotation\n      } else if (o.rotation != null) {\n        // ensure centre point\n        ensureCentre(o, target); // apply transformation\n\n        matrix = new SVG.Rotate(o.rotation, o.cx, o.cy); // act on scale\n      } else if (o.scale != null || o.scaleX != null || o.scaleY != null) {\n        // ensure centre point\n        ensureCentre(o, target); // ensure scale values on both axes\n\n        o.scaleX = o.scale != null ? o.scale : o.scaleX != null ? o.scaleX : 1;\n        o.scaleY = o.scale != null ? o.scale : o.scaleY != null ? o.scaleY : 1;\n        matrix = new SVG.Scale(o.scaleX, o.scaleY, o.cx, o.cy); // act on skew\n      } else if (o.skewX != null || o.skewY != null) {\n        // ensure centre point\n        ensureCentre(o, target); // ensure skew values on both axes\n\n        o.skewX = o.skewX != null ? o.skewX : 0;\n        o.skewY = o.skewY != null ? o.skewY : 0;\n        matrix = new SVG.Skew(o.skewX, o.skewY, o.cx, o.cy); // act on flip\n      } else if (o.flip) {\n        if (o.flip == 'x' || o.flip == 'y') {\n          o.offset = o.offset == null ? target.bbox()['c' + o.flip] : o.offset;\n        } else {\n          if (o.offset == null) {\n            bbox = target.bbox();\n            o.flip = bbox.cx;\n            o.offset = bbox.cy;\n          } else {\n            o.flip = o.offset;\n          }\n        }\n\n        matrix = new SVG.Matrix().flip(o.flip, o.offset); // act on translate\n      } else if (o.x != null || o.y != null) {\n        matrix = new SVG.Translate(o.x, o.y);\n      }\n\n      if (!matrix) return this;\n      matrix.relative = relative;\n      this.last().transforms.push(matrix);\n      return this._callStart();\n    }\n  });\n  SVG.extend(SVG.Element, {\n    // Reset all transformations\n    untransform: function untransform() {\n      return this.attr('transform', null);\n    },\n    // merge the whole transformation chain into one matrix and returns it\n    matrixify: function matrixify() {\n      var matrix = (this.attr('transform') || ''). // split transformations\n      split(SVG.regex.transforms).slice(0, -1).map(function (str) {\n        // generate key => value pairs\n        var kv = str.trim().split('(');\n        return [kv[0], kv[1].split(SVG.regex.delimiter).map(function (str) {\n          return parseFloat(str);\n        })];\n      }) // merge every transformation into one matrix\n      .reduce(function (matrix, transform) {\n        if (transform[0] == 'matrix') return matrix.multiply(arrayToMatrix(transform[1]));\n        return matrix[transform[0]].apply(matrix, transform[1]);\n      }, new SVG.Matrix());\n      return matrix;\n    },\n    // add an element to another parent without changing the visual representation on the screen\n    toParent: function toParent(parent) {\n      if (this == parent) return this;\n      var ctm = this.screenCTM();\n      var pCtm = parent.screenCTM().inverse();\n      this.addTo(parent).untransform().transform(pCtm.multiply(ctm));\n      return this;\n    },\n    // same as above with parent equals root-svg\n    toDoc: function toDoc() {\n      return this.toParent(this.doc());\n    }\n  });\n  SVG.Transformation = SVG.invent({\n    create: function create(source, inversed) {\n      if (arguments.length > 1 && typeof inversed != 'boolean') {\n        return this.constructor.call(this, [].slice.call(arguments));\n      }\n\n      if (Array.isArray(source)) {\n        for (var i = 0, len = this.arguments.length; i < len; ++i) {\n          this[this.arguments[i]] = source[i];\n        }\n      } else if (_typeof(source) == 'object') {\n        for (var i = 0, len = this.arguments.length; i < len; ++i) {\n          this[this.arguments[i]] = source[this.arguments[i]];\n        }\n      }\n\n      this.inversed = false;\n\n      if (inversed === true) {\n        this.inversed = true;\n      }\n    },\n    extend: {\n      arguments: [],\n      method: '',\n      at: function at(pos) {\n        var params = [];\n\n        for (var i = 0, len = this.arguments.length; i < len; ++i) {\n          params.push(this[this.arguments[i]]);\n        }\n\n        var m = this._undo || new SVG.Matrix();\n        m = new SVG.Matrix().morph(SVG.Matrix.prototype[this.method].apply(m, params)).at(pos);\n        return this.inversed ? m.inverse() : m;\n      },\n      undo: function undo(o) {\n        for (var i = 0, len = this.arguments.length; i < len; ++i) {\n          o[this.arguments[i]] = typeof this[this.arguments[i]] == 'undefined' ? 0 : o[this.arguments[i]];\n        } // The method SVG.Matrix.extract which was used before calling this\n        // method to obtain a value for the parameter o doesn't return a cx and\n        // a cy so we use the ones that were provided to this object at its creation\n\n\n        o.cx = this.cx;\n        o.cy = this.cy;\n        this._undo = new SVG[capitalize(this.method)](o, true).at(1);\n        return this;\n      }\n    }\n  });\n  SVG.Translate = SVG.invent({\n    parent: SVG.Matrix,\n    inherit: SVG.Transformation,\n    create: function create(source, inversed) {\n      this.constructor.apply(this, [].slice.call(arguments));\n    },\n    extend: {\n      arguments: ['transformedX', 'transformedY'],\n      method: 'translate'\n    }\n  });\n  SVG.Rotate = SVG.invent({\n    parent: SVG.Matrix,\n    inherit: SVG.Transformation,\n    create: function create(source, inversed) {\n      this.constructor.apply(this, [].slice.call(arguments));\n    },\n    extend: {\n      arguments: ['rotation', 'cx', 'cy'],\n      method: 'rotate',\n      at: function at(pos) {\n        var m = new SVG.Matrix().rotate(new SVG.Number().morph(this.rotation - (this._undo ? this._undo.rotation : 0)).at(pos), this.cx, this.cy);\n        return this.inversed ? m.inverse() : m;\n      },\n      undo: function undo(o) {\n        this._undo = o;\n        return this;\n      }\n    }\n  });\n  SVG.Scale = SVG.invent({\n    parent: SVG.Matrix,\n    inherit: SVG.Transformation,\n    create: function create(source, inversed) {\n      this.constructor.apply(this, [].slice.call(arguments));\n    },\n    extend: {\n      arguments: ['scaleX', 'scaleY', 'cx', 'cy'],\n      method: 'scale'\n    }\n  });\n  SVG.Skew = SVG.invent({\n    parent: SVG.Matrix,\n    inherit: SVG.Transformation,\n    create: function create(source, inversed) {\n      this.constructor.apply(this, [].slice.call(arguments));\n    },\n    extend: {\n      arguments: ['skewX', 'skewY', 'cx', 'cy'],\n      method: 'skew'\n    }\n  });\n  SVG.extend(SVG.Element, {\n    // Dynamic style generator\n    style: function style(s, v) {\n      if (arguments.length == 0) {\n        // get full style\n        return this.node.style.cssText || '';\n      } else if (arguments.length < 2) {\n        // apply every style individually if an object is passed\n        if (_typeof(s) == 'object') {\n          for (v in s) {\n            this.style(v, s[v]);\n          }\n        } else if (SVG.regex.isCss.test(s)) {\n          // parse css string\n          s = s.split(/\\s*;\\s*/) // filter out suffix ; and stuff like ;;\n          .filter(function (e) {\n            return !!e;\n          }).map(function (e) {\n            return e.split(/\\s*:\\s*/);\n          }); // apply every definition individually\n\n          while (v = s.pop()) {\n            this.style(v[0], v[1]);\n          }\n        } else {\n          // act as a getter if the first and only argument is not an object\n          return this.node.style[camelCase(s)];\n        }\n      } else {\n        this.node.style[camelCase(s)] = v === null || SVG.regex.isBlank.test(v) ? '' : v;\n      }\n\n      return this;\n    }\n  });\n  SVG.Parent = SVG.invent({\n    // Initialize node\n    create: function create(element) {\n      this.constructor.call(this, element);\n    } // Inherit from\n    ,\n    inherit: SVG.Element // Add class methods\n    ,\n    extend: {\n      // Returns all child elements\n      children: function children() {\n        return SVG.utils.map(SVG.utils.filterSVGElements(this.node.childNodes), function (node) {\n          return SVG.adopt(node);\n        });\n      } // Add given element at a position\n      ,\n      add: function add(element, i) {\n        if (i == null) this.node.appendChild(element.node);else if (element.node != this.node.childNodes[i]) this.node.insertBefore(element.node, this.node.childNodes[i]);\n        return this;\n      } // Basically does the same as `add()` but returns the added element instead\n      ,\n      put: function put(element, i) {\n        this.add(element, i);\n        return element;\n      } // Checks if the given element is a child\n      ,\n      has: function has(element) {\n        return this.index(element) >= 0;\n      } // Gets index of given element\n      ,\n      index: function index(element) {\n        return [].slice.call(this.node.childNodes).indexOf(element.node);\n      } // Get a element at the given index\n      ,\n      get: function get(i) {\n        return SVG.adopt(this.node.childNodes[i]);\n      } // Get first child\n      ,\n      first: function first() {\n        return this.get(0);\n      } // Get the last child\n      ,\n      last: function last() {\n        return this.get(this.node.childNodes.length - 1);\n      } // Iterates over all children and invokes a given block\n      ,\n      each: function each(block, deep) {\n        var i,\n            il,\n            children = this.children();\n\n        for (i = 0, il = children.length; i < il; i++) {\n          if (children[i] instanceof SVG.Element) block.apply(children[i], [i, children]);\n          if (deep && children[i] instanceof SVG.Container) children[i].each(block, deep);\n        }\n\n        return this;\n      } // Remove a given child\n      ,\n      removeElement: function removeElement(element) {\n        this.node.removeChild(element.node);\n        return this;\n      } // Remove all elements in this container\n      ,\n      clear: function clear() {\n        // remove children\n        while (this.node.hasChildNodes()) {\n          this.node.removeChild(this.node.lastChild);\n        } // remove defs reference\n\n\n        delete this._defs;\n        return this;\n      },\n      // Get defs\n      defs: function defs() {\n        return this.doc().defs();\n      }\n    }\n  });\n  SVG.extend(SVG.Parent, {\n    ungroup: function ungroup(parent, depth) {\n      if (depth === 0 || this instanceof SVG.Defs || this.node == SVG.parser.draw) return this;\n      parent = parent || (this instanceof SVG.Doc ? this : this.parent(SVG.Parent));\n      depth = depth || Infinity;\n      this.each(function () {\n        if (this instanceof SVG.Defs) return this;\n        if (this instanceof SVG.Parent) return this.ungroup(parent, depth - 1);\n        return this.toParent(parent);\n      });\n      this.node.firstChild || this.remove();\n      return this;\n    },\n    flatten: function flatten(parent, depth) {\n      return this.ungroup(parent, depth);\n    }\n  });\n  SVG.Container = SVG.invent({\n    // Initialize node\n    create: function create(element) {\n      this.constructor.call(this, element);\n    } // Inherit from\n    ,\n    inherit: SVG.Parent\n  });\n  SVG.ViewBox = SVG.invent({\n    create: function create(source) {\n      var i,\n          base = [0, 0, 0, 0];\n      var x,\n          y,\n          width,\n          height,\n          box,\n          view,\n          we,\n          he,\n          wm = 1 // width multiplier\n      ,\n          hm = 1 // height multiplier\n      ,\n          reg = /[+-]?(?:\\d+(?:\\.\\d*)?|\\.\\d+)(?:e[+-]?\\d+)?/gi;\n\n      if (source instanceof SVG.Element) {\n        we = source;\n        he = source;\n        view = (source.attr('viewBox') || '').match(reg);\n        box = source.bbox; // get dimensions of current node\n\n        width = new SVG.Number(source.width());\n        height = new SVG.Number(source.height()); // find nearest non-percentual dimensions\n\n        while (width.unit == '%') {\n          wm *= width.value;\n          width = new SVG.Number(we instanceof SVG.Doc ? we.parent().offsetWidth : we.parent().width());\n          we = we.parent();\n        }\n\n        while (height.unit == '%') {\n          hm *= height.value;\n          height = new SVG.Number(he instanceof SVG.Doc ? he.parent().offsetHeight : he.parent().height());\n          he = he.parent();\n        } // ensure defaults\n\n\n        this.x = 0;\n        this.y = 0;\n        this.width = width * wm;\n        this.height = height * hm;\n        this.zoom = 1;\n\n        if (view) {\n          // get width and height from viewbox\n          x = parseFloat(view[0]);\n          y = parseFloat(view[1]);\n          width = parseFloat(view[2]);\n          height = parseFloat(view[3]); // calculate zoom accoring to viewbox\n\n          this.zoom = this.width / this.height > width / height ? this.height / height : this.width / width; // calculate real pixel dimensions on parent SVG.Doc element\n\n          this.x = x;\n          this.y = y;\n          this.width = width;\n          this.height = height;\n        }\n      } else {\n        // ensure source as object\n        source = typeof source === 'string' ? source.match(reg).map(function (el) {\n          return parseFloat(el);\n        }) : Array.isArray(source) ? source : _typeof(source) == 'object' ? [source.x, source.y, source.width, source.height] : arguments.length == 4 ? [].slice.call(arguments) : base;\n        this.x = source[0];\n        this.y = source[1];\n        this.width = source[2];\n        this.height = source[3];\n      }\n    },\n    extend: {\n      toString: function toString() {\n        return this.x + ' ' + this.y + ' ' + this.width + ' ' + this.height;\n      },\n      morph: function morph(x, y, width, height) {\n        this.destination = new SVG.ViewBox(x, y, width, height);\n        return this;\n      },\n      at: function at(pos) {\n        if (!this.destination) return this;\n        return new SVG.ViewBox([this.x + (this.destination.x - this.x) * pos, this.y + (this.destination.y - this.y) * pos, this.width + (this.destination.width - this.width) * pos, this.height + (this.destination.height - this.height) * pos]);\n      }\n    } // Define parent\n    ,\n    parent: SVG.Container // Add parent method\n    ,\n    construct: {\n      // get/set viewbox\n      viewbox: function viewbox(x, y, width, height) {\n        if (arguments.length == 0) // act as a getter if there are no arguments\n          return new SVG.ViewBox(this); // otherwise act as a setter\n\n        return this.attr('viewBox', new SVG.ViewBox(x, y, width, height));\n      }\n    }\n  }) // Add events to elements\n  ;\n  ['click', 'dblclick', 'mousedown', 'mouseup', 'mouseover', 'mouseout', 'mousemove', 'mouseenter', 'mouseleave', 'touchstart', 'touchmove', 'touchleave', 'touchend', 'touchcancel'].forEach(function (event) {\n    // add event to SVG.Element\n    SVG.Element.prototype[event] = function (f) {\n      // bind event to element rather than element node\n      if (f == null) {\n        SVG.off(this, event);\n      } else {\n        SVG.on(this, event, f);\n      }\n\n      return this;\n    };\n  });\n  SVG.listenerId = 0; // Add event binder in the SVG namespace\n\n  SVG.on = function (node, events, listener, binding, options) {\n    var l = listener.bind(binding || node);\n    var n = node instanceof SVG.Element ? node.node : node; // ensure instance object for nodes which are not adopted\n\n    n.instance = n.instance || {\n      _events: {}\n    };\n    var bag = n.instance._events; // add id to listener\n\n    if (!listener._svgjsListenerId) {\n      listener._svgjsListenerId = ++SVG.listenerId;\n    }\n\n    events.split(SVG.regex.delimiter).forEach(function (event) {\n      var ev = event.split('.')[0];\n      var ns = event.split('.')[1] || '*'; // ensure valid object\n\n      bag[ev] = bag[ev] || {};\n      bag[ev][ns] = bag[ev][ns] || {}; // reference listener\n\n      bag[ev][ns][listener._svgjsListenerId] = l; // add listener\n\n      n.addEventListener(ev, l, options || false);\n    });\n  }; // Add event unbinder in the SVG namespace\n\n\n  SVG.off = function (node, events, listener, options) {\n    var n = node instanceof SVG.Element ? node.node : node;\n    if (!n.instance) return; // listener can be a function or a number\n\n    if (typeof listener === 'function') {\n      listener = listener._svgjsListenerId;\n      if (!listener) return;\n    }\n\n    var bag = n.instance._events;\n    (events || '').split(SVG.regex.delimiter).forEach(function (event) {\n      var ev = event && event.split('.')[0];\n      var ns = event && event.split('.')[1];\n      var namespace, l;\n\n      if (listener) {\n        // remove listener reference\n        if (bag[ev] && bag[ev][ns || '*']) {\n          // removeListener\n          n.removeEventListener(ev, bag[ev][ns || '*'][listener], options || false);\n          delete bag[ev][ns || '*'][listener];\n        }\n      } else if (ev && ns) {\n        // remove all listeners for a namespaced event\n        if (bag[ev] && bag[ev][ns]) {\n          for (l in bag[ev][ns]) {\n            SVG.off(n, [ev, ns].join('.'), l);\n          }\n\n          delete bag[ev][ns];\n        }\n      } else if (ns) {\n        // remove all listeners for a specific namespace\n        for (event in bag) {\n          for (namespace in bag[event]) {\n            if (ns === namespace) {\n              SVG.off(n, [event, ns].join('.'));\n            }\n          }\n        }\n      } else if (ev) {\n        // remove all listeners for the event\n        if (bag[ev]) {\n          for (namespace in bag[ev]) {\n            SVG.off(n, [ev, namespace].join('.'));\n          }\n\n          delete bag[ev];\n        }\n      } else {\n        // remove all listeners on a given node\n        for (event in bag) {\n          SVG.off(n, event);\n        }\n\n        n.instance._events = {};\n      }\n    });\n  };\n\n  SVG.extend(SVG.Element, {\n    // Bind given event to listener\n    on: function on(event, listener, binding, options) {\n      SVG.on(this, event, listener, binding, options);\n      return this;\n    },\n    // Unbind event from listener\n    off: function off(event, listener) {\n      SVG.off(this.node, event, listener);\n      return this;\n    },\n    fire: function fire(event, data) {\n      // Dispatch event\n      if (event instanceof window.Event) {\n        this.node.dispatchEvent(event);\n      } else {\n        this.node.dispatchEvent(event = new SVG.CustomEvent(event, {\n          detail: data,\n          cancelable: true\n        }));\n      }\n\n      this._event = event;\n      return this;\n    },\n    event: function event() {\n      return this._event;\n    }\n  });\n  SVG.Defs = SVG.invent({\n    // Initialize node\n    create: 'defs' // Inherit from\n    ,\n    inherit: SVG.Container\n  });\n  SVG.G = SVG.invent({\n    // Initialize node\n    create: 'g' // Inherit from\n    ,\n    inherit: SVG.Container // Add class methods\n    ,\n    extend: {\n      // Move over x-axis\n      x: function x(_x3) {\n        return _x3 == null ? this.transform('x') : this.transform({\n          x: _x3 - this.x()\n        }, true);\n      } // Move over y-axis\n      ,\n      y: function y(_y3) {\n        return _y3 == null ? this.transform('y') : this.transform({\n          y: _y3 - this.y()\n        }, true);\n      } // Move by center over x-axis\n      ,\n      cx: function cx(x) {\n        return x == null ? this.gbox().cx : this.x(x - this.gbox().width / 2);\n      } // Move by center over y-axis\n      ,\n      cy: function cy(y) {\n        return y == null ? this.gbox().cy : this.y(y - this.gbox().height / 2);\n      },\n      gbox: function gbox() {\n        var bbox = this.bbox(),\n            trans = this.transform();\n        bbox.x += trans.x;\n        bbox.x2 += trans.x;\n        bbox.cx += trans.x;\n        bbox.y += trans.y;\n        bbox.y2 += trans.y;\n        bbox.cy += trans.y;\n        return bbox;\n      }\n    } // Add parent method\n    ,\n    construct: {\n      // Create a group element\n      group: function group() {\n        return this.put(new SVG.G());\n      }\n    }\n  });\n  SVG.Doc = SVG.invent({\n    // Initialize node\n    create: function create(element) {\n      if (element) {\n        // ensure the presence of a dom element\n        element = typeof element == 'string' ? document.getElementById(element) : element; // If the target is an svg element, use that element as the main wrapper.\n        // This allows svg.js to work with svg documents as well.\n\n        if (element.nodeName == 'svg') {\n          this.constructor.call(this, element);\n        } else {\n          this.constructor.call(this, SVG.create('svg'));\n          element.appendChild(this.node);\n          this.size('100%', '100%');\n        } // set svg element attributes and ensure defs node\n\n\n        this.namespace().defs();\n      }\n    } // Inherit from\n    ,\n    inherit: SVG.Container // Add class methods\n    ,\n    extend: {\n      // Add namespaces\n      namespace: function namespace() {\n        return this.attr({\n          xmlns: SVG.ns,\n          version: '1.1'\n        }).attr('xmlns:xlink', SVG.xlink, SVG.xmlns).attr('xmlns:svgjs', SVG.svgjs, SVG.xmlns);\n      } // Creates and returns defs element\n      ,\n      defs: function defs() {\n        if (!this._defs) {\n          var defs; // Find or create a defs element in this instance\n\n          if (defs = this.node.getElementsByTagName('defs')[0]) this._defs = SVG.adopt(defs);else this._defs = new SVG.Defs(); // Make sure the defs node is at the end of the stack\n\n          this.node.appendChild(this._defs.node);\n        }\n\n        return this._defs;\n      } // custom parent method\n      ,\n      parent: function parent() {\n        if (!this.node.parentNode || this.node.parentNode.nodeName == '#document' || this.node.parentNode.nodeName == '#document-fragment') return null;\n        return this.node.parentNode;\n      } // Fix for possible sub-pixel offset. See:\n      // https://bugzilla.mozilla.org/show_bug.cgi?id=608812\n      ,\n      spof: function spof() {\n        var pos = this.node.getScreenCTM();\n        if (pos) this.style('left', -pos.e % 1 + 'px').style('top', -pos.f % 1 + 'px');\n        return this;\n      } // Removes the doc from the DOM\n      ,\n      remove: function remove() {\n        if (this.parent()) {\n          this.parent().removeChild(this.node);\n        }\n\n        return this;\n      },\n      clear: function clear() {\n        // remove children\n        while (this.node.hasChildNodes()) {\n          this.node.removeChild(this.node.lastChild);\n        } // remove defs reference\n\n\n        delete this._defs; // add back parser\n\n        if (!SVG.parser.draw.parentNode) this.node.appendChild(SVG.parser.draw);\n        return this;\n      },\n      clone: function clone(parent) {\n        // write dom data to the dom so the clone can pickup the data\n        this.writeDataToDom(); // get reference to node\n\n        var node = this.node; // clone element and assign new id\n\n        var clone = assignNewId(node.cloneNode(true)); // insert the clone in the given parent or after myself\n\n        if (parent) {\n          (parent.node || parent).appendChild(clone.node);\n        } else {\n          node.parentNode.insertBefore(clone.node, node.nextSibling);\n        }\n\n        return clone;\n      }\n    }\n  }); // ### This module adds backward / forward functionality to elements.\n  //\n\n  SVG.extend(SVG.Element, {\n    // Get all siblings, including myself\n    siblings: function siblings() {\n      return this.parent().children();\n    } // Get the curent position siblings\n    ,\n    position: function position() {\n      return this.parent().index(this);\n    } // Get the next element (will return null if there is none)\n    ,\n    next: function next() {\n      return this.siblings()[this.position() + 1];\n    } // Get the next element (will return null if there is none)\n    ,\n    previous: function previous() {\n      return this.siblings()[this.position() - 1];\n    } // Send given element one step forward\n    ,\n    forward: function forward() {\n      var i = this.position() + 1,\n          p = this.parent(); // move node one step forward\n\n      p.removeElement(this).add(this, i); // make sure defs node is always at the top\n\n      if (p instanceof SVG.Doc) p.node.appendChild(p.defs().node);\n      return this;\n    } // Send given element one step backward\n    ,\n    backward: function backward() {\n      var i = this.position();\n      if (i > 0) this.parent().removeElement(this).add(this, i - 1);\n      return this;\n    } // Send given element all the way to the front\n    ,\n    front: function front() {\n      var p = this.parent(); // Move node forward\n\n      p.node.appendChild(this.node); // Make sure defs node is always at the top\n\n      if (p instanceof SVG.Doc) p.node.appendChild(p.defs().node);\n      return this;\n    } // Send given element all the way to the back\n    ,\n    back: function back() {\n      if (this.position() > 0) this.parent().removeElement(this).add(this, 0);\n      return this;\n    } // Inserts a given element before the targeted element\n    ,\n    before: function before(element) {\n      element.remove();\n      var i = this.position();\n      this.parent().add(element, i);\n      return this;\n    } // Insters a given element after the targeted element\n    ,\n    after: function after(element) {\n      element.remove();\n      var i = this.position();\n      this.parent().add(element, i + 1);\n      return this;\n    }\n  });\n  SVG.Mask = SVG.invent({\n    // Initialize node\n    create: function create() {\n      this.constructor.call(this, SVG.create('mask')); // keep references to masked elements\n\n      this.targets = [];\n    } // Inherit from\n    ,\n    inherit: SVG.Container // Add class methods\n    ,\n    extend: {\n      // Unmask all masked elements and remove itself\n      remove: function remove() {\n        // unmask all targets\n        for (var i = this.targets.length - 1; i >= 0; i--) {\n          if (this.targets[i]) this.targets[i].unmask();\n        }\n\n        this.targets = []; // remove mask from parent\n\n        SVG.Element.prototype.remove.call(this);\n        return this;\n      }\n    } // Add parent method\n    ,\n    construct: {\n      // Create masking element\n      mask: function mask() {\n        return this.defs().put(new SVG.Mask());\n      }\n    }\n  });\n  SVG.extend(SVG.Element, {\n    // Distribute mask to svg element\n    maskWith: function maskWith(element) {\n      // use given mask or create a new one\n      this.masker = element instanceof SVG.Mask ? element : this.parent().mask().add(element); // store reverence on self in mask\n\n      this.masker.targets.push(this); // apply mask\n\n      return this.attr('mask', 'url(\"#' + this.masker.attr('id') + '\")');\n    } // Unmask element\n    ,\n    unmask: function unmask() {\n      delete this.masker;\n      return this.attr('mask', null);\n    }\n  });\n  SVG.ClipPath = SVG.invent({\n    // Initialize node\n    create: function create() {\n      this.constructor.call(this, SVG.create('clipPath')); // keep references to clipped elements\n\n      this.targets = [];\n    } // Inherit from\n    ,\n    inherit: SVG.Container // Add class methods\n    ,\n    extend: {\n      // Unclip all clipped elements and remove itself\n      remove: function remove() {\n        // unclip all targets\n        for (var i = this.targets.length - 1; i >= 0; i--) {\n          if (this.targets[i]) this.targets[i].unclip();\n        }\n\n        this.targets = []; // remove clipPath from parent\n\n        this.parent().removeElement(this);\n        return this;\n      }\n    } // Add parent method\n    ,\n    construct: {\n      // Create clipping element\n      clip: function clip() {\n        return this.defs().put(new SVG.ClipPath());\n      }\n    }\n  }); //\n\n  SVG.extend(SVG.Element, {\n    // Distribute clipPath to svg element\n    clipWith: function clipWith(element) {\n      // use given clip or create a new one\n      this.clipper = element instanceof SVG.ClipPath ? element : this.parent().clip().add(element); // store reverence on self in mask\n\n      this.clipper.targets.push(this); // apply mask\n\n      return this.attr('clip-path', 'url(\"#' + this.clipper.attr('id') + '\")');\n    } // Unclip element\n    ,\n    unclip: function unclip() {\n      delete this.clipper;\n      return this.attr('clip-path', null);\n    }\n  });\n  SVG.Gradient = SVG.invent({\n    // Initialize node\n    create: function create(type) {\n      this.constructor.call(this, SVG.create(type + 'Gradient')); // store type\n\n      this.type = type;\n    } // Inherit from\n    ,\n    inherit: SVG.Container // Add class methods\n    ,\n    extend: {\n      // Add a color stop\n      at: function at(offset, color, opacity) {\n        return this.put(new SVG.Stop()).update(offset, color, opacity);\n      } // Update gradient\n      ,\n      update: function update(block) {\n        // remove all stops\n        this.clear(); // invoke passed block\n\n        if (typeof block == 'function') block.call(this, this);\n        return this;\n      } // Return the fill id\n      ,\n      fill: function fill() {\n        return 'url(#' + this.id() + ')';\n      } // Alias string convertion to fill\n      ,\n      toString: function toString() {\n        return this.fill();\n      } // custom attr to handle transform\n      ,\n      attr: function attr(a, b, c) {\n        if (a == 'transform') a = 'gradientTransform';\n        return SVG.Container.prototype.attr.call(this, a, b, c);\n      }\n    } // Add parent method\n    ,\n    construct: {\n      // Create gradient element in defs\n      gradient: function gradient(type, block) {\n        return this.defs().gradient(type, block);\n      }\n    }\n  }); // Add animatable methods to both gradient and fx module\n\n  SVG.extend(SVG.Gradient, SVG.FX, {\n    // From position\n    from: function from(x, y) {\n      return (this._target || this).type == 'radial' ? this.attr({\n        fx: new SVG.Number(x),\n        fy: new SVG.Number(y)\n      }) : this.attr({\n        x1: new SVG.Number(x),\n        y1: new SVG.Number(y)\n      });\n    } // To position\n    ,\n    to: function to(x, y) {\n      return (this._target || this).type == 'radial' ? this.attr({\n        cx: new SVG.Number(x),\n        cy: new SVG.Number(y)\n      }) : this.attr({\n        x2: new SVG.Number(x),\n        y2: new SVG.Number(y)\n      });\n    }\n  }); // Base gradient generation\n\n  SVG.extend(SVG.Defs, {\n    // define gradient\n    gradient: function gradient(type, block) {\n      return this.put(new SVG.Gradient(type)).update(block);\n    }\n  });\n  SVG.Stop = SVG.invent({\n    // Initialize node\n    create: 'stop' // Inherit from\n    ,\n    inherit: SVG.Element // Add class methods\n    ,\n    extend: {\n      // add color stops\n      update: function update(o) {\n        if (typeof o == 'number' || o instanceof SVG.Number) {\n          o = {\n            offset: arguments[0],\n            color: arguments[1],\n            opacity: arguments[2]\n          };\n        } // set attributes\n\n\n        if (o.opacity != null) this.attr('stop-opacity', o.opacity);\n        if (o.color != null) this.attr('stop-color', o.color);\n        if (o.offset != null) this.attr('offset', new SVG.Number(o.offset));\n        return this;\n      }\n    }\n  });\n  SVG.Pattern = SVG.invent({\n    // Initialize node\n    create: 'pattern' // Inherit from\n    ,\n    inherit: SVG.Container // Add class methods\n    ,\n    extend: {\n      // Return the fill id\n      fill: function fill() {\n        return 'url(#' + this.id() + ')';\n      } // Update pattern by rebuilding\n      ,\n      update: function update(block) {\n        // remove content\n        this.clear(); // invoke passed block\n\n        if (typeof block == 'function') block.call(this, this);\n        return this;\n      } // Alias string convertion to fill\n      ,\n      toString: function toString() {\n        return this.fill();\n      } // custom attr to handle transform\n      ,\n      attr: function attr(a, b, c) {\n        if (a == 'transform') a = 'patternTransform';\n        return SVG.Container.prototype.attr.call(this, a, b, c);\n      }\n    } // Add parent method\n    ,\n    construct: {\n      // Create pattern element in defs\n      pattern: function pattern(width, height, block) {\n        return this.defs().pattern(width, height, block);\n      }\n    }\n  });\n  SVG.extend(SVG.Defs, {\n    // Define gradient\n    pattern: function pattern(width, height, block) {\n      return this.put(new SVG.Pattern()).update(block).attr({\n        x: 0,\n        y: 0,\n        width: width,\n        height: height,\n        patternUnits: 'userSpaceOnUse'\n      });\n    }\n  });\n  SVG.Shape = SVG.invent({\n    // Initialize node\n    create: function create(element) {\n      this.constructor.call(this, element);\n    } // Inherit from\n    ,\n    inherit: SVG.Element\n  });\n  SVG.Bare = SVG.invent({\n    // Initialize\n    create: function create(element, inherit) {\n      // construct element\n      this.constructor.call(this, SVG.create(element)); // inherit custom methods\n\n      if (inherit) for (var method in inherit.prototype) {\n        if (typeof inherit.prototype[method] === 'function') this[method] = inherit.prototype[method];\n      }\n    } // Inherit from\n    ,\n    inherit: SVG.Element // Add methods\n    ,\n    extend: {\n      // Insert some plain text\n      words: function words(text) {\n        // remove contents\n        while (this.node.hasChildNodes()) {\n          this.node.removeChild(this.node.lastChild);\n        } // create text node\n\n\n        this.node.appendChild(document.createTextNode(text));\n        return this;\n      }\n    }\n  });\n  SVG.extend(SVG.Parent, {\n    // Create an element that is not described by SVG.js\n    element: function element(_element, inherit) {\n      return this.put(new SVG.Bare(_element, inherit));\n    }\n  });\n  SVG.Symbol = SVG.invent({\n    // Initialize node\n    create: 'symbol' // Inherit from\n    ,\n    inherit: SVG.Container,\n    construct: {\n      // create symbol\n      symbol: function symbol() {\n        return this.put(new SVG.Symbol());\n      }\n    }\n  });\n  SVG.Use = SVG.invent({\n    // Initialize node\n    create: 'use' // Inherit from\n    ,\n    inherit: SVG.Shape // Add class methods\n    ,\n    extend: {\n      // Use element as a reference\n      element: function element(_element2, file) {\n        // Set lined element\n        return this.attr('href', (file || '') + '#' + _element2, SVG.xlink);\n      }\n    } // Add parent method\n    ,\n    construct: {\n      // Create a use element\n      use: function use(element, file) {\n        return this.put(new SVG.Use()).element(element, file);\n      }\n    }\n  });\n  SVG.Rect = SVG.invent({\n    // Initialize node\n    create: 'rect' // Inherit from\n    ,\n    inherit: SVG.Shape // Add parent method\n    ,\n    construct: {\n      // Create a rect element\n      rect: function rect(width, height) {\n        return this.put(new SVG.Rect()).size(width, height);\n      }\n    }\n  });\n  SVG.Circle = SVG.invent({\n    // Initialize node\n    create: 'circle' // Inherit from\n    ,\n    inherit: SVG.Shape // Add parent method\n    ,\n    construct: {\n      // Create circle element, based on ellipse\n      circle: function circle(size) {\n        return this.put(new SVG.Circle()).rx(new SVG.Number(size).divide(2)).move(0, 0);\n      }\n    }\n  });\n  SVG.extend(SVG.Circle, SVG.FX, {\n    // Radius x value\n    rx: function rx(_rx) {\n      return this.attr('r', _rx);\n    } // Alias radius x value\n    ,\n    ry: function ry(_ry) {\n      return this.rx(_ry);\n    }\n  });\n  SVG.Ellipse = SVG.invent({\n    // Initialize node\n    create: 'ellipse' // Inherit from\n    ,\n    inherit: SVG.Shape // Add parent method\n    ,\n    construct: {\n      // Create an ellipse\n      ellipse: function ellipse(width, height) {\n        return this.put(new SVG.Ellipse()).size(width, height).move(0, 0);\n      }\n    }\n  });\n  SVG.extend(SVG.Ellipse, SVG.Rect, SVG.FX, {\n    // Radius x value\n    rx: function rx(_rx2) {\n      return this.attr('rx', _rx2);\n    } // Radius y value\n    ,\n    ry: function ry(_ry2) {\n      return this.attr('ry', _ry2);\n    }\n  }); // Add common method\n\n  SVG.extend(SVG.Circle, SVG.Ellipse, {\n    // Move over x-axis\n    x: function x(_x4) {\n      return _x4 == null ? this.cx() - this.rx() : this.cx(_x4 + this.rx());\n    } // Move over y-axis\n    ,\n    y: function y(_y4) {\n      return _y4 == null ? this.cy() - this.ry() : this.cy(_y4 + this.ry());\n    } // Move by center over x-axis\n    ,\n    cx: function cx(x) {\n      return x == null ? this.attr('cx') : this.attr('cx', x);\n    } // Move by center over y-axis\n    ,\n    cy: function cy(y) {\n      return y == null ? this.attr('cy') : this.attr('cy', y);\n    } // Set width of element\n    ,\n    width: function width(_width3) {\n      return _width3 == null ? this.rx() * 2 : this.rx(new SVG.Number(_width3).divide(2));\n    } // Set height of element\n    ,\n    height: function height(_height3) {\n      return _height3 == null ? this.ry() * 2 : this.ry(new SVG.Number(_height3).divide(2));\n    } // Custom size function\n    ,\n    size: function size(width, height) {\n      var p = proportionalSize(this, width, height);\n      return this.rx(new SVG.Number(p.width).divide(2)).ry(new SVG.Number(p.height).divide(2));\n    }\n  });\n  SVG.Line = SVG.invent({\n    // Initialize node\n    create: 'line' // Inherit from\n    ,\n    inherit: SVG.Shape // Add class methods\n    ,\n    extend: {\n      // Get array\n      array: function array() {\n        return new SVG.PointArray([[this.attr('x1'), this.attr('y1')], [this.attr('x2'), this.attr('y2')]]);\n      } // Overwrite native plot() method\n      ,\n      plot: function plot(x1, y1, x2, y2) {\n        if (x1 == null) return this.array();else if (typeof y1 !== 'undefined') x1 = {\n          x1: x1,\n          y1: y1,\n          x2: x2,\n          y2: y2\n        };else x1 = new SVG.PointArray(x1).toLine();\n        return this.attr(x1);\n      } // Move by left top corner\n      ,\n      move: function move(x, y) {\n        return this.attr(this.array().move(x, y).toLine());\n      } // Set element size to given width and height\n      ,\n      size: function size(width, height) {\n        var p = proportionalSize(this, width, height);\n        return this.attr(this.array().size(p.width, p.height).toLine());\n      }\n    } // Add parent method\n    ,\n    construct: {\n      // Create a line element\n      line: function line(x1, y1, x2, y2) {\n        // make sure plot is called as a setter\n        // x1 is not necessarily a number, it can also be an array, a string and a SVG.PointArray\n        return SVG.Line.prototype.plot.apply(this.put(new SVG.Line()), x1 != null ? [x1, y1, x2, y2] : [0, 0, 0, 0]);\n      }\n    }\n  });\n  SVG.Polyline = SVG.invent({\n    // Initialize node\n    create: 'polyline' // Inherit from\n    ,\n    inherit: SVG.Shape // Add parent method\n    ,\n    construct: {\n      // Create a wrapped polyline element\n      polyline: function polyline(p) {\n        // make sure plot is called as a setter\n        return this.put(new SVG.Polyline()).plot(p || new SVG.PointArray());\n      }\n    }\n  });\n  SVG.Polygon = SVG.invent({\n    // Initialize node\n    create: 'polygon' // Inherit from\n    ,\n    inherit: SVG.Shape // Add parent method\n    ,\n    construct: {\n      // Create a wrapped polygon element\n      polygon: function polygon(p) {\n        // make sure plot is called as a setter\n        return this.put(new SVG.Polygon()).plot(p || new SVG.PointArray());\n      }\n    }\n  }); // Add polygon-specific functions\n\n  SVG.extend(SVG.Polyline, SVG.Polygon, {\n    // Get array\n    array: function array() {\n      return this._array || (this._array = new SVG.PointArray(this.attr('points')));\n    } // Plot new path\n    ,\n    plot: function plot(p) {\n      return p == null ? this.array() : this.clear().attr('points', typeof p == 'string' ? p : this._array = new SVG.PointArray(p));\n    } // Clear array cache\n    ,\n    clear: function clear() {\n      delete this._array;\n      return this;\n    } // Move by left top corner\n    ,\n    move: function move(x, y) {\n      return this.attr('points', this.array().move(x, y));\n    } // Set element size to given width and height\n    ,\n    size: function size(width, height) {\n      var p = proportionalSize(this, width, height);\n      return this.attr('points', this.array().size(p.width, p.height));\n    }\n  }); // unify all point to point elements\n\n  SVG.extend(SVG.Line, SVG.Polyline, SVG.Polygon, {\n    // Define morphable array\n    morphArray: SVG.PointArray // Move by left top corner over x-axis\n    ,\n    x: function x(_x5) {\n      return _x5 == null ? this.bbox().x : this.move(_x5, this.bbox().y);\n    } // Move by left top corner over y-axis\n    ,\n    y: function y(_y5) {\n      return _y5 == null ? this.bbox().y : this.move(this.bbox().x, _y5);\n    } // Set width of element\n    ,\n    width: function width(_width4) {\n      var b = this.bbox();\n      return _width4 == null ? b.width : this.size(_width4, b.height);\n    } // Set height of element\n    ,\n    height: function height(_height4) {\n      var b = this.bbox();\n      return _height4 == null ? b.height : this.size(b.width, _height4);\n    }\n  });\n  SVG.Path = SVG.invent({\n    // Initialize node\n    create: 'path' // Inherit from\n    ,\n    inherit: SVG.Shape // Add class methods\n    ,\n    extend: {\n      // Define morphable array\n      morphArray: SVG.PathArray // Get array\n      ,\n      array: function array() {\n        return this._array || (this._array = new SVG.PathArray(this.attr('d')));\n      } // Plot new path\n      ,\n      plot: function plot(d) {\n        return d == null ? this.array() : this.clear().attr('d', typeof d == 'string' ? d : this._array = new SVG.PathArray(d));\n      } // Clear array cache\n      ,\n      clear: function clear() {\n        delete this._array;\n        return this;\n      } // Move by left top corner\n      ,\n      move: function move(x, y) {\n        return this.attr('d', this.array().move(x, y));\n      } // Move by left top corner over x-axis\n      ,\n      x: function x(_x6) {\n        return _x6 == null ? this.bbox().x : this.move(_x6, this.bbox().y);\n      } // Move by left top corner over y-axis\n      ,\n      y: function y(_y6) {\n        return _y6 == null ? this.bbox().y : this.move(this.bbox().x, _y6);\n      } // Set element size to given width and height\n      ,\n      size: function size(width, height) {\n        var p = proportionalSize(this, width, height);\n        return this.attr('d', this.array().size(p.width, p.height));\n      } // Set width of element\n      ,\n      width: function width(_width5) {\n        return _width5 == null ? this.bbox().width : this.size(_width5, this.bbox().height);\n      } // Set height of element\n      ,\n      height: function height(_height5) {\n        return _height5 == null ? this.bbox().height : this.size(this.bbox().width, _height5);\n      }\n    } // Add parent method\n    ,\n    construct: {\n      // Create a wrapped path element\n      path: function path(d) {\n        // make sure plot is called as a setter\n        return this.put(new SVG.Path()).plot(d || new SVG.PathArray());\n      }\n    }\n  });\n  SVG.Image = SVG.invent({\n    // Initialize node\n    create: 'image' // Inherit from\n    ,\n    inherit: SVG.Shape // Add class methods\n    ,\n    extend: {\n      // (re)load image\n      load: function load(url) {\n        if (!url) return this;\n        var self = this,\n            img = new window.Image(); // preload image\n\n        SVG.on(img, 'load', function () {\n          SVG.off(img);\n          var p = self.parent(SVG.Pattern);\n          if (p === null) return; // ensure image size\n\n          if (self.width() == 0 && self.height() == 0) self.size(img.width, img.height); // ensure pattern size if not set\n\n          if (p && p.width() == 0 && p.height() == 0) p.size(self.width(), self.height()); // callback\n\n          if (typeof self._loaded === 'function') self._loaded.call(self, {\n            width: img.width,\n            height: img.height,\n            ratio: img.width / img.height,\n            url: url\n          });\n        });\n        SVG.on(img, 'error', function (e) {\n          SVG.off(img);\n\n          if (typeof self._error === 'function') {\n            self._error.call(self, e);\n          }\n        });\n        return this.attr('href', img.src = this.src = url, SVG.xlink);\n      } // Add loaded callback\n      ,\n      loaded: function loaded(_loaded) {\n        this._loaded = _loaded;\n        return this;\n      },\n      error: function error(_error) {\n        this._error = _error;\n        return this;\n      }\n    } // Add parent method\n    ,\n    construct: {\n      // create image element, load image and set its size\n      image: function image(source, width, height) {\n        return this.put(new SVG.Image()).load(source).size(width || 0, height || width || 0);\n      }\n    }\n  });\n  SVG.Text = SVG.invent({\n    // Initialize node\n    create: function create() {\n      this.constructor.call(this, SVG.create('text'));\n      this.dom.leading = new SVG.Number(1.3); // store leading value for rebuilding\n\n      this._rebuild = true; // enable automatic updating of dy values\n\n      this._build = false; // disable build mode for adding multiple lines\n      // set default font\n\n      this.attr('font-family', SVG.defaults.attrs['font-family']);\n    } // Inherit from\n    ,\n    inherit: SVG.Shape // Add class methods\n    ,\n    extend: {\n      // Move over x-axis\n      x: function x(_x7) {\n        // act as getter\n        if (_x7 == null) return this.attr('x');\n        return this.attr('x', _x7);\n      } // Move over y-axis\n      ,\n      y: function y(_y7) {\n        var oy = this.attr('y'),\n            o = typeof oy === 'number' ? oy - this.bbox().y : 0; // act as getter\n\n        if (_y7 == null) return typeof oy === 'number' ? oy - o : oy;\n        return this.attr('y', typeof _y7.valueOf() === 'number' ? _y7 + o : _y7);\n      } // Move center over x-axis\n      ,\n      cx: function cx(x) {\n        return x == null ? this.bbox().cx : this.x(x - this.bbox().width / 2);\n      } // Move center over y-axis\n      ,\n      cy: function cy(y) {\n        return y == null ? this.bbox().cy : this.y(y - this.bbox().height / 2);\n      } // Set the text content\n      ,\n      text: function text(_text) {\n        // act as getter\n        if (typeof _text === 'undefined') {\n          var _text = '';\n          var children = this.node.childNodes;\n\n          for (var i = 0, len = children.length; i < len; ++i) {\n            // add newline if its not the first child and newLined is set to true\n            if (i != 0 && children[i].nodeType != 3 && SVG.adopt(children[i]).dom.newLined == true) {\n              _text += '\\n';\n            } // add content of this node\n\n\n            _text += children[i].textContent;\n          }\n\n          return _text;\n        } // remove existing content\n\n\n        this.clear().build(true);\n\n        if (typeof _text === 'function') {\n          // call block\n          _text.call(this, this);\n        } else {\n          // store text and make sure text is not blank\n          _text = _text.split('\\n'); // build new lines\n\n          for (var i = 0, il = _text.length; i < il; i++) {\n            this.tspan(_text[i]).newLine();\n          }\n        } // disable build mode and rebuild lines\n\n\n        return this.build(false).rebuild();\n      } // Set font size\n      ,\n      size: function size(_size) {\n        return this.attr('font-size', _size).rebuild();\n      } // Set / get leading\n      ,\n      leading: function leading(value) {\n        // act as getter\n        if (value == null) return this.dom.leading; // act as setter\n\n        this.dom.leading = new SVG.Number(value);\n        return this.rebuild();\n      } // Get all the first level lines\n      ,\n      lines: function lines() {\n        var node = (this.textPath && this.textPath() || this).node; // filter tspans and map them to SVG.js instances\n\n        var lines = SVG.utils.map(SVG.utils.filterSVGElements(node.childNodes), function (el) {\n          return SVG.adopt(el);\n        }); // return an instance of SVG.set\n\n        return new SVG.Set(lines);\n      } // Rebuild appearance type\n      ,\n      rebuild: function rebuild(_rebuild) {\n        // store new rebuild flag if given\n        if (typeof _rebuild == 'boolean') this._rebuild = _rebuild; // define position of all lines\n\n        if (this._rebuild) {\n          var self = this,\n              blankLineOffset = 0,\n              dy = this.dom.leading * new SVG.Number(this.attr('font-size'));\n          this.lines().each(function () {\n            if (this.dom.newLined) {\n              if (!self.textPath()) this.attr('x', self.attr('x'));\n\n              if (this.text() == '\\n') {\n                blankLineOffset += dy;\n              } else {\n                this.attr('dy', dy + blankLineOffset);\n                blankLineOffset = 0;\n              }\n            }\n          });\n          this.fire('rebuild');\n        }\n\n        return this;\n      } // Enable / disable build mode\n      ,\n      build: function build(_build) {\n        this._build = !!_build;\n        return this;\n      } // overwrite method from parent to set data properly\n      ,\n      setData: function setData(o) {\n        this.dom = o;\n        this.dom.leading = new SVG.Number(o.leading || 1.3);\n        return this;\n      }\n    } // Add parent method\n    ,\n    construct: {\n      // Create text element\n      text: function text(_text2) {\n        return this.put(new SVG.Text()).text(_text2);\n      } // Create plain text element\n      ,\n      plain: function plain(text) {\n        return this.put(new SVG.Text()).plain(text);\n      }\n    }\n  });\n  SVG.Tspan = SVG.invent({\n    // Initialize node\n    create: 'tspan' // Inherit from\n    ,\n    inherit: SVG.Shape // Add class methods\n    ,\n    extend: {\n      // Set text content\n      text: function text(_text3) {\n        if (_text3 == null) return this.node.textContent + (this.dom.newLined ? '\\n' : '');\n        typeof _text3 === 'function' ? _text3.call(this, this) : this.plain(_text3);\n        return this;\n      } // Shortcut dx\n      ,\n      dx: function dx(_dx) {\n        return this.attr('dx', _dx);\n      } // Shortcut dy\n      ,\n      dy: function dy(_dy) {\n        return this.attr('dy', _dy);\n      } // Create new line\n      ,\n      newLine: function newLine() {\n        // fetch text parent\n        var t = this.parent(SVG.Text); // mark new line\n\n        this.dom.newLined = true; // apply new hy¡n\n\n        return this.dy(t.dom.leading * t.attr('font-size')).attr('x', t.x());\n      }\n    }\n  });\n  SVG.extend(SVG.Text, SVG.Tspan, {\n    // Create plain text node\n    plain: function plain(text) {\n      // clear if build mode is disabled\n      if (this._build === false) this.clear(); // create text node\n\n      this.node.appendChild(document.createTextNode(text));\n      return this;\n    } // Create a tspan\n    ,\n    tspan: function tspan(text) {\n      var node = (this.textPath && this.textPath() || this).node,\n          tspan = new SVG.Tspan(); // clear if build mode is disabled\n\n      if (this._build === false) this.clear(); // add new tspan\n\n      node.appendChild(tspan.node);\n      return tspan.text(text);\n    } // Clear all lines\n    ,\n    clear: function clear() {\n      var node = (this.textPath && this.textPath() || this).node; // remove existing child nodes\n\n      while (node.hasChildNodes()) {\n        node.removeChild(node.lastChild);\n      }\n\n      return this;\n    } // Get length of text element\n    ,\n    length: function length() {\n      return this.node.getComputedTextLength();\n    }\n  });\n  SVG.TextPath = SVG.invent({\n    // Initialize node\n    create: 'textPath' // Inherit from\n    ,\n    inherit: SVG.Parent // Define parent class\n    ,\n    parent: SVG.Text // Add parent method\n    ,\n    construct: {\n      morphArray: SVG.PathArray // Create path for text to run on\n      ,\n      path: function path(d) {\n        // create textPath element\n        var path = new SVG.TextPath(),\n            track = this.doc().defs().path(d); // move lines to textpath\n\n        while (this.node.hasChildNodes()) {\n          path.node.appendChild(this.node.firstChild);\n        } // add textPath element as child node\n\n\n        this.node.appendChild(path.node); // link textPath to path and add content\n\n        path.attr('href', '#' + track, SVG.xlink);\n        return this;\n      } // return the array of the path track element\n      ,\n      array: function array() {\n        var track = this.track();\n        return track ? track.array() : null;\n      } // Plot path if any\n      ,\n      plot: function plot(d) {\n        var track = this.track(),\n            pathArray = null;\n\n        if (track) {\n          pathArray = track.plot(d);\n        }\n\n        return d == null ? pathArray : this;\n      } // Get the path track element\n      ,\n      track: function track() {\n        var path = this.textPath();\n        if (path) return path.reference('href');\n      } // Get the textPath child\n      ,\n      textPath: function textPath() {\n        if (this.node.firstChild && this.node.firstChild.nodeName == 'textPath') return SVG.adopt(this.node.firstChild);\n      }\n    }\n  });\n  SVG.Nested = SVG.invent({\n    // Initialize node\n    create: function create() {\n      this.constructor.call(this, SVG.create('svg'));\n      this.style('overflow', 'visible');\n    } // Inherit from\n    ,\n    inherit: SVG.Container // Add parent method\n    ,\n    construct: {\n      // Create nested svg document\n      nested: function nested() {\n        return this.put(new SVG.Nested());\n      }\n    }\n  });\n  SVG.A = SVG.invent({\n    // Initialize node\n    create: 'a' // Inherit from\n    ,\n    inherit: SVG.Container // Add class methods\n    ,\n    extend: {\n      // Link url\n      to: function to(url) {\n        return this.attr('href', url, SVG.xlink);\n      } // Link show attribute\n      ,\n      show: function show(target) {\n        return this.attr('show', target, SVG.xlink);\n      } // Link target attribute\n      ,\n      target: function target(_target2) {\n        return this.attr('target', _target2);\n      }\n    } // Add parent method\n    ,\n    construct: {\n      // Create a hyperlink element\n      link: function link(url) {\n        return this.put(new SVG.A()).to(url);\n      }\n    }\n  });\n  SVG.extend(SVG.Element, {\n    // Create a hyperlink element\n    linkTo: function linkTo(url) {\n      var link = new SVG.A();\n      if (typeof url == 'function') url.call(link, link);else link.to(url);\n      return this.parent().put(link).put(this);\n    }\n  });\n  SVG.Marker = SVG.invent({\n    // Initialize node\n    create: 'marker' // Inherit from\n    ,\n    inherit: SVG.Container // Add class methods\n    ,\n    extend: {\n      // Set width of element\n      width: function width(_width6) {\n        return this.attr('markerWidth', _width6);\n      } // Set height of element\n      ,\n      height: function height(_height6) {\n        return this.attr('markerHeight', _height6);\n      } // Set marker refX and refY\n      ,\n      ref: function ref(x, y) {\n        return this.attr('refX', x).attr('refY', y);\n      } // Update marker\n      ,\n      update: function update(block) {\n        // remove all content\n        this.clear(); // invoke passed block\n\n        if (typeof block == 'function') block.call(this, this);\n        return this;\n      } // Return the fill id\n      ,\n      toString: function toString() {\n        return 'url(#' + this.id() + ')';\n      }\n    } // Add parent method\n    ,\n    construct: {\n      marker: function marker(width, height, block) {\n        // Create marker element in defs\n        return this.defs().marker(width, height, block);\n      }\n    }\n  });\n  SVG.extend(SVG.Defs, {\n    // Create marker\n    marker: function marker(width, height, block) {\n      // Set default viewbox to match the width and height, set ref to cx and cy and set orient to auto\n      return this.put(new SVG.Marker()).size(width, height).ref(width / 2, height / 2).viewbox(0, 0, width, height).attr('orient', 'auto').update(block);\n    }\n  });\n  SVG.extend(SVG.Line, SVG.Polyline, SVG.Polygon, SVG.Path, {\n    // Create and attach markers\n    marker: function marker(_marker, width, height, block) {\n      var attr = ['marker']; // Build attribute name\n\n      if (_marker != 'all') attr.push(_marker);\n      attr = attr.join('-'); // Set marker attribute\n\n      _marker = arguments[1] instanceof SVG.Marker ? arguments[1] : this.doc().marker(width, height, block);\n      return this.attr(attr, _marker);\n    }\n  }); // Define list of available attributes for stroke and fill\n\n  var sugar = {\n    stroke: ['color', 'width', 'opacity', 'linecap', 'linejoin', 'miterlimit', 'dasharray', 'dashoffset'],\n    fill: ['color', 'opacity', 'rule'],\n    prefix: function prefix(t, a) {\n      return a == 'color' ? t : t + '-' + a;\n    }\n  } // Add sugar for fill and stroke\n  ;\n  ['fill', 'stroke'].forEach(function (m) {\n    var i,\n        extension = {};\n\n    extension[m] = function (o) {\n      if (typeof o == 'undefined') return this;\n      if (typeof o == 'string' || SVG.Color.isRgb(o) || o && typeof o.fill === 'function') this.attr(m, o);else // set all attributes from sugar.fill and sugar.stroke list\n        for (i = sugar[m].length - 1; i >= 0; i--) {\n          if (o[sugar[m][i]] != null) this.attr(sugar.prefix(m, sugar[m][i]), o[sugar[m][i]]);\n        }\n      return this;\n    };\n\n    SVG.extend(SVG.Element, SVG.FX, extension);\n  });\n  SVG.extend(SVG.Element, SVG.FX, {\n    // Map rotation to transform\n    rotate: function rotate(d, cx, cy) {\n      return this.transform({\n        rotation: d,\n        cx: cx,\n        cy: cy\n      });\n    } // Map skew to transform\n    ,\n    skew: function skew(x, y, cx, cy) {\n      return arguments.length == 1 || arguments.length == 3 ? this.transform({\n        skew: x,\n        cx: y,\n        cy: cx\n      }) : this.transform({\n        skewX: x,\n        skewY: y,\n        cx: cx,\n        cy: cy\n      });\n    } // Map scale to transform\n    ,\n    scale: function scale(x, y, cx, cy) {\n      return arguments.length == 1 || arguments.length == 3 ? this.transform({\n        scale: x,\n        cx: y,\n        cy: cx\n      }) : this.transform({\n        scaleX: x,\n        scaleY: y,\n        cx: cx,\n        cy: cy\n      });\n    } // Map translate to transform\n    ,\n    translate: function translate(x, y) {\n      return this.transform({\n        x: x,\n        y: y\n      });\n    } // Map flip to transform\n    ,\n    flip: function flip(a, o) {\n      o = typeof a == 'number' ? a : o;\n      return this.transform({\n        flip: a || 'both',\n        offset: o\n      });\n    } // Map matrix to transform\n    ,\n    matrix: function matrix(m) {\n      return this.attr('transform', new SVG.Matrix(arguments.length == 6 ? [].slice.call(arguments) : m));\n    } // Opacity\n    ,\n    opacity: function opacity(value) {\n      return this.attr('opacity', value);\n    } // Relative move over x axis\n    ,\n    dx: function dx(x) {\n      return this.x(new SVG.Number(x).plus(this instanceof SVG.FX ? 0 : this.x()), true);\n    } // Relative move over y axis\n    ,\n    dy: function dy(y) {\n      return this.y(new SVG.Number(y).plus(this instanceof SVG.FX ? 0 : this.y()), true);\n    } // Relative move over x and y axes\n    ,\n    dmove: function dmove(x, y) {\n      return this.dx(x).dy(y);\n    }\n  });\n  SVG.extend(SVG.Rect, SVG.Ellipse, SVG.Circle, SVG.Gradient, SVG.FX, {\n    // Add x and y radius\n    radius: function radius(x, y) {\n      var type = (this._target || this).type;\n      return type == 'radial' || type == 'circle' ? this.attr('r', new SVG.Number(x)) : this.rx(x).ry(y == null ? x : y);\n    }\n  });\n  SVG.extend(SVG.Path, {\n    // Get path length\n    length: function length() {\n      return this.node.getTotalLength();\n    } // Get point at length\n    ,\n    pointAt: function pointAt(length) {\n      return this.node.getPointAtLength(length);\n    }\n  });\n  SVG.extend(SVG.Parent, SVG.Text, SVG.Tspan, SVG.FX, {\n    // Set font\n    font: function font(a, v) {\n      if (_typeof(a) == 'object') {\n        for (v in a) {\n          this.font(v, a[v]);\n        }\n      }\n\n      return a == 'leading' ? this.leading(v) : a == 'anchor' ? this.attr('text-anchor', v) : a == 'size' || a == 'family' || a == 'weight' || a == 'stretch' || a == 'variant' || a == 'style' ? this.attr('font-' + a, v) : this.attr(a, v);\n    }\n  });\n  SVG.Set = SVG.invent({\n    // Initialize\n    create: function create(members) {\n      if (members instanceof SVG.Set) {\n        this.members = members.members.slice();\n      } else {\n        Array.isArray(members) ? this.members = members : this.clear();\n      }\n    } // Add class methods\n    ,\n    extend: {\n      // Add element to set\n      add: function add() {\n        var i,\n            il,\n            elements = [].slice.call(arguments);\n\n        for (i = 0, il = elements.length; i < il; i++) {\n          this.members.push(elements[i]);\n        }\n\n        return this;\n      } // Remove element from set\n      ,\n      remove: function remove(element) {\n        var i = this.index(element); // remove given child\n\n        if (i > -1) this.members.splice(i, 1);\n        return this;\n      } // Iterate over all members\n      ,\n      each: function each(block) {\n        for (var i = 0, il = this.members.length; i < il; i++) {\n          block.apply(this.members[i], [i, this.members]);\n        }\n\n        return this;\n      } // Restore to defaults\n      ,\n      clear: function clear() {\n        // initialize store\n        this.members = [];\n        return this;\n      } // Get the length of a set\n      ,\n      length: function length() {\n        return this.members.length;\n      } // Checks if a given element is present in set\n      ,\n      has: function has(element) {\n        return this.index(element) >= 0;\n      } // retuns index of given element in set\n      ,\n      index: function index(element) {\n        return this.members.indexOf(element);\n      } // Get member at given index\n      ,\n      get: function get(i) {\n        return this.members[i];\n      } // Get first member\n      ,\n      first: function first() {\n        return this.get(0);\n      } // Get last member\n      ,\n      last: function last() {\n        return this.get(this.members.length - 1);\n      } // Default value\n      ,\n      valueOf: function valueOf() {\n        return this.members;\n      } // Get the bounding box of all members included or empty box if set has no items\n      ,\n      bbox: function bbox() {\n        // return an empty box of there are no members\n        if (this.members.length == 0) return new SVG.RBox(); // get the first rbox and update the target bbox\n\n        var rbox = this.members[0].rbox(this.members[0].doc());\n        this.each(function () {\n          // user rbox for correct position and visual representation\n          rbox = rbox.merge(this.rbox(this.doc()));\n        });\n        return rbox;\n      }\n    } // Add parent method\n    ,\n    construct: {\n      // Create a new set\n      set: function set(members) {\n        return new SVG.Set(members);\n      }\n    }\n  });\n  SVG.FX.Set = SVG.invent({\n    // Initialize node\n    create: function create(set) {\n      // store reference to set\n      this.set = set;\n    }\n  }); // Alias methods\n\n  SVG.Set.inherit = function () {\n    var m,\n        methods = []; // gather shape methods\n\n    for (var m in SVG.Shape.prototype) {\n      if (typeof SVG.Shape.prototype[m] == 'function' && typeof SVG.Set.prototype[m] != 'function') methods.push(m);\n    } // apply shape aliasses\n\n\n    methods.forEach(function (method) {\n      SVG.Set.prototype[method] = function () {\n        for (var i = 0, il = this.members.length; i < il; i++) {\n          if (this.members[i] && typeof this.members[i][method] == 'function') this.members[i][method].apply(this.members[i], arguments);\n        }\n\n        return method == 'animate' ? this.fx || (this.fx = new SVG.FX.Set(this)) : this;\n      };\n    }); // clear methods for the next round\n\n    methods = []; // gather fx methods\n\n    for (var m in SVG.FX.prototype) {\n      if (typeof SVG.FX.prototype[m] == 'function' && typeof SVG.FX.Set.prototype[m] != 'function') methods.push(m);\n    } // apply fx aliasses\n\n\n    methods.forEach(function (method) {\n      SVG.FX.Set.prototype[method] = function () {\n        for (var i = 0, il = this.set.members.length; i < il; i++) {\n          this.set.members[i].fx[method].apply(this.set.members[i].fx, arguments);\n        }\n\n        return this;\n      };\n    });\n  };\n\n  SVG.extend(SVG.Element, {\n    // Store data values on svg nodes\n    data: function data(a, v, r) {\n      if (_typeof(a) == 'object') {\n        for (v in a) {\n          this.data(v, a[v]);\n        }\n      } else if (arguments.length < 2) {\n        try {\n          return JSON.parse(this.attr('data-' + a));\n        } catch (e) {\n          return this.attr('data-' + a);\n        }\n      } else {\n        this.attr('data-' + a, v === null ? null : r === true || typeof v === 'string' || typeof v === 'number' ? v : JSON.stringify(v));\n      }\n\n      return this;\n    }\n  });\n  SVG.extend(SVG.Element, {\n    // Remember arbitrary data\n    remember: function remember(k, v) {\n      // remember every item in an object individually\n      if (_typeof(arguments[0]) == 'object') for (var v in k) {\n        this.remember(v, k[v]);\n      } // retrieve memory\n      else if (arguments.length == 1) return this.memory()[k]; // store memory\n        else this.memory()[k] = v;\n      return this;\n    } // Erase a given memory\n    ,\n    forget: function forget() {\n      if (arguments.length == 0) this._memory = {};else for (var i = arguments.length - 1; i >= 0; i--) {\n        delete this.memory()[arguments[i]];\n      }\n      return this;\n    } // Initialize or return local memory object\n    ,\n    memory: function memory() {\n      return this._memory || (this._memory = {});\n    }\n  }); // Method for getting an element by id\n\n  SVG.get = function (id) {\n    var node = document.getElementById(idFromReference(id) || id);\n    return SVG.adopt(node);\n  }; // Select elements by query string\n\n\n  SVG.select = function (query, parent) {\n    return new SVG.Set(SVG.utils.map((parent || document).querySelectorAll(query), function (node) {\n      return SVG.adopt(node);\n    }));\n  };\n\n  SVG.extend(SVG.Parent, {\n    // Scoped select method\n    select: function select(query) {\n      return SVG.select(query, this.node);\n    }\n  });\n\n  function pathRegReplace(a, b, c, d) {\n    return c + d.replace(SVG.regex.dots, ' .');\n  } // creates deep clone of array\n\n\n  function array_clone(arr) {\n    var clone = arr.slice(0);\n\n    for (var i = clone.length; i--;) {\n      if (Array.isArray(clone[i])) {\n        clone[i] = array_clone(clone[i]);\n      }\n    }\n\n    return clone;\n  } // tests if a given element is instance of an object\n\n\n  function _is(el, obj) {\n    return el instanceof obj;\n  } // tests if a given selector matches an element\n\n\n  function _matches(el, selector) {\n    return (el.matches || el.matchesSelector || el.msMatchesSelector || el.mozMatchesSelector || el.webkitMatchesSelector || el.oMatchesSelector).call(el, selector);\n  } // Convert dash-separated-string to camelCase\n\n\n  function camelCase(s) {\n    return s.toLowerCase().replace(/-(.)/g, function (m, g) {\n      return g.toUpperCase();\n    });\n  } // Capitalize first letter of a string\n\n\n  function capitalize(s) {\n    return s.charAt(0).toUpperCase() + s.slice(1);\n  } // Ensure to six-based hex\n\n\n  function fullHex(hex) {\n    return hex.length == 4 ? ['#', hex.substring(1, 2), hex.substring(1, 2), hex.substring(2, 3), hex.substring(2, 3), hex.substring(3, 4), hex.substring(3, 4)].join('') : hex;\n  } // Component to hex value\n\n\n  function compToHex(comp) {\n    var hex = comp.toString(16);\n    return hex.length == 1 ? '0' + hex : hex;\n  } // Calculate proportional width and height values when necessary\n\n\n  function proportionalSize(element, width, height) {\n    if (width == null || height == null) {\n      var box = element.bbox();\n      if (width == null) width = box.width / box.height * height;else if (height == null) height = box.height / box.width * width;\n    }\n\n    return {\n      width: width,\n      height: height\n    };\n  } // Delta transform point\n\n\n  function deltaTransformPoint(matrix, x, y) {\n    return {\n      x: x * matrix.a + y * matrix.c + 0,\n      y: x * matrix.b + y * matrix.d + 0\n    };\n  } // Map matrix array to object\n\n\n  function arrayToMatrix(a) {\n    return {\n      a: a[0],\n      b: a[1],\n      c: a[2],\n      d: a[3],\n      e: a[4],\n      f: a[5]\n    };\n  } // Parse matrix if required\n\n\n  function parseMatrix(matrix) {\n    if (!(matrix instanceof SVG.Matrix)) matrix = new SVG.Matrix(matrix);\n    return matrix;\n  } // Add centre point to transform object\n\n\n  function ensureCentre(o, target) {\n    o.cx = o.cx == null ? target.bbox().cx : o.cx;\n    o.cy = o.cy == null ? target.bbox().cy : o.cy;\n  } // PathArray Helpers\n\n\n  function arrayToString(a) {\n    for (var i = 0, il = a.length, s = ''; i < il; i++) {\n      s += a[i][0];\n\n      if (a[i][1] != null) {\n        s += a[i][1];\n\n        if (a[i][2] != null) {\n          s += ' ';\n          s += a[i][2];\n\n          if (a[i][3] != null) {\n            s += ' ';\n            s += a[i][3];\n            s += ' ';\n            s += a[i][4];\n\n            if (a[i][5] != null) {\n              s += ' ';\n              s += a[i][5];\n              s += ' ';\n              s += a[i][6];\n\n              if (a[i][7] != null) {\n                s += ' ';\n                s += a[i][7];\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return s + ' ';\n  } // Deep new id assignment\n\n\n  function assignNewId(node) {\n    // do the same for SVG child nodes as well\n    for (var i = node.childNodes.length - 1; i >= 0; i--) {\n      if (node.childNodes[i] instanceof window.SVGElement) assignNewId(node.childNodes[i]);\n    }\n\n    return SVG.adopt(node).id(SVG.eid(node.nodeName));\n  } // Add more bounding box properties\n\n\n  function fullBox(b) {\n    if (b.x == null) {\n      b.x = 0;\n      b.y = 0;\n      b.width = 0;\n      b.height = 0;\n    }\n\n    b.w = b.width;\n    b.h = b.height;\n    b.x2 = b.x + b.width;\n    b.y2 = b.y + b.height;\n    b.cx = b.x + b.width / 2;\n    b.cy = b.y + b.height / 2;\n    return b;\n  } // Get id from reference string\n\n\n  function idFromReference(url) {\n    var m = (url || '').toString().match(SVG.regex.reference);\n    if (m) return m[1];\n  } // If values like 1e-88 are passed, this is not a valid 32 bit float,\n  // but in those cases, we are so close to 0 that 0 works well!\n\n\n  function float32String(v) {\n    return Math.abs(v) > 1e-37 ? v : 0;\n  } // Create matrix array for looping\n\n\n  var abcdef = 'abcdef'.split(''); // Add CustomEvent to IE9 and IE10\n\n  if (typeof window.CustomEvent !== 'function') {\n    // Code from: https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent\n    var CustomEventPoly = function CustomEventPoly(event, options) {\n      options = options || {\n        bubbles: false,\n        cancelable: false,\n        detail: undefined\n      };\n      var e = document.createEvent('CustomEvent');\n      e.initCustomEvent(event, options.bubbles, options.cancelable, options.detail);\n      return e;\n    };\n\n    CustomEventPoly.prototype = window.Event.prototype;\n    SVG.CustomEvent = CustomEventPoly;\n  } else {\n    SVG.CustomEvent = window.CustomEvent;\n  } // requestAnimationFrame / cancelAnimationFrame Polyfill with fallback based on Paul Irish\n\n\n  (function (w) {\n    var lastTime = 0;\n    var vendors = ['moz', 'webkit'];\n\n    for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {\n      w.requestAnimationFrame = w[vendors[x] + 'RequestAnimationFrame'];\n      w.cancelAnimationFrame = w[vendors[x] + 'CancelAnimationFrame'] || w[vendors[x] + 'CancelRequestAnimationFrame'];\n    }\n\n    w.requestAnimationFrame = w.requestAnimationFrame || function (callback) {\n      var currTime = new Date().getTime();\n      var timeToCall = Math.max(0, 16 - (currTime - lastTime));\n      var id = w.setTimeout(function () {\n        callback(currTime + timeToCall);\n      }, timeToCall);\n      lastTime = currTime + timeToCall;\n      return id;\n    };\n\n    w.cancelAnimationFrame = w.cancelAnimationFrame || w.clearTimeout;\n  })(window);\n\n  return SVG;\n});\n\n//# sourceURL=webpack:///./js/vendor/svg.js?")},"./js/vendor/svg.path.js":function(module,exports){eval("/** svg.path.js - v0.6.0 - 2014-08-15\n * http://otm.github.io/svg.path.js/\n * Copyright (c) 2014 Nils Lagerkvist; Licensed under the  MIT license /\n */\n(function () {\n  var slice = Function.prototype.call.bind(Array.prototype.slice);\n  SVG.extend(SVG.Path, {\n    M: function M(p) {\n      p = arguments.length === 1 ? [p.x, p.y] : slice(arguments);\n      this.addSegment('M', p, this._redrawEnabled);\n\n      if (this._segments.length === 1) {\n        return this.plot('M' + p[0] + ' ' + p[1]);\n      }\n\n      return this;\n    },\n    m: function m(p) {\n      p = arguments.length === 1 ? [p.x, p.y] : slice(arguments);\n      this.addSegment('m', p, this._redrawEnabled);\n\n      if (this._segments.length === 1) {\n        return this.plot('m' + p[0] + ' ' + p[1]);\n      }\n\n      return this;\n    },\n    // TODO: Solve\n    L: function L(p) {\n      p = arguments.length === 1 ? [p.x, p.y] : slice(arguments);\n      return this.addSegment('L', p, this._redrawEnabled);\n    },\n    l: function l(p) {\n      p = arguments.length === 1 ? [p.x, p.y] : slice(arguments);\n      return this.addSegment('l', p, this._redrawEnabled);\n    },\n    H: function H(x) {\n      return this.addSegment('H', [x], this._redrawEnabled);\n    },\n    h: function h(x) {\n      return this.addSegment('h', [x], this._redrawEnabled);\n    },\n    V: function V(y) {\n      return this.addSegment('V', [y], this._redrawEnabled);\n    },\n    v: function v(y) {\n      return this.addSegment('v', [y], this._redrawEnabled);\n    },\n    C: function C(p1, p2, p) {\n      p = arguments.length === 3 ? [p1.x, p1.y, p2.x, p2.y, p.x, p.y] : slice(arguments);\n      return this.addSegment('C', p, this._redrawEnabled);\n    },\n    c: function c(p1, p2, p) {\n      p = arguments.length === 3 ? [p1.x, p1.y, p2.x, p2.y, p.x, p.y] : slice(arguments);\n      return this.addSegment('c', p, this._redrawEnabled);\n    },\n    S: function S(p2, p) {\n      p = arguments.length === 2 ? [p2.x, p2.y, p.x, p.y] : slice(arguments);\n      return this.addSegment('S', p, this._redrawEnabled);\n    },\n    s: function s(p2, p) {\n      p = arguments.length === 2 ? [p2.x, p2.y, p.x, p.y] : slice(arguments);\n      return this.addSegment('s', p, this._redrawEnabled);\n    },\n    // Q x1 y1, x y\n    Q: function Q(p1, p) {\n      p = arguments.length === 2 ? [p1.x, p1.y, p.x, p.y] : slice(arguments);\n      return this.addSegment('Q', p, this._redrawEnabled);\n    },\n    q: function q(p1, p) {\n      p = arguments.length === 2 ? [p1.x, p1.y, p.x, p.y] : slice(arguments);\n      return this.addSegment('q', p, this._redrawEnabled);\n    },\n    T: function T(p) {\n      p = arguments.length === 1 ? [p.x, p.y] : slice(arguments);\n      return this.addSegment('T', p, this._redrawEnabled);\n    },\n    t: function t(p) {\n      p = arguments.length === 1 ? [p.x, p.y] : slice(arguments);\n      return this.addSegment('t', p, this._redrawEnabled);\n    },\n    A: function A(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, p) {\n      p = arguments.length === 6 ? [rx, ry, xAxisRotation, largeArcFlag, sweepFlag, p.x, p.y] : slice(arguments);\n      return this.addSegment('A', p, this._redrawEnabled);\n    },\n    a: function a(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, p) {\n      p = arguments.length === 6 ? [rx, ry, xAxisRotation, largeArcFlag, sweepFlag, p.x, p.y] : slice(arguments);\n      return this.addSegment('a', p, this._redrawEnabled);\n    },\n    Z: function Z() {\n      return this.addSegment('Z', [], this._redrawEnabled);\n    },\n    // TODO: Add check that first element is moveto\n    addSegment: function addSegment(movement, coordinates, redraw) {\n      var segment = {\n        type: movement,\n        coords: coordinates\n      };\n\n      if (!this._segments) {\n        this._segments = [];\n      }\n\n      this._segments.push(segment);\n\n      if (redraw !== false) {\n        this._drawSegment(segment);\n      }\n\n      return this;\n    },\n    clearPath: function clearPath() {\n      if (this._segments) {\n        this._segments.length = 0;\n      }\n\n      this._lastSegment = null;\n      return this.plot();\n    },\n    getSegmentCount: function getSegmentCount() {\n      return this._segments.length;\n    },\n    getSegment: function getSegment(index) {\n      return this._segments[index];\n    },\n    removeSegment: function removeSegment(index) {\n      this._segments.splice(index, 1);\n\n      return this.redraw();\n    },\n    replaceSegment: function replaceSegment(index, segment) {\n      this._segments.splice(index, 1, segment);\n\n      return this.redraw();\n    },\n\n    /**\n     * Easing:\n     *\t<>: ease in and out\n     *\t>: ease out\n     *\t<: ease in\n     *\t-: linear\n     *\t=: external control\n     *\ta function\n     */\n    drawAnimated: function drawAnimated(options) {\n      options = options || {};\n      options.duration = options.duration || '1000';\n      options.easing = options.easing || '<>';\n      options.delay = options.delay || 0;\n      var length = this.length();\n      this.stroke({\n        width: 2,\n        dasharray: length + ' ' + length,\n        dashoffset: length\n      });\n      var fx = this.animate(options.duration, options.easing, options.delay);\n      fx.stroke({\n        dashoffset: 0\n      });\n      return this;\n    },\n    update: function update(redraw) {\n      if (redraw === true) this._redrawEnabled = false;\n      if (redraw === false) this._redrawEnabled = true;\n      return !!this._redrawEnabled;\n    },\n    redraw: function redraw() {\n      // reset\n      this._lastSegment = null;\n      this.attr('d', '');\n      return this._drawSegment(this._segments);\n    },\n    _drawSegment: function _drawSegment(segment) {\n      var str = '',\n          lastSegment = this._lastSegment;\n\n      if (!Array.isArray(segment)) {\n        segment = [segment];\n      }\n\n      for (var i = 0; i < segment.length; i += 1) {\n        if (lastSegment === segment[i].type) {\n          str += ' ' + segment[i].coords.join(' ');\n        } else {\n          str += ' ' + segment[i].type + segment[i].coords.join(' ');\n        }\n\n        lastSegment = segment[i].type;\n      }\n\n      this._lastSegment = lastSegment;\n      return this.attr('d', (this.attr('d') || '') + str);\n    }\n  });\n}).call(this);\n\n//# sourceURL=webpack:///./js/vendor/svg.path.js?")},"./js/vendor/svg.resize.js":function(module,exports){eval("/*!\n* svg.resize.js - An extension for svg.js which allows to resize elements which are selected\n* @version 1.4.3\n* https://github.com/svgdotjs/svg.resize.js\n*\n* @copyright [object Object]\n* @license MIT\n*/\n;\n;\n\n(function () {\n  \"use strict\";\n\n  ;\n  (function () {\n    function ResizeHandler(el) {\n      el.remember('_resizeHandler', this);\n      this.el = el;\n      this.parameters = {};\n      this.lastUpdateCall = null;\n      this.p = el.doc().node.createSVGPoint();\n    }\n\n    ResizeHandler.prototype.transformPoint = function (x, y, m) {\n      this.p.x = x - (this.offset.x - window.pageXOffset);\n      this.p.y = y - (this.offset.y - window.pageYOffset);\n      return this.p.matrixTransform(m || this.m);\n    };\n\n    ResizeHandler.prototype._extractPosition = function (event) {\n      // Extract a position from a mouse/touch event.\n      // Returns { x: .., y: .. }\n      return {\n        x: event.clientX != null ? event.clientX : event.touches[0].clientX,\n        y: event.clientY != null ? event.clientY : event.touches[0].clientY\n      };\n    };\n\n    ResizeHandler.prototype.init = function (options) {\n      var _this = this;\n\n      this.stop();\n\n      if (options === 'stop') {\n        return;\n      }\n\n      this.options = {}; // Merge options and defaults\n\n      for (var i in this.el.resize.defaults) {\n        this.options[i] = this.el.resize.defaults[i];\n\n        if (typeof options[i] !== 'undefined') {\n          this.options[i] = options[i];\n        }\n      } // We listen to all these events which are specifying different edges\n\n\n      this.el.on('lt.resize', function (e) {\n        _this.resize(e || window.event);\n      }); // Left-Top\n\n      this.el.on('rt.resize', function (e) {\n        _this.resize(e || window.event);\n      }); // Right-Top\n\n      this.el.on('rb.resize', function (e) {\n        _this.resize(e || window.event);\n      }); // Right-Bottom\n\n      this.el.on('lb.resize', function (e) {\n        _this.resize(e || window.event);\n      }); // Left-Bottom\n\n      this.el.on('t.resize', function (e) {\n        _this.resize(e || window.event);\n      }); // Top\n\n      this.el.on('r.resize', function (e) {\n        _this.resize(e || window.event);\n      }); // Right\n\n      this.el.on('b.resize', function (e) {\n        _this.resize(e || window.event);\n      }); // Bottom\n\n      this.el.on('l.resize', function (e) {\n        _this.resize(e || window.event);\n      }); // Left\n\n      this.el.on('rot.resize', function (e) {\n        _this.resize(e || window.event);\n      }); // Rotation\n\n      this.el.on('point.resize', function (e) {\n        _this.resize(e || window.event);\n      }); // Point-Moving\n      // This call ensures, that the plugin reacts to a change of snapToGrid immediately\n\n      this.update();\n    };\n\n    ResizeHandler.prototype.stop = function () {\n      this.el.off('lt.resize');\n      this.el.off('rt.resize');\n      this.el.off('rb.resize');\n      this.el.off('lb.resize');\n      this.el.off('t.resize');\n      this.el.off('r.resize');\n      this.el.off('b.resize');\n      this.el.off('l.resize');\n      this.el.off('rot.resize');\n      this.el.off('point.resize');\n      return this;\n    };\n\n    ResizeHandler.prototype.resize = function (event) {\n      var _this = this;\n\n      this.m = this.el.node.getScreenCTM().inverse();\n      this.offset = {\n        x: window.pageXOffset,\n        y: window.pageYOffset\n      };\n\n      var txPt = this._extractPosition(event.detail.event);\n\n      this.parameters = {\n        type: this.el.type,\n        // the type of element\n        p: this.transformPoint(txPt.x, txPt.y),\n        x: event.detail.x,\n        // x-position of the mouse when resizing started\n        y: event.detail.y,\n        // y-position of the mouse when resizing started\n        box: this.el.bbox(),\n        // The bounding-box of the element\n        rotation: this.el.transform().rotation // The current rotation of the element\n\n      };\n      this.resizeLimits = this.options.resizeLimits || this.resize.defaults.resizeLimits; // Add font-size parameter if the element type is text\n\n      if (this.el.type === \"text\") {\n        this.parameters.fontSize = this.el.attr()[\"font-size\"];\n      } // the i-param in the event holds the index of the point which is moved, when using `deepSelect`\n\n\n      if (event.detail.i !== undefined) {\n        // get the point array\n        var array = this.el.array().valueOf(); // Save the index and the point which is moved\n\n        this.parameters.i = event.detail.i;\n        this.parameters.pointCoords = [array[event.detail.i][0], array[event.detail.i][1]];\n      }\n\n      this._resizeLeft = function (snap, resizeFont, checkAspectRatio, checkAspectRatioReverse, updateOnlyChanges) {\n        if (this.parameters.box.width - snap[0] >= this.resizeLimits.width) {\n          if (checkAspectRatio) {\n            snap = this.checkAspectRatio(snap, checkAspectRatioReverse);\n          }\n\n          if (this.parameters.type === \"text\") {\n            if (resizeFont) {\n              this.el.move(this.parameters.box.x + snap[0], this.parameters.box.y);\n              this.el.attr(\"font-size\", this.parameters.fontSize - snap[0]);\n            }\n\n            return;\n          }\n\n          this.el.width(this.parameters.box.width - snap[0]);\n\n          if (updateOnlyChanges) {\n            this.el.x(this.parameters.box.x + snap[0]);\n          } else {\n            this.el.move(this.parameters.box.x + snap[0], this.parameters.box.y);\n          }\n        }\n      };\n\n      this._resizeRight = function (snap, resizeFont, checkAspectRatio, checkAspectRatioReverse) {\n        if (this.parameters.box.width + snap[0] >= this.resizeLimits.width) {\n          if (checkAspectRatio) {\n            snap = this.checkAspectRatio(snap, checkAspectRatioReverse);\n          }\n\n          if (this.parameters.type === \"text\") {\n            if (resizeFont) {\n              this.el.move(this.parameters.box.x - snap[0], this.parameters.box.y);\n              this.el.attr(\"font-size\", this.parameters.fontSize + snap[0]);\n            }\n\n            return;\n          }\n\n          this.el.x(this.parameters.box.x).width(this.parameters.box.width + snap[0]);\n        }\n      };\n\n      this._resizeTop = function (snap, checkAspectRatio, checkAspectRatioReverse, updateOnlyChanges) {\n        if (this.parameters.box.height - snap[1] >= this.resizeLimits.height) {\n          if (checkAspectRatio) {\n            snap = this.checkAspectRatio(snap, checkAspectRatioReverse);\n          } // Disable the font-resizing if it is not from the corner of bounding-box\n\n\n          if (this.parameters.type === \"text\") {\n            return;\n          }\n\n          this.el.height(this.parameters.box.height - snap[1]);\n\n          if (updateOnlyChanges) {\n            this.el.y(this.parameters.box.y + snap[1]);\n          } else {\n            this.el.move(this.parameters.box.x, this.parameters.box.y + snap[1]);\n          }\n        }\n      };\n\n      this._resizeBottom = function (snap, checkAspectRatio, checkAspectRatioReverse) {\n        if (this.parameters.box.height + snap[1] >= this.resizeLimits.height) {\n          if (checkAspectRatio) {\n            snap = this.checkAspectRatio(snap, checkAspectRatioReverse);\n          }\n\n          if (this.parameters.type === \"text\") {\n            return;\n          }\n\n          this.el.y(this.parameters.box.y).height(this.parameters.box.height + snap[1]);\n        }\n      }; // Lets check which edge of the bounding-box was clicked and resize the this.el according to this\n\n\n      switch (event.type) {\n        // Left-Top-Edge\n        case 'lt':\n          // We build a calculating function for every case which gives us the new position of the this.el\n          this.calc = function (diffX, diffY) {\n            // The procedure is always the same\n            // First we snap the edge to the given grid (snapping to 1px grid is normal resizing)\n            var snap = this.snapToGrid(diffX, diffY);\n\n            this._resizeTop(snap, true, false, true);\n\n            this._resizeLeft(snap, true, true, false, true);\n          };\n\n          break;\n        // Right-Top\n\n        case 'rt':\n          // s.a.\n          this.calc = function (diffX, diffY) {\n            var snap = this.snapToGrid(diffX, diffY, 1 << 1);\n\n            this._resizeTop(snap, true, true, true);\n\n            this._resizeRight(snap, true, true, true);\n          };\n\n          break;\n        // Right-Bottom\n\n        case 'rb':\n          // s.a.\n          this.calc = function (diffX, diffY) {\n            var snap = this.snapToGrid(diffX, diffY, 0);\n\n            this._resizeBottom(snap, true);\n\n            this._resizeRight(snap, true, true);\n          };\n\n          break;\n        // Left-Bottom\n\n        case 'lb':\n          // s.a.\n          this.calc = function (diffX, diffY) {\n            var snap = this.snapToGrid(diffX, diffY, 1);\n\n            this._resizeBottom(snap, true, true);\n\n            this._resizeLeft(snap, true, true, true, true);\n          };\n\n          break;\n        // Top\n\n        case 't':\n          // s.a.\n          this.calc = function (diffX, diffY) {\n            var snap = this.snapToGrid(diffX, diffY, 1 << 1);\n\n            this._resizeTop(snap);\n          };\n\n          break;\n        // Right\n\n        case 'r':\n          // s.a.\n          this.calc = function (diffX, diffY) {\n            var snap = this.snapToGrid(diffX, diffY, 0);\n\n            this._resizeRight(snap);\n          };\n\n          break;\n        // Bottom\n\n        case 'b':\n          // s.a.\n          this.calc = function (diffX, diffY) {\n            var snap = this.snapToGrid(diffX, diffY, 0);\n\n            this._resizeBottom(snap);\n          };\n\n          break;\n        // Left\n\n        case 'l':\n          // s.a.\n          this.calc = function (diffX, diffY) {\n            var snap = this.snapToGrid(diffX, diffY, 1);\n\n            this._resizeLeft(snap);\n          };\n\n          break;\n        // Rotation\n\n        case 'rot':\n          // s.a.\n          this.calc = function (diffX, diffY) {\n            // yes this is kinda stupid but we need the mouse coords back...\n            var current = {\n              x: diffX + this.parameters.p.x,\n              y: diffY + this.parameters.p.y\n            }; // start minus middle\n\n            var sAngle = Math.atan2(this.parameters.p.y - this.parameters.box.y - this.parameters.box.height / 2, this.parameters.p.x - this.parameters.box.x - this.parameters.box.width / 2); // end minus middle\n\n            var pAngle = Math.atan2(current.y - this.parameters.box.y - this.parameters.box.height / 2, current.x - this.parameters.box.x - this.parameters.box.width / 2);\n            var angle = this.parameters.rotation + (pAngle - sAngle) * 180 / Math.PI + this.options.snapToAngle / 2; // We have to move the element to the center of the box first and change the rotation afterwards\n            // because rotation always works around a rotation-center, which is changed when moving the element\n            // We also set the new rotation center to the center of the box.\n\n            this.el.center(this.parameters.box.cx, this.parameters.box.cy).rotate(angle - angle % this.options.snapToAngle, this.parameters.box.cx, this.parameters.box.cy);\n          };\n\n          break;\n        // Moving one single Point (needed when an element is deepSelected which means you can move every single point of the object)\n\n        case 'point':\n          this.calc = function (diffX, diffY) {\n            // Snapping the point to the grid\n            var snap = this.snapToGrid(diffX, diffY, this.parameters.pointCoords[0], this.parameters.pointCoords[1]); // Get the point array\n\n            var array = this.el.array().valueOf(); // Changing the moved point in the array\n\n            array[this.parameters.i][0] = this.parameters.pointCoords[0] + snap[0];\n            array[this.parameters.i][1] = this.parameters.pointCoords[1] + snap[1]; // And plot the new this.el\n\n            this.el.plot(array);\n          };\n\n      }\n\n      this.el.fire('resizestart', {\n        dx: this.parameters.x,\n        dy: this.parameters.y,\n        event: event\n      }); // When resizing started, we have to register events for...\n      // Touches.\n\n      SVG.on(window, 'touchmove.resize', function (e) {\n        _this.update(e || window.event);\n      });\n      SVG.on(window, 'touchend.resize', function () {\n        _this.done();\n      }); // Mouse.\n\n      SVG.on(window, 'mousemove.resize', function (e) {\n        _this.update(e || window.event);\n      });\n      SVG.on(window, 'mouseup.resize', function () {\n        _this.done();\n      });\n    }; // The update-function redraws the element every time the mouse is moving\n\n\n    ResizeHandler.prototype.update = function (event) {\n      if (!event) {\n        if (this.lastUpdateCall) {\n          this.calc(this.lastUpdateCall[0], this.lastUpdateCall[1]);\n        }\n\n        return;\n      } // Calculate the difference between the mouseposition at start and now\n\n\n      var txPt = this._extractPosition(event);\n\n      var p = this.transformPoint(txPt.x, txPt.y);\n      var diffX = p.x - this.parameters.p.x,\n          diffY = p.y - this.parameters.p.y;\n      this.lastUpdateCall = [diffX, diffY]; // Calculate the new position and height / width of the element\n\n      this.calc(diffX, diffY); // Emit an event to say we have changed.\n\n      this.el.fire('resizing', {\n        dx: diffX,\n        dy: diffY,\n        event: event\n      });\n    }; // Is called on mouseup.\n    // Removes the update-function from the mousemove event\n\n\n    ResizeHandler.prototype.done = function () {\n      this.lastUpdateCall = null;\n      SVG.off(window, 'mousemove.resize');\n      SVG.off(window, 'mouseup.resize');\n      SVG.off(window, 'touchmove.resize');\n      SVG.off(window, 'touchend.resize');\n      this.el.fire('resizedone');\n    }; // The flag is used to determine whether the resizing is used with a left-Point (first bit) and top-point (second bit)\n    // In this cases the temp-values are calculated differently\n\n\n    ResizeHandler.prototype.snapToGrid = function (diffX, diffY, flag, pointCoordsY) {\n      var temp; // If `pointCoordsY` is given, a single Point has to be snapped (deepSelect). That's why we need a different temp-value\n\n      if (typeof pointCoordsY !== 'undefined') {\n        // Note that flag = pointCoordsX in this case\n        temp = [(flag + diffX) % this.options.snapToGrid, (pointCoordsY + diffY) % this.options.snapToGrid];\n      } else {\n        // We check if the flag is set and if not we set a default-value (both bits set - which means upper-left-edge)\n        flag = flag == null ? 1 | 1 << 1 : flag;\n        temp = [(this.parameters.box.x + diffX + (flag & 1 ? 0 : this.parameters.box.width)) % this.options.snapToGrid, (this.parameters.box.y + diffY + (flag & 1 << 1 ? 0 : this.parameters.box.height)) % this.options.snapToGrid];\n      }\n\n      if (diffX < 0) {\n        temp[0] -= this.options.snapToGrid;\n      }\n\n      if (diffY < 0) {\n        temp[1] -= this.options.snapToGrid;\n      }\n\n      diffX -= Math.abs(temp[0]) < this.options.snapToGrid / 2 ? temp[0] : temp[0] - (diffX < 0 ? -this.options.snapToGrid : this.options.snapToGrid);\n      diffY -= Math.abs(temp[1]) < this.options.snapToGrid / 2 ? temp[1] : temp[1] - (diffY < 0 ? -this.options.snapToGrid : this.options.snapToGrid);\n      return this.constraintToBox(diffX, diffY, flag, pointCoordsY);\n    }; // keep element within constrained box\n\n\n    ResizeHandler.prototype.constraintToBox = function (diffX, diffY, flag, pointCoordsY) {\n      //return [diffX, diffY]\n      var c = this.options.constraint || {};\n      var orgX, orgY;\n\n      if (typeof pointCoordsY !== 'undefined') {\n        orgX = flag;\n        orgY = pointCoordsY;\n      } else {\n        orgX = this.parameters.box.x + (flag & 1 ? 0 : this.parameters.box.width);\n        orgY = this.parameters.box.y + (flag & 1 << 1 ? 0 : this.parameters.box.height);\n      }\n\n      if (typeof c.minX !== 'undefined' && orgX + diffX < c.minX) {\n        diffX = c.minX - orgX;\n      }\n\n      if (typeof c.maxX !== 'undefined' && orgX + diffX > c.maxX) {\n        diffX = c.maxX - orgX;\n      }\n\n      if (typeof c.minY !== 'undefined' && orgY + diffY < c.minY) {\n        diffY = c.minY - orgY;\n      }\n\n      if (typeof c.maxY !== 'undefined' && orgY + diffY > c.maxY) {\n        diffY = c.maxY - orgY;\n      }\n\n      return [diffX, diffY];\n    };\n\n    ResizeHandler.prototype.checkAspectRatio = function (snap, isReverse) {\n      if (!this.options.saveAspectRatio) {\n        return snap;\n      }\n\n      var updatedSnap = snap.slice();\n      var aspectRatio = this.parameters.box.width / this.parameters.box.height;\n      var newW = this.parameters.box.width + snap[0];\n      var newH = this.parameters.box.height - snap[1];\n      var newAspectRatio = newW / newH;\n\n      if (newAspectRatio < aspectRatio) {\n        // Height is too big. Adapt it\n        updatedSnap[1] = newW / aspectRatio - this.parameters.box.height;\n        isReverse && (updatedSnap[1] = -updatedSnap[1]);\n      } else if (newAspectRatio > aspectRatio) {\n        // Width is too big. Adapt it\n        updatedSnap[0] = this.parameters.box.width - newH * aspectRatio;\n        isReverse && (updatedSnap[0] = -updatedSnap[0]);\n      }\n\n      return updatedSnap;\n    };\n\n    SVG.extend(SVG.Element, {\n      // Resize element with mouse\n      resize: function resize(options) {\n        (this.remember('_resizeHandler') || new ResizeHandler(this)).init(options || {});\n        return this;\n      }\n    });\n    SVG.Element.prototype.resize.defaults = {\n      snapToAngle: 0.1,\n      // Specifies the speed the rotation is happening when moving the mouse\n      snapToGrid: 1,\n      // Snaps to a grid of `snapToGrid` Pixels\n      constraint: {},\n      // keep element within constrained box\n      resizeLimits: {\n        width: 0,\n        height: 0\n      },\n      // rect limit size on resize\n      saveAspectRatio: false // Save aspect ratio when resizing using lt, rt, rb or lb points\n\n    };\n  }).call(this);\n})();\n\n//# sourceURL=webpack:///./js/vendor/svg.resize.js?")},"./js/vendor/svg.select.js":function(module,exports){eval("function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/*!\n* svg.select.js - An extension of svg.js which allows to select elements with mouse\n* @version 3.0.1\n* https://github.com/svgdotjs/svg.select.js\n*\n* @copyright Ulrich-Matthias Schäfer\n* @license MIT\n*/\n;\n;\n\n(function () {\n  \"use strict\";\n\n  function SelectHandler(el) {\n    this.el = el;\n    el.remember('_selectHandler', this);\n    this.pointSelection = {\n      isSelected: false\n    };\n    this.rectSelection = {\n      isSelected: false\n    }; // helper list with position settings of each type of point\n\n    this.pointsList = {\n      lt: [0, 0],\n      rt: ['width', 0],\n      rb: ['width', 'height'],\n      lb: [0, 'height'],\n      t: ['width', 0],\n      r: ['width', 'height'],\n      b: ['width', 'height'],\n      l: [0, 'height']\n    }; // helper function to get point coordinates based on settings above and an object (bbox in our case)\n\n    this.pointCoord = function (setting, object, isPointCentered) {\n      var coord = typeof setting !== 'string' ? setting : object[setting]; // Top, bottom, right and left points are placed in the center of element width/height\n\n      return isPointCentered ? coord / 2 : coord;\n    };\n\n    this.pointCoords = function (point, object) {\n      var settings = this.pointsList[point];\n      return {\n        x: this.pointCoord(settings[0], object, point === 't' || point === 'b'),\n        y: this.pointCoord(settings[1], object, point === 'r' || point === 'l')\n      };\n    };\n  }\n\n  SelectHandler.prototype.init = function (value, options) {\n    var bbox = this.el.bbox();\n    this.options = {}; // store defaults list of points in order to verify users config\n\n    var points = this.el.selectize.defaults.points; // Merging the defaults and the options-object together\n\n    for (var i in this.el.selectize.defaults) {\n      this.options[i] = this.el.selectize.defaults[i];\n\n      if (options[i] !== undefined) {\n        this.options[i] = options[i];\n      }\n    } // prepare & validate list of points to be added (or excluded)\n\n\n    var pointsLists = ['points', 'pointsExclude'];\n\n    for (var i in pointsLists) {\n      var option = this.options[pointsLists[i]];\n\n      if (typeof option === 'string') {\n        if (option.length > 0) {\n          // if set as comma separated string list => convert it into an array\n          option = option.split(/\\s*,\\s*/i);\n        } else {\n          option = [];\n        }\n      } else if (typeof option === 'boolean' && pointsLists[i] === 'points') {\n        // this is not needed, but let's have it for legacy support\n        option = option ? points : [];\n      }\n\n      this.options[pointsLists[i]] = option;\n    } // intersect correct all points options with users config (exclude unwanted points)\n    // ES5 -> NO arrow functions nor Array.includes()\n\n\n    this.options.points = [points, this.options.points].reduce(function (a, b) {\n      return a.filter(function (c) {\n        return b.indexOf(c) > -1;\n      });\n    }); // exclude pointsExclude, if wanted\n\n    this.options.points = [this.options.points, this.options.pointsExclude].reduce(function (a, b) {\n      return a.filter(function (c) {\n        return b.indexOf(c) < 0;\n      });\n    });\n    this.parent = this.el.parent();\n    this.nested = this.nested || this.parent.group();\n    this.nested.matrix(new SVG.Matrix(this.el).translate(bbox.x, bbox.y)); // When deepSelect is enabled and the element is a line/polyline/polygon, draw only points for moving\n\n    if (this.options.deepSelect && ['line', 'polyline', 'polygon'].indexOf(this.el.type) !== -1) {\n      this.selectPoints(value);\n    } else {\n      this.selectRect(value);\n    }\n\n    this.observe();\n    this.cleanup();\n  };\n\n  SelectHandler.prototype.selectPoints = function (value) {\n    this.pointSelection.isSelected = value; // When set is already there we dont have to create one\n\n    if (this.pointSelection.set) {\n      return this;\n    } // Create our set of elements\n\n\n    this.pointSelection.set = this.parent.set(); // draw the points and mark the element as selected\n\n    this.drawPoints();\n    return this;\n  }; // create the point-array which contains the 2 points of a line or simply the points-array of polyline/polygon\n\n\n  SelectHandler.prototype.getPointArray = function () {\n    var bbox = this.el.bbox();\n    return this.el.array().valueOf().map(function (el) {\n      return [el[0] - bbox.x, el[1] - bbox.y];\n    });\n  }; // Draws a points\n\n\n  SelectHandler.prototype.drawPoints = function () {\n    var _this = this,\n        array = this.getPointArray(); // go through the array of points\n\n\n    for (var i = 0, len = array.length; i < len; ++i) {\n      var curriedEvent = function (k) {\n        return function (ev) {\n          ev = ev || window.event;\n          ev.preventDefault ? ev.preventDefault() : ev.returnValue = false;\n          ev.stopPropagation();\n          var x = ev.pageX || ev.touches[0].pageX;\n          var y = ev.pageY || ev.touches[0].pageY;\n\n          _this.el.fire('point', {\n            x: x,\n            y: y,\n            i: k,\n            event: ev\n          });\n        };\n      }(i); // add every point to the set\n      // add css-classes and a touchstart-event which fires our event for moving points\n\n\n      var point = this.drawPoint(array[i][0], array[i][1]).addClass(this.options.classPoints).addClass(this.options.classPoints + '_point').on('touchstart', curriedEvent).on('mousedown', curriedEvent);\n      this.pointSelection.set.add(point);\n    }\n  }; // The function to draw single point\n\n\n  SelectHandler.prototype.drawPoint = function (cx, cy) {\n    var pointType = this.options.pointType;\n\n    switch (pointType) {\n      case 'circle':\n        return this.drawCircle(cx, cy);\n\n      case 'rect':\n        return this.drawRect(cx, cy);\n\n      default:\n        if (typeof pointType === 'function') {\n          return pointType.call(this, cx, cy);\n        }\n\n        throw new Error('Unknown ' + pointType + ' point type!');\n    }\n  }; // The function to draw the circle point\n\n\n  SelectHandler.prototype.drawCircle = function (cx, cy) {\n    return this.nested.circle(this.options.pointSize).stroke(this.options.pointStroke).fill(this.options.pointFill).center(cx, cy);\n  }; // The function to draw the rect point\n\n\n  SelectHandler.prototype.drawRect = function (cx, cy) {\n    return this.nested.rect(this.options.pointSize, this.options.pointSize).stroke(this.options.pointStroke).fill(this.options.pointFill).center(cx, cy);\n  }; // every time a point is moved, we have to update the positions of our point\n\n\n  SelectHandler.prototype.updatePointSelection = function () {\n    var array = this.getPointArray();\n    this.pointSelection.set.each(function (i) {\n      if (this.cx() === array[i][0] && this.cy() === array[i][1]) {\n        return;\n      }\n\n      this.center(array[i][0], array[i][1]);\n    });\n  };\n\n  SelectHandler.prototype.updateRectSelection = function () {\n    var _this = this,\n        bbox = this.el.bbox();\n\n    this.rectSelection.set.get(0).attr({\n      width: bbox.width,\n      height: bbox.height\n    }); // set.get(1) is always in the upper left corner. no need to move it\n\n    if (this.options.points.length) {\n      this.options.points.map(function (point, index) {\n        var coords = _this.pointCoords(point, bbox);\n\n        _this.rectSelection.set.get(index + 1).center(coords.x, coords.y);\n      });\n    }\n\n    if (this.options.rotationPoint) {\n      var length = this.rectSelection.set.length();\n      this.rectSelection.set.get(length - 1).center(bbox.width / 2, 20);\n    }\n  };\n\n  SelectHandler.prototype.selectRect = function (value) {\n    var _this = this,\n        bbox = this.el.bbox();\n\n    this.rectSelection.isSelected = value; // when set is already p\n\n    this.rectSelection.set = this.rectSelection.set || this.parent.set(); // helperFunction to create a mouse-down function which triggers the event specified in `eventName`\n\n    function getMoseDownFunc(eventName) {\n      return function (ev) {\n        ev = ev || window.event;\n        ev.preventDefault ? ev.preventDefault() : ev.returnValue = false;\n        ev.stopPropagation();\n        var x = ev.pageX || ev.touches[0].pageX;\n        var y = ev.pageY || ev.touches[0].pageY;\n\n        _this.el.fire(eventName, {\n          x: x,\n          y: y,\n          event: ev\n        });\n      };\n    } // create the selection-rectangle and add the css-class\n\n\n    if (!this.rectSelection.set.get(0)) {\n      this.rectSelection.set.add(this.nested.rect(bbox.width, bbox.height).addClass(this.options.classRect));\n    } // Draw Points at the edges, if enabled\n\n\n    if (this.options.points.length && this.rectSelection.set.length() < 2) {\n      var ename = \"touchstart\",\n          mname = \"mousedown\";\n      this.options.points.map(function (point, index) {\n        var coords = _this.pointCoords(point, bbox);\n\n        var pointElement = _this.drawPoint(coords.x, coords.y).attr('class', _this.options.classPoints + '_' + point).on(mname, getMoseDownFunc(point)).on(ename, getMoseDownFunc(point));\n\n        _this.rectSelection.set.add(pointElement);\n      });\n      this.rectSelection.set.each(function () {\n        this.addClass(_this.options.classPoints);\n      });\n    } // draw rotationPint, if enabled\n\n\n    if (this.options.rotationPoint && (this.options.points && !this.rectSelection.set.get(9) || !this.options.points && !this.rectSelection.set.get(1))) {\n      var curriedEvent = function curriedEvent(ev) {\n        ev = ev || window.event;\n        ev.preventDefault ? ev.preventDefault() : ev.returnValue = false;\n        ev.stopPropagation();\n        var x = ev.pageX || ev.touches[0].pageX;\n        var y = ev.pageY || ev.touches[0].pageY;\n\n        _this.el.fire('rot', {\n          x: x,\n          y: y,\n          event: ev\n        });\n      };\n\n      var pointElement = this.drawPoint(bbox.width / 2, 20).attr('class', this.options.classPoints + '_rot').on(\"touchstart\", curriedEvent).on(\"mousedown\", curriedEvent);\n      this.rectSelection.set.add(pointElement);\n    }\n  };\n\n  SelectHandler.prototype.handler = function () {\n    var bbox = this.el.bbox();\n    this.nested.matrix(new SVG.Matrix(this.el).translate(bbox.x, bbox.y));\n\n    if (this.rectSelection.isSelected) {\n      this.updateRectSelection();\n    }\n\n    if (this.pointSelection.isSelected) {\n      this.updatePointSelection();\n    }\n  };\n\n  SelectHandler.prototype.observe = function () {\n    var _this = this;\n\n    if (MutationObserver) {\n      if (this.rectSelection.isSelected || this.pointSelection.isSelected) {\n        this.observerInst = this.observerInst || new MutationObserver(function () {\n          _this.handler();\n        });\n        this.observerInst.observe(this.el.node, {\n          attributes: true\n        });\n      } else {\n        try {\n          this.observerInst.disconnect();\n          delete this.observerInst;\n        } catch (e) {}\n      }\n    } else {\n      this.el.off('DOMAttrModified.select');\n\n      if (this.rectSelection.isSelected || this.pointSelection.isSelected) {\n        this.el.on('DOMAttrModified.select', function () {\n          _this.handler();\n        });\n      }\n    }\n  };\n\n  SelectHandler.prototype.cleanup = function () {\n    //var _this = this;\n    if (!this.rectSelection.isSelected && this.rectSelection.set) {\n      // stop watching the element, remove the selection\n      this.rectSelection.set.each(function () {\n        this.remove();\n      });\n      this.rectSelection.set.clear();\n      delete this.rectSelection.set;\n    }\n\n    if (!this.pointSelection.isSelected && this.pointSelection.set) {\n      // Remove all points, clear the set, stop watching the element\n      this.pointSelection.set.each(function () {\n        this.remove();\n      });\n      this.pointSelection.set.clear();\n      delete this.pointSelection.set;\n    }\n\n    if (!this.pointSelection.isSelected && !this.rectSelection.isSelected) {\n      this.nested.remove();\n      delete this.nested;\n    }\n  };\n\n  SVG.extend(SVG.Element, {\n    // Select element with mouse\n    selectize: function selectize(value, options) {\n      // Check the parameters and reassign if needed\n      if (_typeof(value) === 'object') {\n        options = value;\n        value = true;\n      }\n\n      var selectHandler = this.remember('_selectHandler') || new SelectHandler(this);\n      selectHandler.init(value === undefined ? true : value, options || {});\n      return this;\n    }\n  });\n  SVG.Element.prototype.selectize.defaults = {\n    points: ['lt', 'rt', 'rb', 'lb', 't', 'r', 'b', 'l'],\n    // which points to draw, default all\n    pointsExclude: [],\n    // easier option if to exclude few than rewrite all\n    classRect: 'svg_select_boundingRect',\n    // Css-class added to the rect\n    classPoints: 'svg_select_points',\n    // Css-class added to the points\n    pointSize: 7,\n    // size of point\n    rotationPoint: true,\n    // If true, rotation point is drawn. Needed for rotation!\n    deepSelect: false,\n    // If true, moving of single points is possible (only line, polyline, polyon)\n    pointType: 'circle',\n    // Point type: circle or rect, default circle\n    pointFill: \"#000\",\n    // Point fill color\n    pointStroke: {\n      width: 1,\n      color: \"#000\"\n    } // Point stroke properties\n\n  };\n})();\n\n//# sourceURL=webpack:///./js/vendor/svg.select.js?")}});